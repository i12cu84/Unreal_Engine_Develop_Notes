```
#include <iostream>
#include <bit>
int main()
{
    if constexpr (std::endian::native == std::endian::big)
        std::cout << "Big endian" << '\n';
    else if constexpr (std::endian::native == std::endian::little)
        std::cout << "Little endian" << '\n';
    else
        std::cout << "Unknown endian" << '\n';
    return 0;
}
```
使用std::endian::native来检查本机的字节序。
如果本机是大端字节序，我们打印"Big endian"；
如果本机是小端字节序，我们打印"Little endian"；
否则，我们打印"Unknown endian"。

另外，
字节序，又称端序或尾序，指的是多字节数据在计算机内存中或在数字通信链路中的存储顺序。
例如，一个int型变量占用4个字节，假设它的起始地址为0x10，那么这个变量将会被存储在0x10、0x11、0x12和0x13位置上。
字节序主要有两种类型：
大端字节序：高位字节存储在内存的低地址上，低位字节存储在内存的高位地址上。
这种排列方式与数据用字节表示时的书写顺序一致，符合人类的阅读习惯。
小端字节序：高位字节存储在内存的高地址上，低位字节存储在内存的低地址上。
小端序与人类的阅读习惯相反，但更符合计算机读取内存的方式，因为CPU读取内存中的数据时，是从低地址向高地址方向进行读取的。
例如，对于数据0x01020304，它的大端和小端字节序在内存中的布局如下：
大端字节序：0x01（高位字节）存储在低地址处，0x02、0x03和0x04依次存储在较高的地址处。
小端字节序：0x04（低位字节）存储在低地址处，0x03、0x02和0x01（高位字节）依次存储在较高的地址处。
需要注意的是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。
所以，计算机的内部处理都是小端字节序。
但是，在其他场合比如网络传输和文件储存，几乎都是用的大端字节序。
这就是为什么会有字节序这一说法。