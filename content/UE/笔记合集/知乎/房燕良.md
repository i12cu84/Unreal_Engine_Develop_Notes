
<details>
<summary>目录·蓝图扩展概述</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/84954473
虚幻引擎的蓝图是一种基于节点的可视化脚本编程系统，对它的扩展也就主要是生成新的功能节点了。目前在工作中要到的蓝图扩展方式主要有以下几种：

蓝图宏（Blueprint Macros）可以把一系列节点组成的操作包装成一个节点；
使用C++编写蓝图可调用的UFunction，则蓝图编辑器会自动生成对应的蓝图节点，这是最常用的一种方式；
通过派生蓝图节点的基类：class UK2Node，可以灵活的定制节点的各种行为，典型的是“动态添加/删除针脚（pin）”的需求。这个派生类对应的功能逻辑主要通过重载父类的两个行为接口来实现：Expand Node和Node Handling Functor。
这个专栏主要是谈C++编程的扩展方式，所处蓝图宏就不谈了，官方的文档说的比较清楚，也很易用。一般性的UFunction扩展方式，官方文档也比较详细，也就不赘述了。

这个专栏主要讲2,3中的内容，特别是官方没什么文档的那些功能如何实现。具体的内容规划如下（以下文章建议按顺序阅读）：

通过实现一个派生类，轻松完成异步操作的蓝图节点封装：
将异步操作封装为蓝图节点
69 赞同 · 6 评论文章

通过自定义Thunk函数实现指出“通配符”参数的“UFunction模板函数”节点：
实现蓝图模板函数
58 赞同 · 1 评论文章

详细讲解“通过派生class UK2Node”创建自定义蓝图节点的步骤：
通过派生class UK2Node创建自定义蓝图节点
31 赞同 · 3 评论文章

实现蓝图节点的动态添加/删除Pin：
实现蓝图节点的动态添加/删除Pin
30 赞同 · 5 评论文章

通过派生FNodeHandlingFunctor 实现自定义class UK2Node派生类自定义蓝图节点的编译，控制编译过程中statement、terminal、net的生成或配置：
使用Node Handler定制蓝图节点的编译过程
33 赞同 · 3 评论文章

通过讲解蓝图编辑器的技术架构，以及蓝图虚拟机的运行机制，深入的理解蓝图：
理解蓝图技术架构
202 赞同 · 14 评论文章

以上这些内容，主要是笔者通过阅读引擎源代码，加上一些试验验证之后，总结出来的。希望对大家有所帮助。如果有不够准确的地方，还请指出。:)

最后，夹带点私货吧：

游戏程序员的自我修养
​neil3d.gitee.io
这是我的GitHub Page，欢迎访问。:D
</code></pre>
</details>

<details>
<summary>实现蓝图模板函数</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/84956153
Unreal的蓝图和C++一样，也是一种静态类型的编程语言，但它又不像其他静态类型语言那样支持模板，有些时候就觉得很不方便。蓝图节点支持任意类型的参数这种需求，主要分为两种情况：

UObject派生类对象：那很简单了，使用基类指针作为参数就好，在C++里面可以Cast，或者取得对象的UClass，就可以根据反射信息做很多事了；
Struct类型，或者TArray<MyStruct>类型：这个是本文的重点。
其实说蓝图完全不支持“模板”也是不对的，引擎中其实已经有很多能够处理任意Struct或者TArray<MyStruct>类型的节点了！官方文档中把这种情况叫做参数“Wildcard”（通配符）。感谢Unreal开源，通过阅读源代码，加上一点实验，就能够搞清楚具体实现方法和背后的细节。

下面主要探讨使用UFUNCTION的CustomThunk描述符，实现自定义的Thunk函数；然后通过指定meta的CustomStructureParam和ArrayParm参数，来实现参数类型“通配符”！这中间的难点是：需要明确蓝图Stack的处理方式。Demo如下图所示：


在上图的Demo中：

自定义了一个蓝图Struct：MyStruct
使用C++实现了一个蓝图节点“Show Struct Fields”：可以接受任意UStruct的引用，具体类型可以由C++或者蓝图定义；
蓝图节点“Array Numeric Field Average”：可以接受任意类型的TArray<MyStruct>，并对数组中指定的数值型字段求平均；
完整的Demo工程可以从我的GitHub下载：

UnrealCookBook/MyBlueprintNode
​github.com/neil3d/UnrealCookBook/tree/master/MyBlueprintNode

UFunction与蓝图节点
在Unreal开发中可以使用C++对蓝图进行扩展，生成Unreal蓝图节点最方便的方法就是写一个UFUNCTION，无论是定义在UBlueprintFunctionLibrary派生类里面的static函数，还是定义在UObject、AActor派生类里面的类成员函数，只要加上UFUNCTION宏修饰，并在宏里面添加BlueprintCallable标识符，就可以自动完成蓝图编辑节点、蓝图节点执行调用的整个过程。不过，由于C++和蓝图都属于“静态类型”编程语言，这种形式编写的蓝图节点，所有的输入、输出参数的类型都必须是固定的，这样引擎才能自动处理蓝图虚拟机的栈。

在UFUNCTION中允许使用一个特殊的标识符：“CustomThunk”，告诉UHT（Unreal Header Tool）不要生成默认的蓝图包装函数，而是由我们手工实现。这种方式，需要手工控制蓝图虚拟机的“栈”。再结合UFUNCTION的其它meta标识符，可以实现参数类型的“通配符”，就可以实现模板函数，也就是输入、输出参数可以处理多种数据类型，类似C++的泛型。这些meta标识符主要有：

ArrayParm="Parameter1, Parameter2, .."：说明 BlueprintCallable 函数应使用一个Call Array Function节点，且列出的参数应被视为通配符数组属性；
ArrayTypeDependentParams="Parameter"：使用 ArrayParm 时，此说明符将指定一个参数，其将确定 ArrayParm 列表中所有参数的类型；
CustomStructureParam="Parameter1, Parameter2, .."：列出的参数都会被视为通配符。
引擎源代码中，这种编程方式的典型的例子有：

蓝图编辑器中的“Utilities”->“Array”菜单中的所有节点，他们可以处理任意的UStruct类型的数组。这些节点对应的源代码是：class UKismetArrayLibrary
class UDataTableFunctionLibrary::GetDataTableRowFromName(UDataTable* Table, FName RowName, FTableRowBase& OutRow)
详见官方文档：UFunctions
CustomThunk函数
如果在UFUNCTION宏里面指定了CustomThunk，那么UHT就不会自动生成这个函数的“thunk”，而需要开发者自己实现。这里的“thunk”是什么呢？我们看个例子。

我们来做个最简单的小试验，在工程中建立一个Blueprint Function Library，添加一个简单的UFUNCTION：

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "MyBlueprintFunctionLibrary.generated.h"

UCLASS()
class MYBLUEPRINTNODES_API UMyBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()
public:
    UFUNCTION(BlueprintCallable)
    static int Sum(int a, int b);
};
然后在对应的cpp文件中，使用C++实现这个函数：

#include "MyBlueprintFunctionLibrary.h"

int UMyBlueprintFunctionLibrary::Sum(int a, int b) {
    return a + b;
}
项目build一下，然后你就可以在“Intermediate”目录找到这个"MyBlueprintFunctionLibrary.generated.h"文件。在这个文件里面，你可以找到这样一段代码：

DECLARE_FUNCTION(execSum) \
    { \
        P_GET_PROPERTY(UIntProperty,Z_Param_a); \
        P_GET_PROPERTY(UIntProperty,Z_Param_b); \
        P_FINISH; \
        P_NATIVE_BEGIN; \
        *(int32*)Z_Param__Result=UMyBlueprintFunctionLibrary::Sum(Z_Param_a,Z_Param_b); \
        P_NATIVE_END; \
    }
这段代码就是蓝图函数节点的thunk了！这段代码做了这样几件事：

声明了一个名为“execSum”的函数，函数的签名为：void func( UObject* Context, FFrame& Stack, RESULT_DECL )
使用P_GET_PROPERTY宏，从“FFrame& Stack”（也就是蓝图虚拟机的栈）中取出函数参数；
调用P_FINISH宏；
使用取出的这些参数调用我们实现的UMyBlueprintFunctionLibrary::Sum()函数；
“thunk”函数是一个包装，它完成的核心任务就是处理蓝图虚拟机的Stack，然后调用我们使用C++实现的函数。

我们还可以看一下UHT帮我们生成的另外一个文件：MyBlueprintFunctionLibrary.gen.cpp，在其中有这样一段代码：

void UMyBlueprintFunctionLibrary::StaticRegisterNativesUMyBlueprintFunctionLibrary()
    {
        UClass* Class = UMyBlueprintFunctionLibrary::StaticClass();
        static const FNameNativePtrPair Funcs[] = {
            { "Sum", &UMyBlueprintFunctionLibrary::execSum },
        };
        FNativeFunctionRegistrar::RegisterFunctions(Class, Funcs, ARRAY_COUNT(Funcs));
    }
这段代码把刚才"MyBlueprintFunctionLibrary.generated.h"中声明的excSum函数注册到了UMyBlueprintFunctionLibrary::StaticClass()这个UClass对象之中，并指定它的名字为“Sum”，也就是我们原始C++代码中声明的函数名，也是在蓝图编辑器中显示的名字。

看清楚了什么是“thunk函数”，“CustomThunk函数”也就不言自明了。在UFUNCTION中指定“CustomThunk”标识符，就是告诉UHT，不要在.generated.h中生成DECLARE_FUNCTION那部分代码，这部分代码改由手写。为啥要抛弃自动生成，而手写呢？回到本文主题：要实现“参数类型通配符”（或者叫做“蓝图模板节点”），就必须手写thunk！

蓝图Stack探索
要实现自己的thunk函数，核心任务就是“准确的处理蓝图虚拟机的栈”，可惜的是官方并没有这方面的文档！下面我就把自己的一些探索记录下来，请大家指正。

以上面的int Sum(int a, int b)函数为例，thunk函数使用P_GET_PROPERTY宏从Stack取值，这个宏P_GET_PROPERTY(UIntProperty,Z_Param_a)展开之后的代码如下所示：

UIntProperty::TCppType Z_Param_a = UIntProperty::GetDefaultPropertyValue();
Stack.StepCompiledIn<UIntProperty>(&Z_Param_a);
其中UIntProperty派生自TProperty_Numeric<int32>，UIntProperty::TCppType就是“int32”无疑！

我们还需要处理TArray<MyStruct>这样的数据，所以我们重点要看一下这种参数类型的栈处理。
假设我们有一个C++的UStruct：

USTRUCT(Blueprintable)
struct FMyStruct {
    GENERATED_USTRUCT_BODY()

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    FString Name;

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    int Value;
};
类似这样一个UFUNCTION：

UFUNCTION(BlueprintCallable)
static void PrintMyStructArray(const TArray<FMyStruct>& MyStructArray);
则在.h中的thunk函数为：

DECLARE_FUNCTION(execPrintMyStructArray) \
    { \
        P_GET_TARRAY_REF(FMyStruct,Z_Param_Out_MyStructArray); \
        P_FINISH; \
        P_NATIVE_BEGIN; \
        UMyBlueprintFunctionLibrary::PrintMyStructArray(Z_Param_Out_MyStructArray); \
        P_NATIVE_END; \
    } \
其中P_GET_TARRAY_REF(FMyStruct,Z_Param_Out_MyStructArray);这个宏展开之后的代码为：

PARAM_PASSED_BY_REF(Z_Param_Out_MyStructArray, UArrayProperty, TArray<FMyStruct>)
最终展开为：

TArray<FMyStruct> Z_Param_Out_MyStructArrayTemp;
TArray<FMyStruct>& Z_Param_Out_MyStructArray = Stack.StepCompiledInRef<UArrayProperty, TArray<FMyStruct> >(&Z_Param_Out_MyStructArrayTemp);
综合上面两个例子，我们发现核心操作都是调用template<class TProperty> void FFrame::StepCompiledIn(void*const Result)这个模板函数。通过跟踪这个函数的执行，发现它实际调用了UObject::execInstanceVariable()函数。 1. 更新"FFrame::PropertyChainForCompiledIn"这个成员变量； 2. 使用更新后的“FFrame::PropertyChainForCompiledIn”值，更新了"FFrame::MostRecentPropertyAddress"成员变量。

再结合引擎中CustomThunk函数的实现源码，可以得出这样的结论：

通过调用Stack.StepCompiledIn()函数，就可以更新蓝图虚拟机的栈顶指针；
Stack.MostRecentPropertyAddress和Stack.MostRecentProperty这两个变量，就是当前参数值的内存地址和反射信息。
有了具体变量的内存地址和类型的反射信息，就足够做很多事了。下面我们就开始实践。

实践1：接受任意UStruct类型参数
下面我们就看一下文章开头的这张图里面的蓝图节点“Show Struct Fields”是如何接受任意类型UStruct参数的。

先上代码, BlueprintWildcardLibrary.h

USTRUCT(BlueprintInternalUseOnly)
struct FDummyStruct {
    GENERATED_USTRUCT_BODY()

};

UCLASS()
class UNREALCOOKBOOK_API UBlueprintWildcardLibrary : public UBlueprintFunctionLibrary {
    GENERATED_BODY()

public:
    UFUNCTION(BlueprintCallable, CustomThunk, Category = "MyDemo", meta = (CustomStructureParam = "CustomStruct"))
        static void ShowStructFields(const FDummyStruct& CustomStruct);
    static void Generic_ShowStructFields(const void* StructAddr, const UStructProperty* StructProperty);

    DECLARE_FUNCTION(execShowStructFields) {

        Stack.MostRecentPropertyAddress = nullptr;
        Stack.MostRecentProperty = nullptr;

        Stack.StepCompiledIn<UStructProperty>(NULL);
        void* StructAddr = Stack.MostRecentPropertyAddress;
        UStructProperty* StructProperty = Cast<UStructProperty>(Stack.MostRecentProperty);


        P_FINISH;

        P_NATIVE_BEGIN;
        Generic_ShowStructFields(StructAddr, StructProperty);
        P_NATIVE_END;
    }
};
BlueprintWildcardLibrary.cpp

#include "BlueprintWildcardLibrary.h"
#include "Engine/Engine.h"

void UBlueprintWildcardLibrary::Generic_ShowStructFields(const void* StructAddr, const UStructProperty* StructProperty) {
    UScriptStruct* Struct = StructProperty->Struct;
    for (TFieldIterator<UProperty> iter(Struct); iter; ++iter) {

        FScreenMessageString NewMessage;
        NewMessage.CurrentTimeDisplayed = 0.0f;
        NewMessage.Key = INDEX_NONE;
        NewMessage.DisplayColor = FColor::Blue;
        NewMessage.TimeToDisplay = 5;
        NewMessage.ScreenMessage = FString::Printf(TEXT("Property: [%s].[%s]"),
            *(Struct->GetName()),
            *(iter->GetName())
        );
        NewMessage.TextScale = FVector2D::UnitVector;
        GEngine->PriorityScreenMessages.Insert(NewMessage, 0);
    }
}
解释一下这段代码：

首先声明了一个UFunction：static void ShowStructFields(const FDummyStruct& CustomStruct);，其参数类型是“FDummyStruct”，这只是一个占位符；
在UFUNCTION宏里面指定“CustomThunk”和“CustomStructureParam”；
实现一个execShowStructFields函数。这个函数很简单，主要是处理蓝图的Stack，从中取出需要的参数，然后对用C++的实现；
具体功能实现在：static void Generic_ShowStructFields(const void* StructAddr, const UStructProperty* StructProperty)这个函数中。
实践2：对数组中的Struct的数值型求平均
下面我们再来一下文章开头的这张图里面的“Array Numeric Field Average”蓝图节点是如何通过“CustomThunk”函数来实现的。

参照引擎源代码，我定义了这样一个宏，用来从栈上取出泛型数组参数，并正确的移动栈指针：

#define P_GET_GENERIC_ARRAY(ArrayAddr, ArrayProperty) Stack.MostRecentProperty = nullptr;\
        Stack.StepCompiledIn<UArrayProperty>(NULL);\
        void* ArrayAddr = Stack.MostRecentPropertyAddress;\
        UArrayProperty* ArrayProperty = Cast<UArrayProperty>(Stack.MostRecentProperty);\
        if (!ArrayProperty) {   Stack.bArrayContextFailed = true;   return; }
通过这个宏，可以得到两个局部变量：

void* ArrayAddr: 数组的起始内存地址；
UArrayProperty* ArrayProperty: 数组的反射信息，ArrayProperty->Inner就是数组成员对应的类型了；
有了这个宏，我们就可以很方便的写出thunk函数了：

DECLARE_FUNCTION(execArray_NumericPropertyAverage) {

        // get TargetArray
        P_GET_GENERIC_ARRAY(ArrayAddr, ArrayProperty);

        // get PropertyName
        P_GET_PROPERTY(UNameProperty, PropertyName);

        P_FINISH;

        P_NATIVE_BEGIN;
        *(float*)RESULT_PARAM = GenericArray_NumericPropertyAverage(ArrayAddr, ArrayProperty, PropertyName);
        P_NATIVE_END;
    }
经过以上的准备，我们就已经可以正确的处理“泛型数组”了。下一步就是对这个数组中指定的数“值类型成员变量”求均值了，这主要依靠Unreal的反射信息，一步步抽丝剥茧，找到数组中的每个变量即可。反射系统的使用不是本文的重点，先看完整代码吧。

BlueprintWildcardLibrary.h
#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "BlueprintWildcardLibrary.generated.h"

#define P_GET_GENERIC_ARRAY(ArrayAddr, ArrayProperty) Stack.MostRecentProperty = nullptr;\
        Stack.StepCompiledIn<UArrayProperty>(NULL);\
        void* ArrayAddr = Stack.MostRecentPropertyAddress;\
        UArrayProperty* ArrayProperty = Cast<UArrayProperty>(Stack.MostRecentProperty);\
        if (!ArrayProperty) {   Stack.bArrayContextFailed = true;   return; }

UCLASS()
class UNREALCOOKBOOK_API UBlueprintWildcardLibrary : public UBlueprintFunctionLibrary {
    GENERATED_BODY()

public:

    UFUNCTION(BlueprintPure, CustomThunk, meta = (DisplayName = "Array Numeric Property Average", ArrayParm = "TargetArray", ArrayTypeDependentParams = "TargetArray"), Category = "MyDemo")
        static float Array_NumericPropertyAverage(const TArray<int32>& TargetArray, FName PropertyName);
    static float GenericArray_NumericPropertyAverage(const void* TargetArray, const UArrayProperty* ArrayProperty, FName ArrayPropertyName);

public:
    DECLARE_FUNCTION(execArray_NumericPropertyAverage) {

        // get TargetArray
        P_GET_GENERIC_ARRAY(ArrayAddr, ArrayProperty);

        // get PropertyName
        P_GET_PROPERTY(UNameProperty, PropertyName);

        P_FINISH;

        P_NATIVE_BEGIN;
        *(float*)RESULT_PARAM = GenericArray_NumericPropertyAverage(ArrayAddr, ArrayProperty, PropertyName);
        P_NATIVE_END;
    }
};
BlueprintWildcardLibrary.cpp
#include "BlueprintWildcardLibrary.h"
#include "Engine/Engine.h"

float UBlueprintWildcardLibrary::Array_NumericPropertyAverage(const TArray<int32>& TargetArray, FName PropertyName) {
    // We should never hit these!  They're stubs to avoid NoExport on the class.  Call the Generic* equivalent instead
    check(0);
    return 0.f;
}

float UBlueprintWildcardLibrary::GenericArray_NumericPropertyAverage(const void* TargetArray, const UArrayProperty* ArrayProperty, FName PropertyName) {

    UStructProperty* InnerProperty = Cast<UStructProperty>(ArrayProperty->Inner);
    if (!InnerProperty) {
        UE_LOG(LogTemp, Error, TEXT("Array inner property is NOT a UStruct!"));
        return 0.f;
    }

    UScriptStruct* Struct = InnerProperty->Struct;
    FString PropertyNameStr = PropertyName.ToString();
    UNumericProperty* NumProperty = nullptr;
    for (TFieldIterator<UNumericProperty> iter(Struct); iter; ++iter) {
        if (Struct->PropertyNameToDisplayName(iter->GetFName()) == PropertyNameStr) {
            NumProperty = *iter;
            break;
        }
    }
    if (!NumProperty) {
        UE_LOG(LogTemp, Log, TEXT("Struct property NOT numeric = [%s]"),
            *(PropertyName.ToString())
        );
    }


    FScriptArrayHelper ArrayHelper(ArrayProperty, TargetArray);
    int Count = ArrayHelper.Num();
    float Sum = 0.f;

    if(Count <= 0)
        return 0.f;

    if (NumProperty->IsFloatingPoint())
        for (int i = 0; i < Count; i++) {
            void* ElemPtr = ArrayHelper.GetRawPtr(i);
            const uint8* ValuePtr = NumProperty->ContainerPtrToValuePtr<uint8>(ElemPtr);
            Sum += NumProperty->GetFloatingPointPropertyValue(ValuePtr);

        }
    else if (NumProperty->IsInteger()) {
        for (int i = 0; i < Count; i++) {
            void* ElemPtr = ArrayHelper.GetRawPtr(i);
            const uint8* ValuePtr = NumProperty->ContainerPtrToValuePtr<uint8>(ElemPtr);
            Sum += NumProperty->GetSignedIntPropertyValue(ValuePtr);
        }
    }
    // TODO: else if(enum类型)

    return Sum / Count;
}
</code></pre>
</details>

<details>
<summary>通过派生class UK2Node创建自定义蓝图节点</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/84958215
通过UFunction可以方便的添加蓝图节点，通过CustomThunk还可以支持“类型通配符”，但是如果需要动态添加针脚（Pin）那么就需要通过派生class UK2Node来实现了。这个过程有点复杂，本文就先打个基础，把这个基类的基本扩展方式搞清楚。

下面我们就一步一步的来实现一个最简单的“Hello World蓝图节点”，通过这个节点我们来看看扩展K2Node的关键步骤。在后面一篇博客再去实现“动态增加输入项”的节点。

项目创建
我们创建一个C++: Basic Code工程，然后，手动添加一个Editor模块，如下图所示：

手动添加这个模块的操作如下：

修改 .uproject 文件，在Modules字段，添加新的项目，命名为：MyBlueprintNodeEditor，Type设置为：Editor；
在Source目录下建立一个子目录，命名为: MyBlueprintNodeEditor，这个子目录就是保存这个模块的所有源文件了；
在这个子目录下创建一个：MyBlueprintNodeEditor.Build.cs，用来实现UBT对这个模块的build的配置；并把“BlueprintGraph”模块添加的PrivateDependencyModuleNames中；
在“MyBlueprintNodeEditor.Target.cs”文件中添加这个模块：
ExtraModuleNames.AddRange( new string[] {
"MyBlueprintNode",
"MyBlueprintNodeEditor"
} );
为什么要添加一个Editor模块呢？因为class UK2Node这个类属于一个名为“BlueprintGraph”的Editor模块，而蓝图的Graph编辑，Compile之后生成一个class UBlueprintGeneratedClass的实例，而UK2Node这些对象的实例在Runtime是不需要的。

创建新的节点类型
首先，我们来创建一个class UK2Node的派生类，命名为：class UBPNode_SayHello

UCLASS()
class MYBLUEPRINTNODEEDITOR_API UBPNode_SayHello : public UK2Node
{
    GENERATED_BODY()

};
有了这个类之后，在Blueprint编辑器里面还不能创建它。我们需要把这个节点的创建操作添加到右键菜单中，并且稍微美化一下这个节点的显示，通过以下几个函数来完成。

UCLASS()
class MYBLUEPRINTNODEEDITOR_API UBPNode_SayHello : public UK2Node
{
    GENERATED_BODY()

public:
    // UEdGraphNode interface
    virtual FText GetTooltipText() const override { return FText::FromString(TEXT("a hello world node")); }
    virtual FText GetNodeTitle(ENodeTitleType::Type TitleType) const override { return FText::FromString(TEXT("Say Hello World")); }
    // End of UEdGraphNode interface

    // UK2Node interface
    virtual FText GetMenuCategory() const { return FText::FromString(TEXT("MyBlueprintNodes")); }
    virtual void GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const override;
    // End of UK2Node interface
};
这几个函数的名字已经足够说明它们的作用了，其中最重要的就是“GetMenuActions()”这个了，它的实现代码如下：

void UBPNode_SayHello::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    UClass* ActionKey = GetClass();

    if (ActionRegistrar.IsOpenForRegistration(ActionKey))
    {
        UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
        check(NodeSpawner != nullptr);

        ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
    }
}
以上简单代码之后，我们就可以通过右键菜单创建一个空的节点了，如下图所示：


实现节点连接
接下来，需要把这个Node连接到整个Graph，才能使它能够被调用。我们这个节点将通过Pin来连接到整个蓝图（Pure Node没有Pin）。通过override父类的AllocateDefaultPins()函数，我们来添加需要的两个pin：

void UBPNode_SayHello::AllocateDefaultPins() {

    CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
    CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);
}
我们添加了一个Input Pin、一个Output Pin，实现效果如下图所示：


实现节点的功能
上面这个节点编译就会报错，因为我们还没有实现最核心的蓝图节点编译函数。在这里，我们通过重载“ExpandNode()”来实现这个节点的功能。我个人目前理解这个函数的名字含义是：通过把这个节点展开成一个已有节点类型组成的Sub Graph来实现本节点的功能。先看代码吧：

void UBPNode_SayHello::ExpandNode(FKismetCompilerContext & CompilerContext, UEdGraph * SourceGraph) {
    Super::ExpandNode(CompilerContext, SourceGraph);

    UEdGraphPin* ExecPin = GetExecPin();
    UEdGraphPin* ThenPin = GetThenPin();
    if (ExecPin && ThenPin) {

        // create a CallFunction node
        FName MyFunctionName = GET_FUNCTION_NAME_CHECKED(UMyBlueprintFunctionLibrary, SayHello_Internal);

        UK2Node_CallFunction* CallFuncNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
        CallFuncNode->FunctionReference.SetExternalMember(MyFunctionName, UMyBlueprintFunctionLibrary::StaticClass());
        CallFuncNode->AllocateDefaultPins();

        // move pins
        CompilerContext.MovePinLinksToIntermediate(*ExecPin, *(CallFuncNode->GetExecPin()));
        CompilerContext.MovePinLinksToIntermediate(*ThenPin, *(CallFuncNode->GetThenPin()));
    }

    // break any links to the expanded node
    BreakAllNodeLinks();
}
这段代码通过新建一个UK2Node_CallFunction节点，然后把Pin重新绑定来实现所需的功能；UK2Node_CallFunction节点可以调用任意的UFUNCTION，在这里我们调用一个自己的简单函数：UMyBlueprintFunctionLibrary::SayHello_Internal()，这个函数实现很简单，需要注意的是在它的UFUNCTION声明里面，我设置了它为“BlueprintInternalUseOnly”，具体看代码：

UCLASS()
class MYBLUEPRINTNODE_API UMyBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()

public:
    UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = "true"))
    static void SayHello_Internal();
};
结束语
上面这个例子的完整UE4 Project和源代码都已经上传到我的GitHub供大家参考：https://github.com/neil3d/UnrealCookBook/tree/master/MyBlueprintNode。

通过这个例子，我们已经掌握了最基本的K2Node扩展的方式，其实很简单，主要是重写父类class UK2Node以及父类的父类class UEdGraphNode的一些关键方法。当然，目前这个节点和标准的UFUNCTION节点没什么差别，在下一篇博客中我们将实现一个动态分配Pin的节点，那才能体现这种方法的价值。
</code></pre>
</details>

<details>
<summary>实现蓝图节点的动态添加/删除Pin</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/86231216
通过本系列文章上篇的介绍，我们已经可以创建一个“没什么用”的蓝图节点了。要想让它有用，关键还是上篇中说的典型应用场景：动态添加Pin，这篇博客就来解决这个问题。

目标
和上篇一样，我还将通过一个尽量简单的节点，来说明"可动态添加/删除Pin的蓝图节点"的实现过程，让大家尽量聚焦在“蓝图自定义节点”这个主题上。

设想这样一个节点：Say Something，把输入的N个字符串连接起来，然后打印输出。也就是说，这个节点的输入Pin是可以动态添加的。我们将在上篇的那个工程基础上实现这个自定义节点。最终实现的效果如下图所示：


下面我们还是来仔细的过一遍实现步骤吧！

创建Blueprint Graph节点类型
首先，我们还是需要创建一个class UK2Node的派生类，这个过程在上一篇中已经详细说过了，照单炒菜，很容易就创建了下图这样一个空的自定义节点，这里就不赘述了。不清楚的话，可以返回去在照着上一篇做就好了。




创建自定义的节点Widget
我们要动态增加Pin的话，需要在节点上显示一个"加号按钮"，点击之后增加一个“input pin”。这就不能使用默认的Blueprint Graph Node Widget了，需要对其进行扩展。这个扩展的思路和前面一样，也是找到特定的基类，重载其虚函数即可，这个基类就是class SGraphNodeK2Base。我们要重载的两个核心的函数是：

CreateInputSideAddButton()，创建我们需要的添加输入Pin的按钮；
OnAddPin()，响应这个按钮的操作；
来看一下最简化的代码吧： SGraphNodeSaySomething.h

class SGraphNodeSaySomething : public SGraphNodeK2Base
{
public:
    SLATE_BEGIN_ARGS(SGraphNodeSaySomething){}
    SLATE_END_ARGS()

    void Construct(const FArguments& InArgs, UBPNode_SaySomething* InNode);
protected:
    virtual void CreateInputSideAddButton(TSharedPtr<SVerticalBox> InputBox) override;
    virtual FReply OnAddPin() override;
};
SGraphNodeSaySomething.cpp

void SGraphNodeSaySomething::Construct(const FArguments& InArgs, UBPNode_SaySomething* InNode)
{
    this->GraphNode = InNode;
    this->SetCursor( EMouseCursor::CardinalCross );
    this->UpdateGraphNode();
}

void SGraphNodeSaySomething::CreateInputSideAddButton(TSharedPtr<SVerticalBox> InputBox)
{
    FText Tmp = FText::FromString(TEXT("Add word"));
    TSharedRef<SWidget> AddPinButton = AddPinButtonContent(Tmp, Tmp);

    FMargin AddPinPadding = Settings->GetInputPinPadding();
    AddPinPadding.Top += 6.0f;

    InputBox->AddSlot()
    .AutoHeight()
    .VAlign(VAlign_Center)
    .Padding(AddPinPadding)
    [
        AddPinButton
    ];
}

FReply SGraphNodeSaySomething::OnAddPin()
{ }
如果你接触过Unreal Slate的话，上面这个Slate Widget的代码很容易看懂啦，如果你没有玩过Slate。。。。Slate是虚幻自己的一套 Immediate Mode UI framework，建议先过一下官方文档。

最后，因为这个基类：SGraphNodeK2Base，属于GraphEditor模块，所以要修改MyBlueprintNodeEditor.Build.cs，把它添加到PrivateDependencyModuleNames：

PrivateDependencyModuleNames.AddRange(new string[] {
            "UnrealEd",
            "GraphEditor",
            "BlueprintGraph",
            "KismetCompiler",
            "MyBlueprintNode"
        });
扩展蓝图编辑器的节点Widget
OK，上面我们已经创建了两个类，分别是：

class UBPNode_SaySomething : public UK2Node
class SGraphNodeSaySomething : public SGraphNodeK2Base
下面我们就需要让蓝图编辑器知道：创建UBPNode_SaySomething对象的时候，需要使用SGraphNodeSaySomething这个Widget。

添加自定义Node Widget的两种方式（参见引擎源码class FNodeFactory）：

重载UEdGraphNode::CreateVisualWidget()函数，例如：
TSharedPtr<SGraphNode> UNiagaraNode::CreateVisualWidget() 
{
    return SNew(SNiagaraGraphNode, this);
}
使用 class FEdGraphUtilities 注册 class FGraphPanelNodeFactory对象，例如：
void FBehaviorTreeEditorModule::StartupModule()
{
    GraphPanelNodeFactory_BehaviorTree = MakeShareable( new FGraphPanelNodeFactory_BehaviorTree() );
    FEdGraphUtilities::RegisterVisualNodeFactory(GraphPanelNodeFactory_BehaviorTree);
}
在这里，我们使用第一种方式，也就是在class UBPNode_SaySomething中重载父类的虚函数CreateVisualWidget()。

TSharedPtr<SGraphNode> UBPNode_SaySomething::CreateVisualWidget() {
    return SNew(SGraphNodeSaySomething, this);
}
完成上述代码之后，运行蓝图编辑器，添加Say Something节点，就可以看到这个Widget了：


动态增加Pin
当用户点击“Add Word +”按钮时，SGraphNodeSaySomething::OnAddPin()会被调用，下面是它的实现代码：

FReply SGraphNodeSaySomething::OnAddPin()
{
    UBPNode_SaySomething* BPNode = CastChecked<UBPNode_SaySomething>(GraphNode);

    const FScopedTransaction Transaction(NSLOCTEXT("Kismet", "AddArgumentPin", "Add Argument Pin"));
    BPNode->Modify();

    BPNode->AddPinToNode();
    FBlueprintEditorUtils::MarkBlueprintAsModified(BPNode->GetBlueprint());

    UpdateGraphNode();
    GraphNode->GetGraph()->NotifyGraphChanged();

    return FReply::Handled();
}
上面这段代码主要是响应用户的UI操作，添加Pin的核心操作，还是放在UBPNode_SaySomething::AddPinToNode()这个函数里面去实现的:

void UBPNode_SaySomething::AddPinToNode()
{
    TMap<FString, FStringFormatArg> FormatArgs= {
            {TEXT("Count"), ArgPinNames.Num()}
    };
    FName NewPinName(*FString::Format(TEXT("Word {Count}"), FormatArgs));
    ArgPinNames.Add(NewPinName);

    CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_String, NewPinName);
}
现在我们就可以在蓝图编辑器里面操作添加输入Pin了 ：


动态删除Pin
如果用户想要删除某个输入变量Pin，他需要在那个Pin上点击鼠标右键，呼出Context Menu，选择“删除”菜单项将其移除。下面我们就看看这个操作是如何实现的。

动图封面
我们可以通过重载void UEdGraphNode::GetContextMenuActions(const FGraphNodeContextMenuBuilder& Context) const来定制Context Menu。

void UBPNode_SaySomething::GetContextMenuActions(const FGraphNodeContextMenuBuilder & Context) const
{
    Super::GetContextMenuActions(Context);

    if (Context.bIsDebugging)
        return;

    Context.MenuBuilder->BeginSection("UBPNode_SaySomething", FText::FromString(TEXT("Say Something")));

    if (Context.Pin != nullptr)
    {
        if (Context.Pin->Direction == EGPD_Input && Context.Pin->ParentPin == nullptr)
        {
            Context.MenuBuilder->AddMenuEntry(
                FText::FromString(TEXT("Remove Word")),
                FText::FromString(TEXT("Remove Word from input")),
                FSlateIcon(),
                FUIAction(
                    FExecuteAction::CreateUObject(this, &UBPNode_SaySomething::RemoveInputPin, const_cast<UEdGraphPin*>(Context.Pin))
                )
            );
        }
    }// end of if

    Context.MenuBuilder->EndSection();
}
这个函数的实现很直白啦，就是操作MenuBuilder，添加菜单项，并绑定UIAction到成员函数UBPNode_SaySomething::RemoveInputPin，接下来就是实现这个函数了。

void UBPNode_SaySomething::RemoveInputPin(UEdGraphPin * Pin)
{
    FScopedTransaction Transaction(FText::FromString("SaySomething_RemoveInputPin"));
    Modify();

    ArgPinNames.Remove(Pin->GetFName());

    RemovePin(Pin);
    FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(GetBlueprint());
}
也很简单，就是直接调用父类的RemovePin()，并同步处理一下自己内部的状态变量就好了。

实现这个蓝图节点的编译
通过前面的步骤，蓝图编辑器的扩展就全部完成了，接下来就是最后一步了，通过扩展蓝图编译过程来实现这个节点的实际功能。

我们延续上篇的思路来实现这个节点的功能，也就是重载UK2Node::ExpandNode()函数。

核心的问题是如何把当前的所有的输入的Pin组合起来？ 答案很简单，把所有输入的Pin做成一个TArray<FString>，这样就可以传入到一个UFunction来调用。

首先我们在 class UMyBlueprintFunctionLibrary 中添加一个函数：

UCLASS()
class MYBLUEPRINTNODE_API UMyBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()

public:
    UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = "true"))
        static void SaySomething_Internal(const TArray<FString>& InWords);
};
然后，仍然与上篇相同，使用一个 class UK2Node_CallFunction 节点实例对象来调用这个UFunction，不同的是，我们需要使用一个 class UK2Node_MakeArray 节点的实例来把收集所有的动态生成的输入Pin。下面是实现的代码：

void UBPNode_SaySomething::ExpandNode(FKismetCompilerContext & CompilerContext, UEdGraph * SourceGraph) {
    Super::ExpandNode(CompilerContext, SourceGraph);

    UEdGraphPin* ExecPin = GetExecPin();
    UEdGraphPin* ThenPin = GetThenPin();
    if (ExecPin && ThenPin) {

        // create a CallFunction node
        FName MyFunctionName = GET_FUNCTION_NAME_CHECKED(UMyBlueprintFunctionLibrary, SaySomething_Internal);

        UK2Node_CallFunction* CallFuncNode = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
        CallFuncNode->FunctionReference.SetExternalMember(MyFunctionName, UBPNode_SaySomething::StaticClass());
        CallFuncNode->AllocateDefaultPins();

        // move exec pins
        CompilerContext.MovePinLinksToIntermediate(*ExecPin, *(CallFuncNode->GetExecPin()));
        CompilerContext.MovePinLinksToIntermediate(*ThenPin, *(CallFuncNode->GetThenPin()));

        // create a "Make Array" node to compile all args
        UK2Node_MakeArray* MakeArrayNode = CompilerContext.SpawnIntermediateNode<UK2Node_MakeArray>(this, SourceGraph);
        MakeArrayNode->AllocateDefaultPins();

        // Connect Make Array output to function arg
        UEdGraphPin* ArrayOut = MakeArrayNode->GetOutputPin();
        UEdGraphPin* FuncArgPin = CallFuncNode->FindPinChecked(TEXT("InWords"));
        ArrayOut->MakeLinkTo(FuncArgPin);

        // This will set the "Make Array" node's type, only works if one pin is connected.
        MakeArrayNode->PinConnectionListChanged(ArrayOut);

        // connect all arg pin to Make Array input
        for (int32 i = 0; i < ArgPinNames.Num(); i++) {

            // Make Array node has one input by default
            if (i > 0)
                MakeArrayNode->AddInputPin();

            // find the input pin on the "Make Array" node by index.
            const FString PinName = FString::Printf(TEXT("[%d]"), i);
            UEdGraphPin* ArrayInputPin = MakeArrayNode->FindPinChecked(PinName);

            // move input word to array 
            UEdGraphPin* MyInputPin = FindPinChecked(ArgPinNames[i], EGPD_Input);
            CompilerContext.MovePinLinksToIntermediate(*MyInputPin, *ArrayInputPin);
        }// end of for
    }

    // break any links to the expanded node
    BreakAllNodeLinks();
}
核心步骤来讲解一下：

创建了一个class UK2Node_CallFunction的实例，然后把自身节点的两端的Exec Pin重定向到这个Node的两端；
使用“函数参数名称”找到UK2Node_CallFunction节点的输入Pin，把它连接到一个新建的UK2Node_MakeArray的节点实例上；
把自己所有的输入变量Pin重定向到UK2Node_MakeArray的输入上（需要为它动态添加新的Pin）；
结束语
今天涉及到的class稍微有点多，我整理了一个UML静态结构图，看看这几个classes直接的关系以及它们所在的模块。完整源代码仍然是在我的GitHub：

neil3d/UnrealCookBook
​github.com/neil3d/UnrealCookBook/tree/master/MyBlueprintNode


至此，通过派生class UK2Node和class SGraphNodeK2Base来扩展Blueprint Graph Editor，我们可以自己定义蓝图节点，以及编辑器中的Node Widget，可以添加按钮，以及其他任何你想要做的东西。通过这个定制化的Node Widget，可以实现编辑时对Blueprint Graph Node的交互控制啦~。
</code></pre>
</details>

<details>
<summary>使用Node Handler定制蓝图节点的编译过程</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/87489168
通过前面的文章，我们已经能够创建自己的蓝图节点，并可以动态添加、删除Pins，但是感觉好像有什么地方不太对劲啊。你发现没有？那就是前面两篇文章中，我们自定义的蓝图节点都是通过UK2Node::ExpandNode()来实现节点的具体功能，然而，这个函数只不过是在内部创建了一些其他的节点，然后把自己的Pins重新连接到新建的节点的Pin之上，本质上这个过程手动连线也可以做啊！如果，我们需要做一个全新的蓝图功能节点，无法用现有节点组合完成呢？那要怎么办呢？那就需要深入到蓝图的编译过程，控制蓝图编译出的字节码，来实现想要的节点功能了。引擎中实现的大多数默认节点都是这样做的。在这篇博客，就通过一个最简单的实例，来探索这个过程是怎么实现的。

在进入实做的细节之前，我们必须先谈一点概念性的抽象的东西，概念搞明白了之后，我们再通过一个实例来看一下具体的实现步骤。

浅谈蓝图编译过程
由于本人对蓝图编译的过程掌握的还不够，还不能非常详实的把它的原理和实现都说的很明白，所以这里只能“浅谈”一下，谈个大概。在以后的博文中再进行补充吧。

蓝图编译过程的最终产出是一个：UBlueprintGeneratedClass对象。UBlueprintGeneratedClass它是从UClass派生的，也就是说它具备Unreal C++开发的类所具备的那些UProperty啊、UFunction啊等等东西；
蓝图里面使用可视化Graph编辑的那些逻辑，最终会生成字节码，保存到UFunction成员变量中，具体就是：TArray<uint8>``UFunction::Script 这个成员变量啦；
字节码生成的核心过程是:

遍历Graph的所有节点，使用一定策略（具体是啥策略，另外的文章再讲）生成一个线性的列表，保存到“TArray<UEdGraphNode*>``FKismetFunctionContext::LinearExecutionList”；
然后遍历每个蓝图节点，生成相应的“语句”，正确的名词是：Statement，保存到“TMap< UEdGraphNode*, TArray<FBlueprintCompiledStatement*> > FKismetFunctionContext::StatementsPerNode”，一个Node在编译过程中可以产生多个Statement；
重点来了：这就是我们开发的自定义节点能够控制字节码生成的地方：
Statement 有很多类型，看看它的枚举，发现很接近字节码了，是类似汇编语言那种；需要通过“条件跳转”之类的逻辑，在线性的代码中产生分支和循环；详见下图中的：enum EKismetCompiledStatementType
上述过程可以算是编译器的前端，接下来就进入后端的流程，具体代码是在：class ``FKismetCompilerVMBackend；
后端，也就是字节码的生成的核心代码是在：FScriptBuilderBase::GenerateCodeForStatement()，这个函数通过一个大的“switch (Statement.Type)”语句，把不同类型的statement生成字节码

那么，在前面提到的“重点步骤”是怎么实现呢？很简单，分两步：

定义一个class FNodeHandlingFunctor的派生类，重载其方法，例如：Compile()等，即可控制这个节点在编译过程中生成的statement；
重载 class UK2Node的虚函数“CreateNodeHandler()”，返回一个上述派生类的对象指针。
FNodeHandlingFunctor 详解
既然本文重点步骤就是编写FNodeHandlingFunctor的派生类，那么有必要把这个基类仔细的看看啦！ 这个类的代码并不多，但是包含了三个重要的概念：

Statement：这个前面已经讲过了，它对应的是“struct FBlueprintCompiledStatement”。这个结构体有很多变量，但是并不是同时有效的，具体要根据Type字段来解释。其中的LHS和RHS是两个常用的字段，也就是我们常说的“左值”和“右值”。（简单说就是：一个表达式把一系列右侧的参数值计算之后赋值给左侧的变量）
Terminal，也就是：struct FBPTerminal，它的注释说的比较明白：A terminal in the graph (literal or variable reference)，也就是说“它代表Graph中的一个端点，可能是字面量，也可能是变量的引用”
Net：对于“变量引用型的Terminal”，需要注册的一个“关系网”中，用来在运行时求解它的值。
理解了这三个概念之后，再来看他的几个常用的虚函数：

virtual void Compile(FKismetFunctionContext& Context, UEdGraphNode* Node) 这个就是编译过程中的回调啦，一般用来生成这个Node对应的Statement，可以是0个到多个；
virtual void RegisterNets(FKismetFunctionContext& Context, UEdGraphNode* Node) 这个节点注册Terminal网络的回调；在这里可以使用“FKismetFunctionContext::CreateLocalTerminal”创建非Pin直接相关的Terminal对象；
virtual void RegisterNet(FKismetFunctionContext& Context, UEdGraphPin* Pin) 这个节点上的针脚注册Terminal网络的回调；
总结一下： 实现一个FNodeHandlingFunctor的派生类，我们可以实现自己的Node Handler 通过这个Node Handler，可以在编译过程中生成需要的Terminal，并注册到Net中 * 在编译的过程中，可以生成任意多个Statement，直接影响后续的字节码生成

举个栗子
下面我们就通过一个具体的例子，来看看通过Node Handler方式控制蓝图节点的编译，具体如何实现的。说实话，引擎实现的蓝图节点真的很丰富了，很难想出一个有实用性的例子，只好胡诌一个了：

判断输入的一个整型变量，分为：正数，零，负数，三种状态，执行不同的流程；
如下图中的“TriGate”节点所示：


完整的Demo工程可以从我的GitHub下载：
neil3d/UnrealCookBook
​github.com/neil3d/UnrealCookBook/tree/master/MyBlueprintNode


这个节点的完整源代码附在文末，我们先来step by step讲解一下，实现过程不难理解：

第一步：添加一个自定义的UK2Node派生类
首先就是要创建一个class UK2Node的派生类：class UBPNode_TriGate : public UK2Node，这个过程很简单，基本上和前面两篇博客介绍的一样，这里就不重复了。只有一个地方不同，那就是我们不再需要重载 ExpendNode() 函数，而是重载CreateNodeHandler()函数。它的实现也很简单，就是返回一个我们自定义的FNodeHandlingFunctor派生类对象。

FNodeHandlingFunctor * UBPNode_TriGate::CreateNodeHandler(FKismetCompilerContext & CompilerContext) const
{
    return new FKCHandler_TriGate(CompilerContext);
}
在其cpp文件中创建一个自定义的FNodeHandlingFunctor派生类：class FKCHandler_TriGate : public FNodeHandlingFunctor，后面将主要实现这个类的几个虚函数，来完成整个节点的功能。

第二步：生成两个Terminal
想象一下，代码执行过程中，我们需要比较输入的那个整数是否大于零，把结果保存到一个临时变量中，所以我们需要两个Terminal： - 一个用来用来表示字面量“0” - 另一个用来存储比较结果

这两个Terminal就是在"FKCHandler_TriGate::RegisterNets()"函数中定义的

virtual void RegisterNets(FKismetFunctionContext& Context, UEdGraphNode* Node) override
    {
        FNodeHandlingFunctor::RegisterNets(Context, Node);

        // 存储比较结果的bool变量
        FBPTerminal* BoolTerm = Context.CreateLocalTerminal();
        BoolTerm->Type.PinCategory = UEdGraphSchema_K2::PC_Boolean;
        BoolTerm->Source = Node;
        BoolTerm->Name = Context.NetNameMap->MakeValidName(Node) + TEXT("_CmpResult");
        BoolTermMap.Add(Node, BoolTerm);

        // 字面量“0”
        LiteralZeroTerm = Context.CreateLocalTerminal(ETerminalSpecification::TS_Literal);
        LiteralZeroTerm->bIsLiteral = true;
        LiteralZeroTerm->Type.PinCategory = UEdGraphSchema_K2::PC_Int;
        LiteralZeroTerm->Name = TEXT("0");
    }
第三步：实现Compile过程，生成6个Statement
做好了前面两步的准备，接下来就是关键的步骤了：定义一系列Statements来实现我们的逻辑。重复一下要实现的逻辑：

判断输入的一个整型变量，分为：正数，零，负数，三种状态，执行不同的流程；
逻辑很简单，不过，我们需要转换一下思考方式，要使用类似汇编语言的那种思路：要把语句顺序排列，然后使用条件跳转语句控制分支逻辑。下面将要使用到的Statement类型先说明一下：

KCST_CallFunction：调用指定的UFunction，我们需要把“输入那个整数”和零做比较，这个功能我们将通过调用 class UKismetMathLibrary 中的函数来实现，使用到两个函数：
UKismetMathLibrary::Greater_IntInt()
UKismetMathLibrary::EqualEqual_IntInt()
KCST_GotoIfNot：条件跳转，可以指定跳转到哪个Statement（或者指定的Pin）；
KCST_UnconditionalGoto：无条件跳转，主要用来跳转到右侧的三个Exec Pin中的一个；
KCST_CallFunction 实例
下面说一下KCST_CallFunction具体在我们这个例子中的使用。

首先我们需要找到UFunction相关的信息：

UClass* MathLibClass = UKismetMathLibrary::StaticClass();
UFunction* CreaterFuncPtr = FindField<UFunction>(MathLibClass, "Greater_IntInt");
UFunction* EqualFuncPtr = FindField<UFunction>(MathLibClass, "EqualEqual_IntInt");
下面生成的这个Statement就是比较输入变量是否大于零，并把比较结果保存到我们定义的BoolTerm变量中：

FBlueprintCompiledStatement& CallCreaterZero = Context.AppendStatementForNode(MyNode);
        CallCreaterZero.Type = KCST_CallFunction;
        CallCreaterZero.FunctionToCall = CreaterFuncPtr;
        CallCreaterZero.LHS = BoolTerm;
        CallCreaterZero.RHS.Add(InputTerm);
        CallCreaterZero.RHS.Add(LiteralZeroTerm);
KCST_GotoIfNot 实例
下面生成的这个Statement就是通过判断BoolTerm的值为False的话，则跳转：

FBlueprintCompiledStatement& IfPositive = Context.AppendStatementForNode(Node);
        IfPositive.Type = KCST_GotoIfNot;
        IfPositive.LHS = BoolTerm;
那么，跳转到什么地方呢？跳转到后面的比较语句，具体代码如下：

FBlueprintCompiledStatement& CallEqualZero = Context.AppendStatementForNode(MyNode);
    ...
        CallEqualZero.bIsJumpTarget = true;
        IfPositive.TargetLabel = &CallEqualZero;
设置新的语句“bIsJumpTarget = true”，使它成为一个跳转的目标，然后把前面那个跳转的Statement的TargetLabel设置为这个新的语句。

KCST_UnconditionalGoto
无条件跳转到指定的Exec Pin。注意：下面这个Statement在运行时，根据BoolTerm的值，可能被前面的条件跳转语句跳过，来实现分支的逻辑。

FBlueprintCompiledStatement& ExecZero = Context.AppendStatementForNode(Node);
    ExecZero.Type = KCST_UnconditionalGoto;
    Context.GotoFixupRequestMap.Add(&ExecZero, ZeroPin);
完整的 Statement 列表
运用上面三种Statement，把他们罗列出来，即可实现我们的逻辑功能了。乍看上去可能并不直观，主要是这种类似汇编的方式并不直观，可能需要反复看几遍。

virtual void Compile(FKismetFunctionContext& Context, UEdGraphNode* Node) override
    {
        UBPNode_TriGate* MyNode = CastChecked<UBPNode_TriGate>(Node);

        // 查找输入的那个整数的Pin对应的Terminal
        UEdGraphPin* InputPin = Context.FindRequiredPinByName(Node, TriGatePN::Input, EGPD_Input);

        UEdGraphPin* PinToTry = FEdGraphUtilities::GetNetFromPin(InputPin);
        FBPTerminal** pInputTerm = Context.NetMap.Find(PinToTry);
        if (pInputTerm == nullptr)
        {
            CompilerContext.MessageLog.Error(TEXT("FKCHandler_TriGate: Failed to resolve term passed into"), InputPin);
            return;
        }

        FBPTerminal* InputTerm = *pInputTerm;

        // 查找三个输出Pin
        UEdGraphPin* PositivePin = MyNode->FindPin(TriGatePN::Positive, EGPD_Output);
        UEdGraphPin* ZeroPin = MyNode->FindPin(TriGatePN::Zero, EGPD_Output);
        UEdGraphPin* NegativePin = MyNode->FindPin(TriGatePN::Negative, EGPD_Output);

        // 临时bool变量的Terminal
        FBPTerminal* BoolTerm = BoolTermMap.FindRef(MyNode);

        UClass* MathLibClass = UKismetMathLibrary::StaticClass();
        UFunction* CreaterFuncPtr = FindField<UFunction>(MathLibClass, "Greater_IntInt");
        UFunction* EqualFuncPtr = FindField<UFunction>(MathLibClass, "EqualEqual_IntInt");

        // Statement 1: 计算表达式 BoolTerm = Interger > 0
        FBlueprintCompiledStatement& CallCreaterZero = Context.AppendStatementForNode(MyNode);
        CallCreaterZero.Type = KCST_CallFunction;
        CallCreaterZero.FunctionToCall = CreaterFuncPtr;
        CallCreaterZero.LHS = BoolTerm;
        CallCreaterZero.RHS.Add(InputTerm);
        CallCreaterZero.RHS.Add(LiteralZeroTerm);

        // Statement 2: if(BoolTerm)
        FBlueprintCompiledStatement& IfPositive = Context.AppendStatementForNode(Node);
        IfPositive.Type = KCST_GotoIfNot;
        IfPositive.LHS = BoolTerm;

        // Statement 3: 执行 Positive Pin
        FBlueprintCompiledStatement& ExecPositive = Context.AppendStatementForNode(Node);
        ExecPositive.Type = KCST_UnconditionalGoto;
        Context.GotoFixupRequestMap.Add(&ExecPositive, PositivePin);

        // Statement 4: 计算表达式 BoolTerm = Interger == 0
        FBlueprintCompiledStatement& CallEqualZero = Context.AppendStatementForNode(MyNode);
        CallEqualZero.Type = KCST_CallFunction;
        CallEqualZero.FunctionToCall = EqualFuncPtr;
        CallEqualZero.LHS = BoolTerm;
        CallEqualZero.bIsJumpTarget = true;
        CallEqualZero.RHS.Add(InputTerm);
        CallEqualZero.RHS.Add(LiteralZeroTerm);

        IfPositive.TargetLabel = &CallEqualZero;

        // Statement 5: GotoIfNot(BoolTerm)
        FBlueprintCompiledStatement& IfZero = Context.AppendStatementForNode(Node);
        IfZero.Type = KCST_GotoIfNot;
        IfZero.LHS = BoolTerm;
        Context.GotoFixupRequestMap.Add(&IfZero, NegativePin);

        // Statement 6: 执行 Zero Pin
        FBlueprintCompiledStatement& ExecZero = Context.AppendStatementForNode(Node);
        ExecZero.Type = KCST_UnconditionalGoto;
        Context.GotoFixupRequestMap.Add(&ExecZero, ZeroPin);

    }
附：class UBPNode_TriGate源代码
BPNode_TriGate.h
#pragma once

#include "CoreMinimal.h"
#include "K2Node.h"
#include "BPNode_TriGate.generated.h"

UCLASS()
class MYBLUEPRINTNODEEDITOR_API UBPNode_TriGate : public UK2Node
{
    GENERATED_BODY()
public:
    // UEdGraphNode interface
    virtual void AllocateDefaultPins() override;

    virtual FText GetTooltipText() const override { return FText::FromString(TEXT("TriGate by Integer")); }
    virtual FText GetNodeTitle(ENodeTitleType::Type TitleType) const override { return FText::FromString(TEXT("TriGate")); }
    // End of UEdGraphNode interface

    // UK2Node interface
    virtual FText GetMenuCategory() const { return FText::FromString(TEXT("MyBlueprintNodes")); }
    virtual void GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const override;
    virtual class FNodeHandlingFunctor* CreateNodeHandler(class FKismetCompilerContext& CompilerContext) const;
    // End of UK2Node interface
};
BPNode_TriGate.cpp
#include "BPNode_TriGate.h"
#include "EdGraphSchema_K2.h"   // BlueprintGraph
#include "BlueprintNodeSpawner.h"   // BlueprintGraph
#include "BlueprintActionDatabaseRegistrar.h"   // BlueprintGraph
#include "BPTerminal.h"
#include "KismetCompilerMisc.h"
#include "KismetCompiler.h"
#include "Kismet/KismetMathLibrary.h"
#include "EdGraphUtilities.h"

namespace TriGatePN
{
    FName Input = TEXT("Integer");
    FName Positive = TEXT("Positive");
    FName Zero = TEXT("Zero");
    FName Negative = TEXT("Negative");
}

class FKCHandler_TriGate : public FNodeHandlingFunctor
{
protected:
    // 为每个Node开辟一个临时bool变量，用来存储输入参数的比较结果
    TMap<UEdGraphNode*, FBPTerminal*> BoolTermMap;
    FBPTerminal* LiteralZeroTerm;

public:
    FKCHandler_TriGate(FKismetCompilerContext& InCompilerContext)
        : FNodeHandlingFunctor(InCompilerContext)
    {
    }

    virtual void RegisterNets(FKismetFunctionContext& Context, UEdGraphNode* Node) override
    {
        FNodeHandlingFunctor::RegisterNets(Context, Node);

        FBPTerminal* BoolTerm = Context.CreateLocalTerminal();
        BoolTerm->Type.PinCategory = UEdGraphSchema_K2::PC_Boolean;
        BoolTerm->Source = Node;
        BoolTerm->Name = Context.NetNameMap->MakeValidName(Node) + TEXT("_CmpResult");
        BoolTermMap.Add(Node, BoolTerm);

        LiteralZeroTerm = Context.CreateLocalTerminal(ETerminalSpecification::TS_Literal);
        LiteralZeroTerm->bIsLiteral = true;
        LiteralZeroTerm->Type.PinCategory = UEdGraphSchema_K2::PC_Int;
        LiteralZeroTerm->Name = TEXT("0");
    }

    virtual void Compile(FKismetFunctionContext& Context, UEdGraphNode* Node) override
    {
        UBPNode_TriGate* MyNode = CastChecked<UBPNode_TriGate>(Node);

        // 查找输入的那个整数的Pin对应的Terminal
        UEdGraphPin* InputPin = Context.FindRequiredPinByName(Node, TriGatePN::Input, EGPD_Input);

        UEdGraphPin* PinToTry = FEdGraphUtilities::GetNetFromPin(InputPin);
        FBPTerminal** pInputTerm = Context.NetMap.Find(PinToTry);
        if (pInputTerm == nullptr)
        {
            CompilerContext.MessageLog.Error(TEXT("FKCHandler_TriGate: Failed to resolve term passed into"), InputPin);
            return;
        }

        FBPTerminal* InputTerm = *pInputTerm;

        // 查找三个输出Pin
        UEdGraphPin* PositivePin = MyNode->FindPin(TriGatePN::Positive, EGPD_Output);
        UEdGraphPin* ZeroPin = MyNode->FindPin(TriGatePN::Zero, EGPD_Output);
        UEdGraphPin* NegativePin = MyNode->FindPin(TriGatePN::Negative, EGPD_Output);

        // 临时bool变量的Terminal
        FBPTerminal* BoolTerm = BoolTermMap.FindRef(MyNode);

        UClass* MathLibClass = UKismetMathLibrary::StaticClass();
        UFunction* CreaterFuncPtr = FindField<UFunction>(MathLibClass, "Greater_IntInt");
        UFunction* EqualFuncPtr = FindField<UFunction>(MathLibClass, "EqualEqual_IntInt");

        // Statement 1: 计算表达式 BoolTerm = Interger > 0
        FBlueprintCompiledStatement& CallCreaterZero = Context.AppendStatementForNode(MyNode);
        CallCreaterZero.Type = KCST_CallFunction;
        CallCreaterZero.FunctionToCall = CreaterFuncPtr;
        CallCreaterZero.LHS = BoolTerm;
        CallCreaterZero.RHS.Add(InputTerm);
        CallCreaterZero.RHS.Add(LiteralZeroTerm);

        // Statement 2: if(BoolTerm)
        FBlueprintCompiledStatement& IfPositive = Context.AppendStatementForNode(Node);
        IfPositive.Type = KCST_GotoIfNot;
        IfPositive.LHS = BoolTerm;

        // Statement 3: 执行 Positive Pin
        FBlueprintCompiledStatement& ExecPositive = Context.AppendStatementForNode(Node);
        ExecPositive.Type = KCST_UnconditionalGoto;
        Context.GotoFixupRequestMap.Add(&ExecPositive, PositivePin);

        // Statement 4: 计算表达式 BoolTerm = Interger == 0
        FBlueprintCompiledStatement& CallEqualZero = Context.AppendStatementForNode(MyNode);
        CallEqualZero.Type = KCST_CallFunction;
        CallEqualZero.FunctionToCall = EqualFuncPtr;
        CallEqualZero.LHS = BoolTerm;
        CallEqualZero.bIsJumpTarget = true;
        CallEqualZero.RHS.Add(InputTerm);
        CallEqualZero.RHS.Add(LiteralZeroTerm);

        IfPositive.TargetLabel = &CallEqualZero;

        // Statement 5: GotoIfNot(BoolTerm)
        FBlueprintCompiledStatement& IfZero = Context.AppendStatementForNode(Node);
        IfZero.Type = KCST_GotoIfNot;
        IfZero.LHS = BoolTerm;
        Context.GotoFixupRequestMap.Add(&IfZero, NegativePin);

        // Statement 6: 执行 Zero Pin
        FBlueprintCompiledStatement& ExecZero = Context.AppendStatementForNode(Node);
        ExecZero.Type = KCST_UnconditionalGoto;
        Context.GotoFixupRequestMap.Add(&ExecZero, ZeroPin);
    }
};

void UBPNode_TriGate::AllocateDefaultPins()
{
    CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
    CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Int, TriGatePN::Input);

    CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, TriGatePN::Positive);
    CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, TriGatePN::Zero);
    CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, TriGatePN::Negative);

}

void UBPNode_TriGate::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    UClass* ActionKey = GetClass();

    if (ActionRegistrar.IsOpenForRegistration(ActionKey))
    {
        UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
        check(NodeSpawner != nullptr);

        ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
    }
}

FNodeHandlingFunctor * UBPNode_TriGate::CreateNodeHandler(FKismetCompilerContext & CompilerContext) const
{
    return new FKCHandler_TriGate(CompilerContext);
}
</code></pre>
</details>

<details>
<summary>理解蓝图技术架构</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/92268112
前面几篇博客谈了几种常用的蓝图扩展方式，其中也对蓝图的底层机制进行了部分的解析，但是还不够整体。这篇文章谈一下目前我对蓝图技术架构的系统性的理解，包括蓝图从编辑到运行的整个过程。

蓝图的发展历程
蓝图是一个突破性的创新，它能够让游戏设计师亲手创造自己想要的“游戏体验”。使用可视化编程的方式，可以大大的加速那种“以体验为核心”的游戏开发的迭代速度，这是一次大胆的尝试，也是一次成功的尝试！（蓝图对于国内流行的那种“以数值成长为核心，以挖坑为目的”的游戏开发，可能没有那么大的意义）

就像很多其他的创新一样，它也是有一个渐进的过程的。它的萌芽就是Unreal Engine 3时代的Kismet。在Unreal Engine 3中，Unreal Script还是主要开发语言，但是可以使用Kismet为关卡添加可视化的事件处理脚本，类似于今天的Level Blueprint。


Unreal Engine 3 官方文档：Kismet Visual Scripting
Blueprint 这个名字很可能是UE4开发了一大半之后才定的。这就是为啥UE4源码里面那么多蓝图相关的模块都以Kismet命名，连蓝图节点的基类也是class UK2Node啦，又有少量模块用的是Blueprint这个名字，其实指代的都是同一系统。


以实例理解蓝图的整个机制
这篇博客的目的是把蓝图的整个体系结构完整的梳理一遍，但是如果只是讲抽象的框架的，会很枯燥，所以我打算以“案例分析”的方式，从一个最简单的蓝图入手，讲解每一步的实际机制是怎样的。


这个案例很简单 新建一个从Actor派生的蓝图 在它的Event Graph中，编辑BeginPlay事件，调用PrintString，显示一个Hello World！

我尽量细的讲一下我这个案例涉及到的每一步的理解！

新建蓝图：BP_HelloWorld
动图封面
这个过程的核心是创建了一个 class UBlueprint 对象的实例，这个对象在编辑器中可以被作为一种Asset Object来处理。class UBlueprint是一个class UObject的派生类。理论上任何UObject都可以成为一个Asset Object，它的创建、存储、对象引用关系等都遵循Unreal的资源管理机制。

具体到代码的话：当我们在编辑器中新建一个蓝图的时候，Unreal Editor会调用UBlueprintFactory::FactoryCreateNew()来创建一个新的class UBlueprint对象；

UObject* UBlueprintFactory::FactoryCreateNew(UClass* Class, UObject* InParent, FName Name, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn, FName CallingContext)
{
        // ......
        // 略去非主干流程代码若干
        // ......

        UClass* BlueprintClass = nullptr;
        UClass* BlueprintGeneratedClass = nullptr;

        IKismetCompilerInterface& KismetCompilerModule = FModuleManager::LoadModuleChecked<IKismetCompilerInterface>("KismetCompiler");
        KismetCompilerModule.GetBlueprintTypesForClass(ParentClass, BlueprintClass, BlueprintGeneratedClass);

        return FKismetEditorUtilities::CreateBlueprint(ParentClass, InParent, Name, BPTYPE_Normal, BlueprintClass, BlueprintGeneratedClass, CallingContext);
}

/** Create a new Blueprint and initialize it to a valid state. */
UBlueprint* FKismetEditorUtilities::CreateBlueprint(UClass* ParentClass, UObject* Outer, const FName NewBPName, EBlueprintType BlueprintType, 
            TSubclassOf<UBlueprint> BlueprintClassType, TSubclassOf<UBlueprintGeneratedClass> BlueprintGeneratedClassType, FName CallingContext)
{
    // ......
    // 略去细节处理流程代码若干
    // ......

    // Create new UBlueprint object
    UBlueprint* NewBP = NewObject<UBlueprint>(Outer, *BlueprintClassType, NewBPName, RF_Public | RF_Standalone | RF_Transactional | RF_LoadCompleted);
    NewBP->Status = BS_BeingCreated;
    NewBP->BlueprintType = BlueprintType;
    NewBP->ParentClass = ParentClass;
    NewBP->BlueprintSystemVersion = UBlueprint::GetCurrentBlueprintSystemVersion();
    NewBP->bIsNewlyCreated = true;
    NewBP->bLegacyNeedToPurgeSkelRefs = false;
    NewBP->GenerateNewGuid();

    // ......
    // 后面还有一些其他处理
    // . Create SimpleConstructionScript and UserConstructionScript
    // . Create default event graph(s)
    // . Create initial UClass
    // ......
}
详见引擎相关源代码：

class UBlueprint： Source/Runtime/Engine/Classes/Engine/Blueprint.h
class UBlueprintFactory：Source/Editor/UnrealEd/Classes/Factories/BlueprintFactory.h
class FKismetEditorUtilities: Source/Editor/UnrealEd/Public/Kismet2/KismetEditorUtilities.h
另外，这个操作还创建了一个class UPackage对象，作为class UBlueprint对象的Outer对象，这个我在后面“保存蓝图”那一小节再展开。

双击打开BP_HelloWorld
当我们在Content Browser中双击一个“BP_HelloWorld”这个蓝图时，Unreal Editor会启动蓝图编辑器，它是一个独立编辑器（Standalone Editor），这个操作是Asset Object的标准行为，就像Material、Texture等对象一样。

动图封面
Unreal Editor通过管理AssetTypeAction来实现上述功能。具体到蓝图的话，有一个class FAssetTypeActions_Blueprint，它实现了class UBlueprint所对应的AssetTypeActions。启动蓝图编辑器这个操作，就是通过：FAssetTypeActions_Blueprint::OpenAssetEditor()来实现的

class ASSETTOOLS_API FAssetTypeActions_Blueprint : public FAssetTypeActions_ClassTypeBase
{
public:
    virtual void OpenAssetEditor(const TArray<UObject*>& InObjects, TSharedPtr<class IToolkitHost> EditWithinLevelEditor = TSharedPtr<IToolkitHost>()) override;
};
这个函数它则调用“Kismet”模块，生成、初始化一个IBlueprintEditor实例，也就是我们天天在用的蓝图编辑器。

void FAssetTypeActions_Blueprint::OpenAssetEditor( const TArray<UObject*>& InObjects, TSharedPtr<IToolkitHost> EditWithinLevelEditor )
{
    EToolkitMode::Type Mode = EditWithinLevelEditor.IsValid() ? EToolkitMode::WorldCentric : EToolkitMode::Standalone;

    for (UObject* Object : InObjects)
    {
        if (UBlueprint* Blueprint = Cast<UBlueprint>(Object))
        {
                FBlueprintEditorModule& BlueprintEditorModule = FModuleManager::LoadModuleChecked<FBlueprintEditorModule>("Kismet");
                TSharedRef< IBlueprintEditor > NewKismetEditor = BlueprintEditorModule.CreateBlueprintEditor(Mode, EditWithinLevelEditor, Blueprint, ShouldUseDataOnlyEditor(Blueprint));
        }
    }
}
详见引擎相关源代码：

class FAssetTypeActions_Blueprint：Source/Developer/AssetTools/Public/AssetTypeActions/AssetTypeActions_Blueprint.h
class FBlueprintEditorModule: Source/Editor/Kismet/BlueprintEditorModule.h
class IBlueprintEditor: Source/Editor/Kismet/BlueprintEditorModule.h
添加节点：PrintString
动图封面
我们在蓝图编辑器里面的每放入一个蓝图节点，就会对应的生成一个class UEdGraphNode的派生类对象，例如前面一篇博客介绍的里面自己所实现的：class UBPNode_SaySomething : public UK2Node（你猜对了：UK2Node是从UEdGraphNode派生的）。UEdGraphNode会管理多个“针脚”，也就是class UEdGraphPin对象。编辑蓝图的过程，主要就是就是创建这些对象，并连接/断开这些针脚对象等。引擎中有一批核心的class UK2Node的派生类，也就是引擎默认提供的那些蓝图节点，具体见下图：


详见引擎相关源代码：

UEdGraph相关代码目录：Source/Runtime/Engine/Classes/EdGraph
引擎提供的蓝图节点相关代码目录：Source/Editor/BlueprintGraph/Class
对于我们这个例子来说，新添加的“PrintString”这个节点，是创建的一个class UK2Node_CallFunction的实例，它是class UK2Node的派生类。它内部保存了一个UFunction对象指针，指向下面这个函数：

void UKismetSystemLibrary::PrintString(UObject* WorldContextObject, const FString& InString, bool bPrintToScreen, bool bPrintToLog, FLinearColor TextColor, float Duration)
详见：Source/Runtime/Engine/Classes/Kismet/KismetSystemLibrary.h

另外还有一个比较有意思的点是：蓝图编辑器中的Event Graph编辑是如何实现的？我想在这里套用一下“Model-View-Controller”模式：

蓝图编辑器管理一个class UEdGraph对象，这个相当于Model
其他的基于Graph的编辑器可能使用class UEdGraph的派生类，例如Material Editor：class UMaterialGraph : public UEdGraph
它使用class UEdGraphSchema_K2来定义蓝图Graph的行为，相当于Controller
这些行为包括：测试Pin之间是否可以连接、创建或删除连接等等
它是class UEdGraphSchema的派生类
详见：Source/Editor/BlueprintGraph/Classes/EdGraphSchema_K2.h
整体的UI、Node布局等，都是一个复用的SGraphEditor，相当于View
Graph中的每个Node对应一个可扩展的Widget，可以从class SGraphNode派生之后添加的SGraphEditor中。对于蓝图来说，它们都是：class SGraphNodeK2Base的派生类
详见：Source/Editor/GraphEditor/Public/KismetNodes/SGraphNodeK2Base.h
点击[Compile]按钮：编译蓝图
动图封面
当点击[Compile]按钮时，蓝图会进行编译。编译的结果就是一个UBlueprintGeneratedClass对象，这个编译出来的对象保存在UBlueprint的父类中：UBlueprintCore::GeneratedClass。

蓝图编译流程的入口函数为：

void FBlueprintEditor::Compile()
这个函数的核心操作是调用：void FKismetEditorUtilities::CompileBlueprint(UBlueprint* BlueprintObj, EBlueprintCompileOptions CompileFlags, FCompilerResultsLog* pResults)
详见：Source/Editor/Kismet/Private/BlueprintEditor.cpp
详见：Source/Editor/UnrealEd/Private/Kismet2/Kismet2.cpp
4.21版本之后的，蓝图编译通过FBlueprintCompilationManager异步进行，对于分析蓝图原理来说增加了难度，可以修改项目中的“DefaultEditor.ini”，添加下面两行关闭这一特性。

[/Script/UnrealEd.BlueprintEditorProjectSettings]
bDisableCompilationManager=true
就我们这个例子来说，编译的核心过程如下：

void FKismetCompilerContext::Compile()
{
    CompileClassLayout(EInternalCompilerFlags::None);
    CompileFunctions(EInternalCompilerFlags::None);
}
可见，蓝图编译主要由两部分：Class Layout，以及根据Graph生成相应的字节码。

Class Layout也就是这个蓝图类包含哪些属性（即class UProperty对象），包含哪些函数（即class UFunction对象），主要是通过这两个函数完成：

UProperty* FKismetCompilerContext::CreateVariable(const FName VarName, const FEdGraphPinType& VarType)
void FKismetCompilerContext::CreateFunctionList()
下面就看一下蓝图Graph编译生成字节码的过程。首先来分享一个查看蓝图编译结果的方法，我们可以修改工程里面的：DefaultEngine.ini，增加一下两行：

[Kismet]
CompileDisplaysBinaryBackend=true
就可以在OutputLog窗口里看到编译出的字节码，我们这个Hello World编译的Log如下：

BlueprintLog: New page: Compile BP_HelloWorld
LogK2Compiler: [function ExecuteUbergraph_BP_HelloWorld]:
Label_0x0:
     $4E: Computed Jump, offset specified by expression:
         $0: Local variable named EntryPoint
Label_0xA:
     $5E: .. debug site ..
Label_0xB:
     $68: Call Math (stack node KismetSystemLibrary::PrintString)
       $17: EX_Self
       $1F: literal ansi string "Hello"
       $27: EX_True
       $27: EX_True
       $2F: literal struct LinearColor (serialized size: 16)
         $1E: literal float 0.000000
         $1E: literal float 0.660000
         $1E: literal float 1.000000
         $1E: literal float 1.000000
         $30: EX_EndStructConst
       $1E: literal float 2.000000
       $16: EX_EndFunctionParms
Label_0x46:
     $5A: .. wire debug site ..
Label_0x47:
     $6: Jump to offset 0x53
Label_0x4C:
     $5E: .. debug site ..
Label_0x4D:
     $5A: .. wire debug site ..
Label_0x4E:
     $6: Jump to offset 0xA
Label_0x53:
     $4: Return expression
       $B: EX_Nothing
Label_0x55:
     $53: EX_EndOfScript
LogK2Compiler: [function ReceiveBeginPlay]:
Label_0x0:
     $5E: .. debug site ..
Label_0x1:
     $5A: .. wire debug site ..
Label_0x2:
     $5E: .. debug site ..
Label_0x3:
     $46: Local Final Script Function (stack node BP_HelloWorld_C::ExecuteUbergraph_BP_HelloWorld)
       $1D: literal int32 76
       $16: EX_EndFunctionParms
Label_0x12:
     $5A: .. wire debug site ..
Label_0x13:
     $4: Return expression
       $B: EX_Nothing
Label_0x15:
     $53: EX_EndOfScript
在蓝图编译时，会把所有的Event Graph组合形成一个Uber Graph，然后遍历Graph的所有节点，生成一个线性的列表，保存到“TArray<UEdGraphNode*> FKismetFunctionContext::LinearExecutionList”；接着遍历每个蓝图节点，生成相应的“语句”，正确的名词是：Statement，保存到“TMap< UEdGraphNode*, TArray<FBlueprintCompiledStatement*> > FKismetFunctionContext::StatementsPerNode”，一个Node在编译过程中可以产生多个Statement；最后调用FScriptBuilderBase::GenerateCodeForStatement()将Statement转换成字节码，保存到TArray<uint8>``UFunction::Script 这个成员变量中。

对于我们这个案例来说，PrintString是使用class UK2Node_CallFunction实现的：

它通过void FKCHandler_CallFunction::CreateFunctionCallStatement(FKismetFunctionContext& Context, UEdGraphNode* Node, UEdGraphPin* SelfPin)来创建一系列的Statement，最重要的是一个“KCST_CallFunction”。
最后通过void FScriptBuilderBase::EmitFunctionCall(FKismetCompilerContext& CompilerContext, FKismetFunctionContext& FunctionContext, FBlueprintCompiledStatement& Statement, UEdGraphNode* SourceNode)来生成蓝图字节码；根据被调用函数的不同，可能转换成以下几种字节码：
EX_CallMath、EX_LocalFinalFunction、EX_FinalFunction、EX_LocalVirtualFunction、EX_VirtualFunction
我们这个PrintString调用的是UKismetSystemLibrary::PrintString()，是EX_FinalFunction
点击[Save]按钮：保存蓝图
动图封面
这个蓝图保存之后，磁盘上会多出一个“BP_HelloWorld.uasset”文件，这个文件本质上就是UObject序列化的结果，但是有一个细节需要注意一下。

UObject的序列化常用的分为两个部分：

UPROPERTY的话，会通过反射信息自动由底层进行序列化
可以在派生类中重载void Serialize(FArchive& Ar)函数可以添加定制化的代码
对于自定义的Struct，可以实现一套“>>”、“<<”操作符，以及Serialize()函数
序列化属于虚幻引擎的基础设施，网上这方面相关的帖子很多，这里就不重复了。

值得一提的是，其实这个BP_HelloWorld.uasset并不直接对于class UBlueprint对象，而是对应一个class UPackage对象。Unreal Editor的Asset处理有一个基础流程，在新建Asset对象时，默认会创建一个class UPackage实例，作为这个Asset的Outer对象。

UObject* UAssetToolsImpl::CreateAsset(const FString& AssetName, const FString& PackagePath, UClass* AssetClass, UFactory* Factory, FName CallingContext)
{

    const FString PackageName = UPackageTools::SanitizePackageName(PackagePath + TEXT("/") + AssetName);

    UClass* ClassToUse = AssetClass ? AssetClass : (Factory ? Factory->GetSupportedClass() : nullptr);

    //! 请注意这里：创建Package对象
    UPackage* Pkg = CreatePackage(nullptr,*PackageName);

    UObject* NewObj = nullptr;
    EObjectFlags Flags = RF_Public|RF_Standalone|RF_Transactional;
    if ( Factory )
    {  
        //! 请注意这里：Pkg作为Outer
        NewObj = Factory->FactoryCreateNew(ClassToUse, Pkg, FName( *AssetName ), Flags, nullptr, GWarn, CallingContext);
    }
    else if ( AssetClass )
    {
        //! 请注意这里：Pkg作为Outer
        NewObj = NewObject<UObject>(Pkg, ClassToUse, FName(*AssetName), Flags);
    }


    return NewObj;
}
这个Package对象在序列化时，也是作为标准的UObject进入序列化流程，但是它起着一个重要的作用：

在整个UObject及其子对象组成的树状结构中，只有最外层（Outermost）的对象是同一个对象时，才会被序列化到一个.uasset文件中
详见：UPackage* UObjectBaseUtility::GetOutermost() const
这样就巧妙的解决了序列化时，如何判断对象之间的关系是聚合、还是链接的问题！我们来考虑另外一个例子：class UStaticMeshComponent：你可以想象一下，当Level中具有一个AStaticMeshActor，它包含UStaticMeshComponent，其静态模型是引用的另外一个UStaticMesh对象，那么序列化的过程是怎么样的呢？

如果UStaticMesh对象序列进入Component、Actor，以至于进入Level，那就不对啦！因为一个静态模型可能在关卡中放置多个实例，如果每个都保存一遍，那就不只是浪费资源了，而是个错误的设计啦！
在引擎中，因为UStaticMesh对象是保存在另外一个.uasset文件中，也就是说它的Outermost对象是另外一个Package，所以在UStaticMeshComponent序列化的时候，它是通过“路径链接”的方式记录的，而不是完整对象！
把BP_HelloWorld拖放到关卡中
动图封面
因为BP_HelloWorld是一个从Actor派生的，所以它可以添加到关卡中。当我们吧BP_HelloWorld拖放到窗口中的时候，和C++创建的Actor派生类一样，其核心操作都调用了AActor* UWorld::SpawnActor( UClass* Class, FTransform const* UserTransformPtr, const FActorSpawnParameters& SpawnParameters )来创建一个新的class AActor派生类对象。对于我们这个例子来说，第一个参数UClass *Class是一个UBlueprintGeneratedClass对象，也就是前面我们是的蓝图编译产生的那个UBlueprintGeneratedClass。

点击[Play]按钮：运行蓝图
动图封面
下面我们就看看这个蓝图在关卡运行时的调用过程。首先，BP_HelloWorld是一个标准的Actor，但是它的BeginPlay事件和C++的Actor派生类重载BeginPlay()实现又有差别。下面我们就先看一下这个事件节点，然后再从字节码解释执行的层面看看PrintString节点是如何被调用的。

BeginPlay事件：AActor::ReceiveBeginPlay()
蓝图编辑器中的BeginPlay事件节点对应的并不是AActor::BeginPlay()，而是AActor::ReceiveBeginPlay()这个事件，我们看一下它的声明：

/** Event when play begins for this actor. */
UFUNCTION(BlueprintImplementableEvent, meta=(DisplayName = "BeginPlay"))
void ReceiveBeginPlay();
从这个声明可以看出：

DisplayName = "BeginPlay"，它只是看上去叫做“BeginPlay”，但是和AActor::BeginPlay()函数是两个东西。AActor::BeginPlay()是C++的实现，并在里面调用了ReceiveBeginPlay()；
ReceiveBeginPlay()是一个“用蓝图实现的事件”，这种函数我们不需要使用C++写它的函数体。
ReceiveBeginPlay()的函数体由UBT生成。生成的代码如下：
static FName NAME_AActor_ReceiveBeginPlay = FName(TEXT("ReceiveBeginPlay"));
void AActor::ReceiveBeginPlay()
{
    ProcessEvent(FindFunctionChecked(NAME_AActor_ReceiveBeginPlay),NULL);
}
这段自动生成的代码实际上是做了两件事：

找到名为“ReceiveBeginPlay”的UFunction对象；
执行“ProcessEvent”函数。
我们先来看一下这个“FindFunctionChecked()”操作，它的调用过程如下：

UObject::FindFunctionChecked()，this==BP_MyActor对象实例
UObject::FindFunction()，其实现为：GetClass()->FindFunctionByName(InName)
UClass::FindFunctionByName()，this==BP_MyActor的UClass对象实例；在这个例子中，this的类型为UClass的子类：UBlueprintGeneratedClass；
上述函数就返回了“ReceiveBeginPlay”对应的一个UFunction对象指针；
在这个例子中，返回的UFunction对象，对应的就是一个“Kismet callable function”（代码注释里的说法），或者是说“蓝图函数”，其字节码就定义在在它的父类UStruct上：TArray<uint8> UStruct::Script。在蓝图编辑器中拉的那个Graph。

接下来，这个UFunction对象作为参数，调用了“AActor::ProcessEvent()”函数，这个函数是父类：UObject::ProcessEvent()的一个简单封装。后者就是蓝图字节码解释执行的部分了！

蓝图字节码的解释执行
首先我们看一下蓝图的字节码长什么样子吧。 在CoreUObject/Public/UObject/Script.h这个文件中有一个enum EExprToken，这个枚举就是蓝图的字节码定义。如果学过汇编语言、JAVA VM或者.Net CLR IL的话，对这些东西并不会陌生：

//
// Evaluatable expression item types.
//
enum EExprToken
{
  ...
  EX_Return = 0x04, // Return from function.
  EX_Jump = 0x06,   // Goto a local address in code.
  EX_JumpIfNot  = 0x07, // Goto if not expression.
  EX_Let  = 0x0F,   // Assign an arbitrary size value to a variable.

  EX_LocalVirtualFunction = 0x45, // Special instructions to quickly call a virtual function that we know is going to run only locally
  EX_LocalFinalFunction = 0x46, // Special instructions to quickly call a final function that we know is going to run only locally
  ...
};
这些字节码又是怎样被解释执行的呢？这部分功能完全是由UObject这个巨大的基类来完成的，引擎并没有一个单独的Blueprint VM之类的模块。这个不必吐槽，这是Unreal的传统，从Unreal第一代的Unreal Script就是这样的。引擎中使用一个全局查找表，把上述字节码映射到函数指针。在运行时，从一个字节码数组中逐个取出字节码，并查找函数指针，进行调用，也就完成了所谓的“字节码解释执行”的过程。

具体的说，引擎定义了一个全局变量：FNativeFuncPtr GNatives[EX_Max]，它保存了一个“字节码到FNativeFuncPtr的查找表。在引擎中通过DEFINE_FUNCTION、IMPLEMENT_VM_FUNCTION来定义蓝图字节码对应的C++函数，并注册到这个全局映射表中，例如字节码“EX_Jump”对应的函数：

DEFINE_FUNCTION(UObject::execJump)
{
    CHECK_RUNAWAY;

    // Jump immediate.
    CodeSkipSizeType Offset = Stack.ReadCodeSkipCount();
    Stack.Code = &Stack.Node->Script[Offset];
}
IMPLEMENT_VM_FUNCTION( EX_Jump, execJump );
字节码解释执行的过程在ProcessLocalScriptFunction()函数中。它使用一个循环while (*Stack.Code != EX_Return)从当前的栈上取出每个字节码，也就是UFunction对象中的那个TArray<uint8> Script成员中的每个元素，解释字节码的代码十分直观：

void FFrame::Step(UObject* Context, RESULT_DECL)
{
    int32 B = *Code++;
    (GNatives[B])(Context,*this,RESULT_PARAM);
}
详见相关引擎源码：

CoreUObject/Public/UObject/Script.h
CoreUObject/Private/UObject/ScriptCore.h
Hello World的执行
在我们这个例子中，这个函数做了以下几件核心的事情：

创建了一个 FFrame 对象，这个对象就是执行这个UFunction所需要的的“栈”对象，他内部保存了一个uint8* Code指针，相当于汇编语言的PC，指向当前需要的字节码；
调用这个UFunction::Invoke()，this就是刚才找到的那个代表ReceiveBeginPlay的UFunction对象；
调用ProcessLocalScriptFunction()函数，解释执行字节码。
我们的PrintString对应的字节码是EX_FinalFunction，最终通过下面这个函数来实现。

DEFINE_FUNCTION(UObject::execFinalFunction)
{
    // Call the final function.
    P_THIS->CallFunction( Stack, RESULT_PARAM, (UFunction*)Stack.ReadObject() );
}
IMPLEMENT_VM_FUNCTION( EX_FinalFunction, execFinalFunction );
它内部通过void UFunction::Invoke(UObject* Obj, FFrame& Stack, RESULT_DECL)调用到UKismetSystemLibrary::PrintString()。

小结一下
OK，罗里吧嗦说了这么多，下面让我们用简练的语言概述一下上面所有内容：

蓝图首先作为一种引擎的Asset对象，可以被Unreal Editor的Asset机制所管理，并且可以被Blueprint Editor来编辑；
在Blueprint Editor中，蓝图的Event Graph以class UEdGraph对象的方式被Graph Editor来编辑；
蓝图通过编译过程，生成一个UClass的派生类对象，即UBlueprintGeneratedClass对象实例；这个实例对象就像C++的UObject派生类对应的UClass那样，拥有UProperty和UFunction；
与C++生成的UClass不同的是，这些UFunction可能会使用蓝图字节码；
在运行时，并不存在一个单独的“蓝图虚拟机”模块，蓝图字节码的解释执行完全是有UObject这个巨大的基类来完成的；
每个字节码对应一个Native函数指针，通过GNatives[ByteCode]查找、调用；
UObject通过解释执行蓝图脚本字节码，调用相应的C++实现的Thunk函数来完成具体的操作；
参考资料
官方文档：Blueprint Compiler Overview
</code></pre>
</details>

<details>
<summary>虚幻4与现代C++: 转移语义和右值引用</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/106977918
C++11标准中引入的最重要的一个特性之一就是转移语义（Move Semantics）啦，理解和使用好转移语义，对我们的程序性能可以有很大帮助。

也许你在网上看过一些相关文章，往往前面先是大篇幅的讲解什么是“右值引用”，让人看的昏昏欲睡，然而“右值引用（Rvalue References）”只是一种底层的语言机制，基于它才能实现所谓的转移语义（Move Semantics）和完美转发（Perfect Forwarding）。在这里，咱们就直奔主题，从Why、What、How三个层面把转移语义搞明白，其中会用到“右值引用”，自然也能理解了。

转移语义解决什么问题？
“转移语义”真的不是啥玄妙的新技术，只是经典C++遗留问题的一个解决方案。在C++中默认使用值类型，值类型的变量之间只能执行“拷贝语义（Copy Semantics）”，而值拷贝对于那些管理着内部重量级资源的对象来说可能很昂贵，例如 std::vector 容器。

OK，咱们先不扯这些技术名词，来看个简单的例子吧。假设：我们要实现一个类，其内部管理一块内存，用来存储大量的数据。在C++中，一般会在构造的时候创建它们、在析构的时候要释放它们。经典C++执行对象复制的时候，需要通过自定义的拷贝构造函数和操作符来实现内部资源对象的复制。例如这样：

class MyString {
  char* mData;
  unsigned int mSize;
 public:
  MyString() : mData(NULL), mSize(0) {}
  ~MyString() {
    if (mData) delete[] mData;
  }
  MyString(const MyString& other) {
    if (other.mSize > 0 && other.mData) {
      mData = new char[other.mSize];
      mSize = other.mSize;
      memcpy(mData, other.mData, mSize);
    } else {
      mData = NULL;
      mSize = 0;
    }
  }
  ... ...
};
上述代码中使用了我已经多年为用过的裸指针，只是为了例子更直观，项目中并不提倡这样用啦。
当下面代码运行的时候，它就会在栈上开辟一个临时对象，然后再调用拷贝构造函数，进行一次内存拷贝，然后把原来那个临时对象析构掉。这太笨拙了吧？！对，就是这个问题！

MyString MakeXXXString() {
  MyString tmp("blah blah");
  tmp += "blah blah";
  return tmp;
}

MyString str = MakeXXXString();
在经典C++中，我们总是使用引用等方式，极力避免这种情况；而在现代C++中，你可能会看到越来越多的大对象按值传递，因为C++11标准中引入了“转移语义”。

如何实现转移语义？
为了获得更好的性能，上面那种情况下，理想的处理方式是把那个临时对象所管理的内部资源的所有权转移给新的对象。那么，怎么转移呢？你需要依C++ 11标准，来实现自己的转移构造函数（Move Constructor）和转移赋值函数（Move Assignment）。具体代码如下：

class MyString {
  char* mData;
  unsigned int mSize;

 public:
    ... ...

  MyString(MyString&& rhs) {
    moveFrom(rhs);
  }

  MyString& operator=(MyString&& rhs) {
    moveFrom(rhs);
    return *this;
  }

private:
  void moveFrom(MyString&& rhs){
    mData = rhs.mData;
    mSize = rhs.mSize;
    rhs.mData = nullptr;
    rhs.mSize = 0;
  }

};
在上面这段代码中，我们实现了一个转移构造函数（Move Constructor）和一个转移赋值操作符（Move Assignment），它们的核心操作都由moveFrom()函数实现。这个函数很简单，就是把原来那个对象中的内存指针和状态值复制到这个对象内，然后把原来那个对象的指针置空，这样那个对象在析构的时候就不会释放这块内存了。于是，也就完成了内部资源的所有权转移。

如果你没有实现拷贝构造函数和拷贝赋值操作符，编译器会在需要的时候自动帮你实现一个；但是转移构造函数和转移赋值操作符则不会自动生成，如果你没有自己实现的话，编译器会转而调用拷贝构造函数或者拷贝赋值操作符。（C++编译器总是很热心的来帮倒忙）

上面的描述就是“转移语义”的一个最典型的场景。通过这个简单例子，我们先不谈艰涩的语言标准，先把问题和解决方法搞清楚。顺带说明一下，Move Semantics，很多人也译作“移动语义”，但是我认为“转移语义”更为贴切：它实现的对象内部资源的所有权转移！

在Unreal引擎中自定义的各种容器，包括TArray、TMap、TSet、FString等，它们也都和现代C++的标准STL容器一样实现了转移构造函数和转移赋值操作符，所以在C++代码中，你可以大胆的返回一个大型的TArray临时对象或者FString数据，不会有性能惩罚。那么对于C++/蓝图的互操作代码又如何呢？请见最后一小节

右值引用和std::move/MoveTemp
需要注意class MyString的转移构造函数和转移赋值操作符的参数类型是：MyString&&，有两个&符号，这个就是“右值引用”啦(并不是带&&就都是右值引用，还可能是所谓的万能引用：Universal Reference，先按下不表)! 因为编译器要明确区分参数类型，才能确定为你调用哪个构造函数或赋值操作符，也就是进行“拷贝”还是“转移”。上面那个MakeXXXString()函数的返回值，就是典型的“右值”。当class MyString具备转移构造函数之后，MyString str = MakeXXXString()这一句就不会再调用拷贝构造函数了，而是调用转移构造函数，而其内部实现只是内存指针的所有权转移。

说到这里，“转移语义”也就说明白了！但是，也许你注意到了引擎中还有一个MoveTemp模板函数（对应C++标准库中的std::move)，这又是什么鬼呢？

简单来说std::move和Unreal的MoveTemp并没有移动什么，它们不负责移动任何东西，实际的移动操作是由对象的移动构造函数和移动赋值操作符完成的，也就是前面说的那些。MoveTemp的本质就是一个“强制类型转换”，使用它就可以把一个左值引用转换成右值引用。这个东西的名字，在C++标准制定过程中，曾有提议叫做“rvalue_cast”，但是最后还是选择了叫做“move”。我们可以理解为：move这个词更形象吧，因为经过MoveTemp之后的对象就死了。。。。它内部管理的数据/资源已经被转移走了。

我们来用TArray举个简单的例子：

TArray<int32> a1 = { 2,2,3,3 };
TArray<int32> a2 = MoveTemp(a1);
a1本来是一个左值，通过MoveTemp强制把它移动到了a2；如果不使用MoveTemp的话，则会调用拷贝构造函数。这两行代码执行之后，a1.Num()和a2.Num()各自会是多少呢？实际的情况是a1已经为空了，a2有那四个元素。

我们再通过一个例子来看一下MoveTemp如何发挥作用：

void AddString(FString Str)
{
    TArray<FString> StrVector;

#if 0
    StrVector.Push(Str);
#else
    StrVector.Push(MoveTemp(Str));
#endif
}
在上面这个函数中，我们可以直接调用StrVector.Push(Str)，则会将Str进行对象拷贝之后添加到TArray，Str的值不变；然而，Str这个对象如果也没其他用处了，那就可以使用StrVector.Push(MoveTemp(Str))这种写法，它调用的则是void TArray::Push(ElementType&& Item)这个成员函数，执行移动语义，Str的内容被清空。

在 TaskGrah 使用移动语义
TaskGraph 是一种 “基于 Task 并行机制”，整体上是比操作基于线程的并行编程要更高级一点，也更易用一些。 UE4 的 TaskGraph 是非常好用的，例如它可以指定Task在哪个线程执行。

TaskGraph的基本用法在引擎源代码注释里面有一个很好的说明，主要就是写下面这样一个class：

class FGenericTask
{
    TSomeType   SomeArgument;
public:
    FGenericTask(TSomeType InSomeArgument) // CAUTION!: Must not use references in the constructor args; use pointers instead if you need by reference
        : SomeArgument(InSomeArgument)
    {
        // Usually the constructor doesn't do anything except save the arguments for use in DoWork or GetDesiredThread.
    }
    ~FGenericTask()
    {
        // you will be destroyed immediately after you execute. Might as well do cleanup in DoWork, but you could also use a destructor.
    }
    FORCEINLINE TStatId GetStatId() const
    {
        RETURN_QUICK_DECLARE_CYCLE_STAT(FGenericTask, STATGROUP_TaskGraphTasks);
    }

    [static] ENamedThreads::Type GetDesiredThread()
    {
        return ENamedThreads::[named thread or AnyThread];
    }
    void DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)
    {
        // The arguments are useful for setting up other tasks. 
        // Do work here, probably using SomeArgument.
        MyCompletionGraphEvent->DontCompleteUntil(TGraphTask<FSomeChildTask>::CreateTask(NULL,CurrentThread).ConstructAndDispatchWhenReady());
    }
};
这里有一个注释： Must not use references in the constructor args ，也就是说不支持引用类型。这时候就是“移动语义”可以发挥作用的地方了。

例如，咱们要做一个Task来分析一个巨大的字符串：

class MyStringParseTask
{
  FString mString;
public:
  MyStringParseTask(FString InString):mString(MoveTemp(InString))
  {}
  ....
}
我们使用mString(MoveTemp(InString))就可以减少一次数据的拷贝了。

蓝图/C++互操作中的移动语义
我分了几种情况进行了测试，下面逐个看一下：

C++返回右值的情况
假设我们有这样一个供蓝图调用的函数：

UFUNCTION(BlueprintCallable, Category = "Modern C++")
TArray<int> MakeBigArrayInCpp();
在".generated.h"中生成的对应的Thunk函数是这样的：

DECLARE_FUNCTION(execMakeBigArrayInCpp) \
    { \
        P_FINISH; \
        P_NATIVE_BEGIN; \
        *(TArray<int32>*)Z_Param__Result=P_THIS->MakeBigArrayInCpp(); \
        P_NATIVE_END; \
    } \
对Z_Param__Result执行赋值操作会调用TArray的移动赋值操作符，所以这里并不会产生TArray内部数据的拷贝，也就是说：C++返回临时对象的情况是支持移动语义。

蓝图返回右值的情况
经测试，这个不支持！下面这个代码是可以编译通过，但是在蓝图中无法创建这个节点。

UFUNCTION(BlueprintImplementableEvent, Category = "Modern C++")
TArray<uint8> MakeBigArray();
函数参数的支持情况
使用C++编程的蓝图函数可以通过UPARAM来支持左值引用，来处理蓝图中的对象，类似下面这样：

UFUNCTION(BlueprintCallable)
 static void DoSomething(UPARAM(ref) TArray<int> &InOutArray);
不过，这种方式不支持右值引用参数传递，这也是意料之中的，这种需求也极少有吧。

延伸阅读
UE4 Coding Standard
Modern C++: What You Need to Know,Herb Sutter, MS Build 2014
右值引用与转移语义,李胜利, IBM Developer
</code></pre>
</details>

<details>
<summary>将异步操作封装为蓝图节点</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/107021667
在蓝图中我们可以使用一些异步节点，典型的就是“Delay”：它并不会阻塞当前的游戏逻辑，而是在指定的时间之后，再执行后面的操作。


​ "Delay"的实现是在class UKismetSystemLibrary中的 static void Delay(UObject* WorldContextObject, float Duration, struct FLatentActionInfo LatentInfo )函数，详见：EngineDir\Source\Runtime\Engine\Classes\Kismet\KismetSystemLibrary.h 。这种实现方式叫做 Latent Function，这个东西在虚幻3的Unreal Script中就有了。具体实现方式这里就不细说了。因为这种方式应该属于历史遗产啦，现在有另外一种更方便的实现方式：Blueprint Async Action。

在周期很长的大型项目中，会出现这种情况：一个问题有不止一种解决方案或者处理手法，这个很好理解：团队在发展，技术在发展，一些东西做着做着有了新想法，老代码跑的很稳定，也懒得改了。虚幻4就是这样一个超长周期的项目，所以也不用迷信引擎源代码，要用历史的、发展的眼光看得它。
Blueprint Async Action
​ 引擎提供了一个基类：class UBlueprintAsyncActionBase，只要从它派生，并按照一定的约定来实现这个派生类，在蓝图编辑器中就可以自动产生相应的异步节点啦。下面就通过一个最简单的例子，来看看这个派生类的写法。

​ 这个例子很简单，就是发送一个Http请求，根据结果调用“成功”和“失败”两个分支。


实例：把HTTP请求封装成一个蓝图的异步节点
首先，需要建立一个 class UBlueprintAsyncActionBase 的派生类：

UCLASS()
class UBlueprintAsyncHttpRequest : public UBlueprintAsyncActionBase
{
    GENERATED_BODY()
};
然后，要为这个类建立一个工厂方法：

这个方法必须设置为BlueprintCallable，并标记BlueprintInternalUseOnly：UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = "true"))
这个工厂方法的名称，就会是我们的蓝图节点的名称了；这个函数的参数会变为节点的输入参数；
定义一个 Multicast Delegate 类型，作为异步操作的完成通知；这个类可以有多个完成通知，但是签名只能有一个；
使用这个 delegate 类型为类添加成员变量，作为完成通知，这个可以有多个；例如，在这个类里面我定义了OnSuccess和OnFail两个Delegate，单他们的类型都是FHttpResponseDelegatge；
下面就是这个类的核心定义了：

UCLASS()
class UBlueprintAsyncHttpRequest : public UBlueprintAsyncActionBase
{
    GENERATED_BODY()

public:
    // Factory Method
    UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = "true"))
        static UBlueprintAsyncHttpRequest* HttpRequest(const FString& URL);

    UPROPERTY(BlueprintAssignable)
        FHttpResponseDelegatge OnSuccess;

    UPROPERTY(BlueprintAssignable)
        FHttpResponseDelegatge OnFail;
};
这个类实现之后，在蓝图编辑器里就可以搜到“HttpRequest”这个节点了。不过，它会有右侧会有三个Exec针脚，就像下图这样：


这是因为引擎默认有一个Then针脚，可以通过为这个UClass设置meta来关闭它：UCLASS(meta=(HideThen=true))。不过，留着它更有用：在等待异步请求的过程中，可以立即去做其他事情。

稍微挖掘一下
​ 这些又没有官方文档，我是咋知道的呢？ 是这样的，我稍微挖掘了一下引擎的源代码，上面说的那些规则是从源代码中的两个类来的：

class UK2Node_AsyncAction : public UK2Node_BaseAsyncTask
EngineDir\Source\Editor\Kismet\Public\Nodes\K2Node_AsyncAction.h
class UK2Node_BaseAsyncTask : public UK2Node
EngineDir\Source\Editor\BlueprintGraph\Classes\K2Node_BaseAsyncTask.h
class UK2Node_AsyncAction 从 class UK2Node_BaseAsyncTask 派生，它们实现的功能大致如下：

class UK2Node_AsyncAction 这个类主要负责绑定class UBlueprintAsyncActionBase派生类的工厂方法，也就是上例中的：UBlueprintAsyncHttpRequest* HttpRequest(const FString& URL);
class UK2Node_BaseAsyncTask 负责创建节点的基本属性：
使用反射，读取工厂方法的输入参数，作为节点的输入变量
还是通过反射，查找这个类有哪些UMulticastDelegateProperty，来创建右侧的Output针脚。前面说的HideThen逻辑也是这里实现的；
至于它们具体是如何实现异步操作封装的，有兴趣的朋友可以去研究一下UK2Node_BaseAsyncTask::ExpandNode()的实现，我先偷个懒吧！

例子完整代码
这个例子的完整工程在这里：

完整工程的GitHub地址
​github.com/neil3d/UnrealCookBook/tree/master/BlueprintAsync
下面是实现这个节点的完整C++代码

BlueprintAsyncHttpRequest.h
#include "CoreMinimal.h"
#include "Kismet/BlueprintAsyncActionBase.h"
#include "Http.h"   // HTTP
#include "BlueprintAsyncHttpRequest.generated.h"

DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FHttpResponseDelegatge, int32, Code, FString, Data);

UCLASS(meta=(HideThen=true))
class BLUEPRINTASYNC_API UBlueprintAsyncHttpRequest : public UBlueprintAsyncActionBase
{
    GENERATED_BODY()

public:
    // Factory Method
    UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = "true"))
        static UBlueprintAsyncHttpRequest* HttpRequest(const FString& URL);

    UPROPERTY(BlueprintAssignable)
        FHttpResponseDelegatge OnSuccess;

    UPROPERTY(BlueprintAssignable)
        FHttpResponseDelegatge OnFail;

private:
    void OnHttpResponse(FHttpRequestPtr Request, FHttpResponsePtr Response, bool bWasSuccessful);

    void SendRequest(const FString& URL);
};
BlueprintAsyncHttpRequest.cpp
#include "BlueprintAsyncHttpRequest.h"

UBlueprintAsyncHttpRequest* UBlueprintAsyncHttpRequest::HttpRequest(const FString& URL)
{
    UBlueprintAsyncHttpRequest* NewRequest = NewObject<UBlueprintAsyncHttpRequest>();
    NewRequest->SendRequest(URL);
    return NewRequest;
}

void UBlueprintAsyncHttpRequest::SendRequest(const FString& URL)
{
    AddToRoot();

    FHttpModule& HttpModule = FHttpModule::Get();

    TSharedRef<IHttpRequest> Request = HttpModule.CreateRequest();
    Request->SetURL(URL);
    Request->SetVerb("GET");
    Request->OnProcessRequestComplete().BindUObject(this, &UBlueprintAsyncHttpRequest::OnHttpResponse);
    Request->ProcessRequest();
}

void UBlueprintAsyncHttpRequest::OnHttpResponse(FHttpRequestPtr Request, FHttpResponsePtr Response, bool bWasSuccessful)
{
    if (bWasSuccessful && Response.IsValid())
    {
        OnSuccess.Broadcast(
            Response->GetResponseCode(),
            Response->GetContentAsString()
        );
    }
    else
    {
        OnFail.Broadcast(-1, TEXT(""));
    }

    RemoveFromRoot();
}
注:[project].build.cs文件里加入"Http”模块
</code></pre>
</details>

<details>
<summary>虚幻4与现代C++：Lambda好用也有坑</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/110077218
C++ Lambda 基础知识
Lambda ，就是希腊字母“λ”，据说是代表着“λ演算（lambda calculus）”。C++11开始支持Lambda，可以说它只是一个便利机制。Lambda能做的事情，本质上都可以手写代码完成，但是它确实太方便了！怎么说呢，还好以前没有认真学std::bind各种绕法，现在用lambda方便多了。

我们可以通过简单的例子初步认识一下：

int var1 = 100;
std::string var2 = "hello";

auto myLambda = [var1, &var2](int param) -> std::string {
    var2.append(std::to_string(var1));
    var2.append(std::to_string(param));
    return var2;
 };

std::cout << "fistLambda typeid = " << typeid(myLambda).name() << std::endl;
上面代码中由[]开头的那一串就是lambda了。在大多数情况下我们就使用“lambda”这个名词就够了，但其实仔细想想，其中代码涉及到三个概念：

lambda表达式（lambda expression）
闭包（closure）
闭包类（closure class）
例如，在上面这段代码中：

定义了一个变量：myLambda，它就是“闭包”
myLambda 的类型是一个编译器生成的匿名的类，也就是“闭包类”；
这个闭包类是由等号右边的"lambda表达式"生成的，这个lambda表达式：
按值捕获了var1；按引用捕获了var2;
并且接受一个int型参数；
返回一个std::string对象
我们可以尝试把编译器自动生成的"闭包类"写出来，把“闭包”对象的构造也写出来，就应该能说明问题了。下面这段代码大体上和上面的代码等效：

int var1 = 100;
std::string var2 = "hello";

class MyClosureClass {
  int var1;
  std::string& var2;

public:
    MyClosureClass(int inVar1, std::string& inVar2)
        : var1(inVar1), var2(inVar2) {}

    // not default constructible
    MyClosureClass() = delete;

    MyClosureClass(const MyClosureClass&) = default;
    MyClosureClass(MyClosureClass&&) = default;
    ~MyClosureClass() = default;

    // not copy assignable
    MyClosureClass& operator=(const MyClosureClass&) = delete;

    // function-call operator
    std::string operator()(int param) {
      var2.append(std::to_string(var1));
      var2.append(std::to_string(param));
      return var2;
    }
    };

    auto myLambda = MyClosureClass(var1, var2);
    std::cout << "myLambda: " << myLambda(2233) << std::endl;
class MyClosureClass 还可能包含一个自定义的类型转换操作符，用来把闭包对象转换成函数指针。
捕获列表“有坑”
lambda表达式的常用语法格式如下：

[ captures ] ( params ) -> return_type { body }
为了理解方便，只列出了常用元素，不全面。
其中比较值得一说的就是[captures]：捕获列表了！

[captures]支持多种写法，首先就是个人不推荐使用的两种默认捕获模式（default capture modes）：

[=]: 按值捕获当前作用域所有变量
[&]: 按引用捕获当前作用域所有变量
从性能、代码可维护性等方面都不建议使用这两种方式。比较常用的写法就是明确列出需要捕获的变量，例如：[var1, &var2], 其中var1使用了“按值捕获”模式，var2前面加了一个&代表着它使用“按引用捕获”的模式。下面就分别讨论一下“按值捕获”和“按引用捕获”有什么坑。

按值捕获 & 捕获时机
按值捕获就是在创建闭包的时候，将当前作用域内的变量赋值到闭包类的成员变量中，这个比较好理解，但是也有一个小小的坑。请看下面代码：

FString LocalStr = TEXT("First string");

auto TestLambda = [LocalStr]()  {
    UE_LOG(LogTemp, Error, TEXT("String = %s ."), *LocalStr);
};

LocalStr = TEXT("Second string");
TestLambda();
当调用TestLambda()的时候，也许会觉得意外，输出的还是：String = First string。这就是要注意的地方，当闭包生成的那一刻，被捕获的变量已经按值赋值的方式进行了捕获，后面那个LocalStr对象再怎么变化，已经和闭包对象里面的值没有关系了。

如果按引用捕获，则可以跟踪LocalStr的更新了，但是按引用捕获的坑更深。

按引用捕获 & 悬空引用
如果是在C#中使用 lambda 就简单很多了，它有自动垃圾回收、class对象全部是引用类型这些特性，而对于C++来说，对象的生命周期、内存管理这根弦始终要绷紧。在C++编程中，程序员有责任保证Lambda调用的时候，保证被捕获的变量仍然有效~！是的，责任在你，而不在编译器。如果不能很好理解这点，就会遇到悬空引用的问题！

悬空引用（ dangling references ）就是说我们创建了一个对象的引用类型的变量，但是被引用的对象被析构了、无效了。一般情况下，引用类型的变量必须在初始化的时候赋值，很少遇到这种情况，但是如果lambda被延迟调用，在调用时，已经脱离了当前的作用域，那么按引用捕获的对象就是悬空引用。

我们先来看一段代码：

FString LocalStr = TEXT("Local string");

auto TestLambda = [&LocalStr]() {
    UE_LOG(LogTemp, Error, TEXT("String = %s ."), *LocalStr);
    LocalStr = TEXT("Lambda string");
};

// 在这里直接调用是没问题的
TestLambda();

// 在Timer中调用，妥妥的Crash！
FTimerDelegate Delegate;
Delegate.BindLambda(TestLambda);

FTimerHandle TestTimer;
GetWorldTimerManager().SetTimer(TestTimer, Delegate, 1.0f, true);
上面这段的代码，在定义lambda之后立即调用则可以运行，同样一个labmda放入timer则会crash！这是为什么呢？

前面基本概念那一部分讲到了TestLambda是一个闭包对象，它的类型是编译器生成的一个匿名的class。对于这个例子，我尝试把这个闭包类的核心部分写出来：

class MyLambdaClass {
    FString& LocalStr;
public:
    MyLambdaClass(FString& InLocalStr) :LocalStr(InLocalStr) {}

    void operator()() const 
    {
        UE_LOG(LogTemp, Error, TEXT("String = %s ."), *LocalStr);
        LocalStr = TEXT("Lambda string");
    }
};
看到上面这个class，应该就很清晰了：

TestLambda()直接调用那一句，FString LocalStr这个对象还在作用域内，所以可以执行；
而在Timer执行的时候，LocalStr这个对象已经出了作用域，被析构了，这个时候Lambda中捕获的那个引用就变成了悬空引用啦，所以会导致Crash！
总之，使用各种 Delegate 的 “BindLambda” 的时候，要格外小心悬空引用的风险。

捕获UObject指针
虚幻的UObject具备自动垃圾回收机制，但这个机制是基于对象之间的引用关系的，也就是说一个 UObject 指针被捕获之后，还是可能被垃圾回收的。所以，对于延迟调用的lambda是不建议捕获UObject的；如果实在需要的话建议使用 FWeakObjectPtr ，例如这样：

AActor* TargetActor = FindMyTargetActor();

auto ObjectLambda = [ActorPtr = TWeakObjectPtr<AActor>(TargetActor)](const FVector& Offset) {
    if (ActorPtr.IsValid()) {
        AActor* TargetActor = ActorPtr.Get();
        TargetActor->AddActorWorldOffset(Offset);
    }
};
通过 FWeakObjectPtr 引用 UObject 指针不会影响对象的生命周期，在 FWeakObjectPtr::IsValid() 方法中默认会判断当前对象是不是 “Pending Kill” 状态。

如果希望持有某个UObject的强引用，保证它不被垃圾回收，那么建议不要用lambda，建议使用其他写法：

使用 Delegate 的 BindUObject 或者 BindUFunction 来处理；
如果是很复杂的代码，也可以用 UObject 或者 FGCObject 的派生类来处理。
C++14的初始化捕获（init capture）
在上面UObject指针的例子中，捕获列表是这样写的：ActorPtr = TWeakObjectPtr<AActor>(TargetActor)，这种写法就是C++14引入的新特性“初始化捕获”，也被称为广义捕获（generalized capture）。这个的语法是这样的：

等号左边的变量是声明在“闭包类” 里面的，它的类型由编译器自动推导；
等号右边的表达式，其作用域就是当前定义lambda的作用域，可以引用局部变量或者实参。
这个语法更有用的地方是：它可以把使用“移动语义”把局部变量移动到闭包中，类似这样：

FString SomeBigString;
// ...
auto MyLambda = [MyStr = MoveTemp(SomeBigString)] {
//....
};
延伸阅读
Unreal Engine Coding Standard
Lambda expressions (since C++11), cppreference.com
</code></pre>
</details>

<details>
<summary>虚幻4现代C++编程实践·目录</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/113088107
所谓的“现代C++”，就是指C++ 11标准之后的C++语言，与之相对应的是“经典C++”，也就是C++ 98/03标准的C++语言。

Unreal Engine 4使用C++14标准开发，用到了很多现代C++的特性和设计理念，而且它不使用标准库，这可能就需要我们对现代C++理解的更清晰一点。于是，打算把自己对于虚幻引擎中的现代C++编程的理解整理成博客，希望对Unreal C++开发的朋友有点帮助。这一系列博客主要还是讲现代C++的基础编程为主，并注重在虚幻引擎开发中的实用性。

这是一个“想到哪，写到哪”的专栏，目录内容持续更新中...

C++编程基础
转移语义是C++11引入的最重要的改进之一，从实用性的角度来理解一下这个概念：
转移语义和右值引用
74 赞同 · 11 评论文章

理解C++ Lambda 的实现机制，以及有什么坑：
Lambda好用也有坑
65 赞同 · 4 评论文章

虚幻4中的C++单元测试:
虚幻4中的C++单元测试
66 赞同 · 7 评论文章

基于任务的并行编程与虚幻4的TaskGraph编程实践
理解基于任务的并行编程，并讲解 TaskGraph 的入门用法：
十分钟上手TaskGraph
109 赞同 · 6 评论文章

Fork-Join是并行编程中常用的设计模式，利用虚幻4的 TaskGraph 很容易实现这种模式：
实现Fork-Join模型
33 赞同 · 8 评论文章
</code></pre>
</details>

<details>
<summary>虚幻4之TaskGraph：十分钟上手TaskGraph</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/113093600
基于任务的并行程序设计
基于任务（task-based）的并行编程可以说是现代 C++ 的一个重要发展方向。什么是“基于任务的并行编程”呢？简单来做个比较的话就很清晰了。

传统的 C++ 并行编程是直接操作OS层面的线程（std::thread）、线程同步对象（ std::mutex, std::condition 等），这种叫做基于线程（thread-based）的并行编程。在这种开发模式下，程序员必须非常仔细的处理线程间的同步、共享数据等问题，为了避免条件竞争(race condition)和死锁而殚精竭虑。虚幻4里面的 FRunable 就是这种模式。

如果说“基于线程的并行编程”就像是在直接使用 D3D、OpenGL 在开发图形程序，那么“基于任务的并行编程”的模式就相当于在一个图形渲染引擎基础上做开发。我们可以更多的在自己的问题域里面思考：

如何把整个处理流程划分成“任务”；
哪些任务是可以并行的，哪些任务需要串行；
然后通过“基于任务”的 API 来派发任务。这个小引擎内部的调度器会帮我们管理线程池等底层对象。

基于任务的模式已经相当成熟，比较有名的实现包括:

微软的 PPL(Parallel Patterns Library)
Intel 的 TBB(Threading Building Blocks)
并且两家已经在2015年一起发起了C++标准提案：N4411-Task Block，Herb Sutter 也是发起人之一。

虚幻4的 TaskGraph 简介
虚幻4的 TaskGraph 就是“基于任务的并行编程”设计思想下的一种很棒的实现。它的最大特点就是：易用，后面你将看到。

TaskGraph 应该是虚幻4引擎中后期才加入的一个机制，但越来越多的系统开始使用它。它不是一个标准的并行编程框架，而一个专门针对虚幻4定制的。它的底层实现代码有点绕，咱们就先不分析它，而是着重说说怎么用好它。

虚幻4的 TaskGraph 有以下常用特性：

在创建任务时，可以指定一个或多个前置任务；这些任务就可以组成一个 Graph 啦；
可以指定任务在哪个线程中执行；这个很实用，后面例子中可以看到；
至于任务之间如何共享数据等问题，TaskGraph 框架是不管的，责任在于开发 Task 的人。不过，不要害怕：你可能发现，任务分配的好的话，这个问题可以很大程度上简单化。

通过实例上手 TaskGraph
我还是通过一个最简单的例子来说明 TaskGraph 的基本用法： - 假定我们需要异步加载一个文本文件。

下面是这个例子的测试接口定义：

建立了一个 Actor 的派生类
提供一个接口，用来发起异步加载的操作：void AsyncLoadTextFile(const FString& FilePath)
提供一个蓝图事件，供上层来接收加载的文件内容：void OnFileLoaded(const FString& FileContent)
完整代码如下：FirstAsyncTask.h
UCLASS()
class MAKINGUSEOFTASKGRAPH_API AFirstAsyncTask : public AActor
{
    GENERATED_BODY()
public:
    UFUNCTION(BlueprintCallable)
        void AsyncLoadTextFile(const FString& FilePath);

    UFUNCTION(BlueprintImplementableEvent)
        void OnFileLoaded(const FString& FileContent);

};
实现代码很简单：

在 AsyncLoadTextFile() 函数中发起一个异步操作；
OnFileLoaded() 将在蓝图中实现，C++这里没有代码；
任务代码是通过自定义的一个class实现的：FTask_LoadFileToString，这个Task的实现代码后面详说；
完整代码如下：FirstAsyncTask.cpp
void AFirstAsyncTask::AsyncLoadTextFile(const FString& FilePath)
{
    FTaskDelegate_FileLoaded TaskDelegate;
    TaskDelegate.BindUFunction(this, "OnFileLoaded");

    TGraphTask<FTask_LoadFileToString>::CreateTask()
                  .ConstructAndDispatchWhenReady(FilePath, TaskDelegate);
}
主线程的代码就是这么简单！然后，我建立一个 class AFirstAsyncTask 的蓝图派生类，来测试它：


看到这里，你可能想要拍砖了：你在一个异步任务里面调用蓝图 OnFileLoaded ，这个不是找死吗？！且慢，砖可以先举着，容我慢慢解释！其关键就在于这个异步任务是如何定义的。

定义任务
用户定义的任务必须要满足 TGraphTask 中对 Task 的接口需求。下面这个 class FTask_LoadFileToString 就是我写的一个简单的任务：

class FTask_LoadFileToString
{
    FTaskDelegate_FileLoaded TaskDelegate;
    FString FilePath;

    FString FileContent;
public:
    FTask_LoadFileToString(FString InFilePath, FTaskDelegate_FileLoaded InTaskDelegate) :
        TaskDelegate(InTaskDelegate), FilePath(MoveTemp(InFilePath))
    {}

    FORCEINLINE TStatId GetStatId() const   {
        RETURN_QUICK_DECLARE_CYCLE_STAT(FTask_LoadFileToString, STATGROUP_TaskGraphTasks);
    }

    static ENamedThreads::Type GetDesiredThread() { return CPrio_LoadFileToString.Get(); }
    static ESubsequentsMode::Type GetSubsequentsMode() 
    { return ESubsequentsMode::TrackSubsequents; }

    void DoTask(ENamedThreads::Type CurrentThread, 
         const FGraphEventRef& MyCompletionGraphEvent)    {
        // load file from Content folder
        FString FullPath = FPaths::Combine(FPaths::ProjectContentDir(), FilePath);
        if (FPaths::FileExists(FullPath))
        {
            FFileHelper::LoadFileToString(FileContent, *FullPath);
        }

        // create completion task
        FGraphEventRef ChildTask =
           TGraphTask<FTaskCompletion_LoadFileToString>::CreateTask(nullptr, CurrentThread).
            ConstructAndDispatchWhenReady(TaskDelegate, FileContent);
        MyCompletionGraphEvent->SetGatherThreadForDontCompleteUntil(
              ENamedThreads::GameThread);
        MyCompletionGraphEvent->DontCompleteUntil(ChildTask);
    }
};
挨个说一下这个类的几个方法：

构造函数是完全自定义的，有多少参数都可以；底层会通过“可变参数模板(Variadic Templates)”把所有参数全都转发过来；
引擎中有一句注释说不支持引用类型的参数：CAUTION!: Must not use references in the constructor args; use pointers instead if you need by reference
不过，我在引擎的代码中发现了有使用引用类型参数的任务，目前还不确定；使用引用类型的话，确实是有很大的“悬空引用(dangling references)”的风险，建议还是不用；
GetStatId()：返回一个 StatId，一般就按照这种固定写法就好了；
GetDesiredThread()：返回这个任务希望运行的线程；常用的写法有：
通过一个 class FAutoConsoleTaskPriority 对象来获得一个当前合适的线程；
指定某个线程，例如：ENamedThreads::GameThread；
GetSubsequentsMode()：有两个可选值，TrackSubsequents 和 FireAndForget ；
DoTask()：这个就是写我们这个任务实际的工作的代码了；
下面就着重看一下这个任务的实现代码：FTask_LoadFileToString::DoTask()，这个函数干了两件事：

首先就是加载那个文本文件了；
然后，创建了一个FTaskCompletion_LoadFileToString子任务，这个子任务负责执行“完成通知”；
重点来了：我指定了FTaskCompletion_LoadFileToString必须在 GameThread 执行！
下面看一下class FTaskCompletion_LoadFileToString的完整代码：

class FTaskCompletion_LoadFileToString
{
    FTaskDelegate_FileLoaded TaskDelegate;
    FString FileContent;
public:
    FTaskCompletion_LoadFileToString(FTaskDelegate_FileLoaded InTaskDelegate, 
         FString InFileContent) :
        TaskDelegate(InTaskDelegate), FileContent(MoveTemp(InFileContent))
    {}

    FORCEINLINE TStatId GetStatId() const   {
        RETURN_QUICK_DECLARE_CYCLE_STAT(FTaskCompletion_LoadFileToString, 
        STATGROUP_TaskGraphTasks);
    }

    static ENamedThreads::Type GetDesiredThread() { return ENamedThreads::GameThread; }
    static ESubsequentsMode::Type GetSubsequentsMode() 
    { return ESubsequentsMode::TrackSubsequents; }

    void DoTask(ENamedThreads::Type CurrentThread, 
              const FGraphEventRef& MyCompletionGraphEvent){
        check(IsInGameThread());
        TaskDelegate.ExecuteIfBound(MoveTemp(FileContent));
    }
};
OK！砖举累了吧，可以放下了：

我是通过这个完成通知任务class FTaskCompletion_LoadFileToString来调用AFirstAsyncTask::OnFileLoaded那个蓝图事件的；
FTaskCompletion_LoadFileToString::GetDesiredThread() 返回值为：ENamedThreads::GameThread，也就是要求它在 GameThread 执行！
这个任务的DoTask()代码就很直接了当了，有两个小点稍微说一下：

你看，我在 DoTask() 里面写了 check(IsInGameThread())，确定是Game Thread。:)
我通过引擎提供的 MoveTemp 模板，实现了FString FileContent的转移拷贝，减少了内存拷贝；关于转移语义可以看我之前的博客。
派发任务
就像上面那样，定义好 “Task 类”之后就需要调用 TaskGraph 来派发这个任务了，就像下面这样：

TGraphTask<FTask_LoadFileToString>::CreateTask().
        ConstructAndDispatchWhenReady(FilePath, TaskDelegate);
解释一下上面这一行代码：

TGraphTask 是一个模板类，它接收一个类型参数，就是我们前面定义的 “Task 类”
首先是调用 TGraphTask::CreateTask() 函数，这个函数有两个参数：
FGraphEventArray* Prerequisites：前置任务列表，默认值为NULL；这个非常有用，后面我单独；讲
ENamedThreads::Type CurrentThreadIfKnown：当前线程，默认值为ENamedThreads::AnyThread；
这里我直接使用了函数参数的默认值；
TGraphTask::CreateTask() 返回一个对象，它的类型是：class TGraphTask::FConstructor
FConstructor 有两个主要的方法：ConstructAndDispatchWhenReady()、ConstructAndHold()，名字就说明它的作用了
这两个方法主要就是构造我们定义的 “Task 类”的实例，并且使用"可变参数模板(Variadic Templates)"把构造函数的参数转发到 “Task 类的构造函数”
可以说这就是 TaskGraph 系统的常用 API 啦！非常非常的简单易用！这么好用的系统，EPIC竟然没有文档，难道是舍不得给大家用吗？哈哈！

小结
这个例子相当于 Hello World 啦！在这个例子中，我使用“父子任务”的结构，来执行异步操作，并在 GameThread 中发送完成通知。这算是 TaskGraph 的用法之一，后续我会继续分享 TaskGraph 的实战经验。TaskGraph 运用过程中的一些问题，也会逐步澄清。

相关的样例工程在我的 GitHub ：

neil3d/UnrealCookBook
​github.com/neil3d/UnrealCookBook/tree/master/MakingUseOfTaskGraph

这里附上这个Demo相关的完整代码：

FirstAsyncTask.h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "FirstAsyncTask.generated.h"

UCLASS()
class MAKINGUSEOFTASKGRAPH_API AFirstAsyncTask : public AActor
{
    GENERATED_BODY()

public:
    AFirstAsyncTask();

    UFUNCTION(BlueprintCallable)
        void AsyncLoadTextFile(const FString& FilePath);

    UFUNCTION(BlueprintImplementableEvent)
        void OnFileLoaded(const FString& FileContent);

};
FirstAsyncTask.cpp
#include "FirstAsyncTask.h"
#include "Misc/Paths.h"
#include "Misc/FileHelper.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
DECLARE_DELEGATE_OneParam(FTaskDelegate_FileLoaded, FString);

class FTaskCompletion_LoadFileToString
{
    FTaskDelegate_FileLoaded TaskDelegate;
    FString FileContent;
public:
    FTaskCompletion_LoadFileToString(FTaskDelegate_FileLoaded InTaskDelegate, FString InFileContent) :
        TaskDelegate(InTaskDelegate), FileContent(MoveTemp(InFileContent))
    {}

    FORCEINLINE TStatId GetStatId() const
    {
        RETURN_QUICK_DECLARE_CYCLE_STAT(FTaskCompletion_LoadFileToString, STATGROUP_TaskGraphTasks);
    }

    static ENamedThreads::Type GetDesiredThread() { return ENamedThreads::GameThread; }

    static ESubsequentsMode::Type GetSubsequentsMode() { return ESubsequentsMode::TrackSubsequents; }

    void DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)
    {
        check(IsInGameThread());

        TaskDelegate.ExecuteIfBound(MoveTemp(FileContent));
    }
};

FAutoConsoleTaskPriority CPrio_LoadFileToString(
    TEXT("TaskGraph.TaskPriorities.LoadFileToString"),
    TEXT("Task and thread priority for file loading."),
    ENamedThreads::HighThreadPriority,
    ENamedThreads::NormalTaskPriority,
    ENamedThreads::HighTaskPriority 
);

class FTask_LoadFileToString
{
    FTaskDelegate_FileLoaded TaskDelegate;
    FString FilePath;

    FString FileContent;
public:
    FTask_LoadFileToString(FString InFilePath, FTaskDelegate_FileLoaded InTaskDelegate) :
        TaskDelegate(InTaskDelegate), FilePath(MoveTemp(InFilePath))
    {}

    FORCEINLINE TStatId GetStatId() const
    {
        RETURN_QUICK_DECLARE_CYCLE_STAT(FTask_LoadFileToString, STATGROUP_TaskGraphTasks);
    }

    static ENamedThreads::Type GetDesiredThread() { return CPrio_LoadFileToString.Get(); }

    static ESubsequentsMode::Type GetSubsequentsMode() { return ESubsequentsMode::TrackSubsequents; }


    void DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)
    {
        // load file from Content folder
        FString FullPath = FPaths::Combine(FPaths::ProjectContentDir(), FilePath);
        if (FPaths::FileExists(FullPath))
        {
            FFileHelper::LoadFileToString(FileContent, *FullPath);
        }

        // create completion task
        FGraphEventRef ChildTask = TGraphTask<FTaskCompletion_LoadFileToString>::CreateTask(nullptr, CurrentThread).
            ConstructAndDispatchWhenReady(TaskDelegate, FileContent);
        MyCompletionGraphEvent->SetGatherThreadForDontCompleteUntil(ENamedThreads::GameThread);
        MyCompletionGraphEvent->DontCompleteUntil(ChildTask);
    }
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Sets default values
AFirstAsyncTask::AFirstAsyncTask()
{
}

void AFirstAsyncTask::AsyncLoadTextFile(const FString& FilePath)
{
    FTaskDelegate_FileLoaded TaskDelegate;
    TaskDelegate.BindUFunction(this, "OnFileLoaded");

    TGraphTask<FTask_LoadFileToString>::CreateTask(nullptr, ENamedThreads::GameThread).ConstructAndDispatchWhenReady(FilePath, TaskDelegate);
}
</code></pre>
</details>

<details>
<summary>虚幻4之TaskGraph: 实现Fork-Join模型</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/126316347
Fork-Join 模型简介
Fork-Join 是一种并行编程的设计模式，通过下面这个图片可以有一个直观的理解：


图片来自维基百科
在上图中，不同颜色的方块代表着可并行执行的“任务”，它们可以根据需要从主线程中“分叉(fork)”出来执行，在需要顺序执行的点上又“合并(join)”到主线程。

使用 TaskGraph 实现 Fork-Join 模型
虚幻4的 TaskGraph 可以为每个“任务”指定“一个或多个前置任务”，也就是组成所谓的 Graph 啦！在这种框架下，Fork-Join 也是一种常用的任务组织的手法。

下面我还是通过一个简单的例子，来看看具体的编程实现。

假定我们需要从一个 Json 格式的文本文件中读取过去 20 年的上证指数数据，然后需要统计出：

最大值，最小值，平均值
最后把这个三个值显示到一个 UMG 的界面上！

咋选了这么个古怪的例子呢？呃，本来是想做一个异步加载 N 个 Static Mesh 模型之类的例子，但是异步加载资源的话，其实用 FStreamableManager 更合适。为了避免误解，就想弄个简单计算的例子。
分拆任务
首先需要把上述需求分拆成多个小的任务，看看哪些可以并行执行：


看下面这个图可能更直观一点：


Task Context 对象
在正式开始编写任务之前，我们需要先解决数据在任务之间“传递”和“共享”的问题。

在这里，我打算使用一个 Context 对象存储所有数据，这种方式也是引擎中很多 TaskGraph 所使用的。

下面是一个任务数据的详细分析：


经过上面的分析之后，我设计了下面的数据结构，这个对象将在主线程和几个异步任务之间共享。结合前面那个图片中的执行序列分析，我决定：不用给Context对象加锁！

struct FStockAnalyzeContext
{
    bool bRunning = false;
    FString DataFilePath;
    FTaskDelegate_StockAnalyzeComplete CompletionDelegate;
    TArray<TSharedPtr<FJsonValue>> StockData;
    FVector Result; // {X:max, Y:min, Z:average}
};
那个 Json 对象，使用“TSharedPtr<FJsonObject, ESPMode::ThreadSafe> StockData”感觉更好一点，不过，引擎中的 JSON 序列化代码的参数写死了，只支持上面那个指针类型。我只能非常谨慎的编码，保证这些Json智能指针在访问的时候，不产生指针的复制。:( 如果你有更好的写法，请留言告诉我！
我们将在一个测试用的 Actor 对象里面存储一个 FStockAnalyzeContext 实例，然后在不同的 Task 之间共享它。

决定了这个 Context 数据结构之后，下面就是挨个实现每个 Task 了！

任务实现：异步加载 JSON
这个 Task 很简单，基本上就是把前一篇博客：基于任务的并行编程与TaskGraph 中的 FTask_LoadFileToString 稍加改造，在 DoTask() 中加上 Json 解析，并去掉派发子任务逻辑即可：

class FTask_LoadFileToJson
{
    FStockAnalyzeContext* Context;
public:
    FTask_LoadFileToJson(FStockAnalyzeContext* InContext) : Context(InContext)
    {}

    TStatId GetStatId() const {
        RETURN_QUICK_DECLARE_CYCLE_STAT(FTask_LoadFileToJson, STATGROUP_TaskGraphTasks);
    }

    static ENamedThreads::Type GetDesiredThread() { return CPrio_StockTasks.Get(); }
    static ESubsequentsMode::Type GetSubsequentsMode() { return ESubsequentsMode::TrackSubsequents; }

    void DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)
    {
        TSharedPtr<FJsonObject> JsonObject;

        // load file from Content folder
        FString FilePath = Context->DataFilePath;
        FString FileContent;
        FString FullPath = FPaths::Combine(FPaths::ProjectContentDir(), FilePath);
        if (FPaths::FileExists(FullPath))
        {
            if (FFileHelper::LoadFileToString(FileContent, *FullPath))
            {
                TSharedRef< TJsonReader<> > Reader = TJsonReaderFactory<>::Create(FileContent);
                FJsonSerializer::Deserialize(Reader, JsonObject);
            }
        }

        // write resut to context
        if (JsonObject)
            Context->StockData = JsonObject->GetArrayField(TEXT("stock"));
    }
};
为了代码简单，我没有做什么错误处理啊~
任务实现：数据统计计算
对“上证指数”求最大值、最小值、平均值，就是从 Context 中读取数据， 进行个简单的计算啦：

class FTask_StockMax
{
    FStockAnalyzeContext* Context;

public:
    FTask_StockMax(FStockAnalyzeContext* InContext) : Context(InContext)
    {}

    TStatId GetStatId() const {
        RETURN_QUICK_DECLARE_CYCLE_STAT(FTask_StockMax, STATGROUP_TaskGraphTasks);
    }

    static ENamedThreads::Type GetDesiredThread() { return CPrio_StockTasks.Get(); }
    static ESubsequentsMode::Type GetSubsequentsMode() { return ESubsequentsMode::TrackSubsequents; }

    void DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)
    {
        // process data 
        float Result = TNumericLimits<float>::Min();
        int32 Count = Context->GetStockDataCount();
        for (int32 i = 0; i < Count; i++)
        {
            float Value = Context->GetStockData(i);
            if (Value > Result)
                Result = Value;
        }

        // write resut to context
        Context->Result.X = Result;
    }
};
任务实现：完成通知
和前一篇博客一样：基于任务的并行编程与TaskGraph 我还是使用一个指定在 Game Thread 执行的 Task 来调用蓝图实现的事件：

class FTaskCompletion_StockAnalyze
{
    FStockAnalyzeContext* Context;
public:
    FTaskCompletion_StockAnalyze(FStockAnalyzeContext* InContext) : Context(InContext)
    {}

    FORCEINLINE TStatId GetStatId() const   {
        RETURN_QUICK_DECLARE_CYCLE_STAT(FTaskCompletion_StockAnalyze, STATGROUP_TaskGraphTasks);
    }

    static ENamedThreads::Type GetDesiredThread() { return ENamedThreads::GameThread; }
    static ESubsequentsMode::Type GetSubsequentsMode() { return ESubsequentsMode::TrackSubsequents; }

    void DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)
    {
        check(IsInGameThread());

        Context->CompletionDelegate.ExecuteIfBound(Context->Result);
        Context->bRunning = false;
    }
};
派发所有任务
重点来了！我们需要把任务的执行组织成下面这个图片所示：


这个重点就是使用：TGraphTask::CreateTask() 函数的第一个个参数。

void AForkJoinDemo::AsyncAnalyzeStockData(const FString& FilePath)
{
    if (TaskContext.bRunning)
        return;

    FTaskDelegate_StockAnalyzeComplete CompletionDelegate;
    CompletionDelegate.BindUFunction(this, "OnAnalyzeComplete");

    TaskContext = {};
    TaskContext.bRunning = true;
    TaskContext.CompletionDelegate = CompletionDelegate;
    TaskContext.DataFilePath = FilePath;

    FGraphEventRef LoadJson = TGraphTask<FTask_LoadFileToJson>::CreateTask().
        ConstructAndDispatchWhenReady(&TaskContext);

    // data process tasks
    FGraphEventArray RootTasks = { LoadJson };
    FGraphEventRef CalMax = TGraphTask<FTask_StockMax>::CreateTask(&RootTasks, ENamedThreads::AnyThread).
        ConstructAndDispatchWhenReady(&TaskContext);

    FGraphEventRef CalMin = TGraphTask<FTask_StockMin>::CreateTask(&RootTasks, ENamedThreads::AnyThread).
        ConstructAndDispatchWhenReady(&TaskContext);

    FGraphEventRef CalAverage = TGraphTask<FTask_StockAverage>::CreateTask(&RootTasks, ENamedThreads::AnyThread).
        ConstructAndDispatchWhenReady(&TaskContext);

    // compeletion
    FGraphEventArray CalTasks = { CalMax, CalMin, CalAverage };
    TGraphTask<FTaskCompletion_StockAnalyze>::CreateTask(&CalTasks, ENamedThreads::AnyThread).
        ConstructAndDispatchWhenReady(&TaskContext);

}
小结
通过指定任务的依赖关系，可以很方便的使用 TaskGraph 实现 Fork-Join 模型。

相关的样例工程在我的 GitHub ：

neil3d/UnrealCookBook
​github.com/neil3d/UnrealCookBook/tree/master/MakingUseOfTaskGraph

本文相关的 Demo 完整源代码也附上：

ForkJoinDemo.h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Dom/JsonObject.h" // Json
#include "Dom/JsonValue.h"  // Json
#include "ForkJoinDemo.generated.h"

DECLARE_DELEGATE_OneParam(FTaskDelegate_StockAnalyzeComplete, FVector);

struct FStockAnalyzeContext
{
    bool bRunning = false;
    FString DataFilePath;
    FTaskDelegate_StockAnalyzeComplete CompletionDelegate;

    TArray<TSharedPtr<FJsonValue>> StockData;
    FVector Result; // {X:max, Y:min, Z:average}

    int32 GetStockDataCount() const;
    float GetStockData(int32 Index) const;
};

UCLASS()
class MAKINGUSEOFTASKGRAPH_API AForkJoinDemo : public AActor
{
    GENERATED_BODY()

public: 
    // Sets default values for this actor's properties
    AForkJoinDemo();

    UFUNCTION(BlueprintCallable)
        void AsyncAnalyzeStockData(const FString& FilePath);

    UFUNCTION(BlueprintImplementableEvent)
        void OnAnalyzeComplete(FVector Result);

protected:
    FStockAnalyzeContext TaskContext;
};
ForkJoinDemo.cpp
FStockAnalyzeContext::GetStockData() 的效率有很大优化空间，这里请忽略，咱们是谈 TaskGraph 为主。
#include "ForkJoinDemo.h"
#include "Misc/Paths.h"
#include "Misc/FileHelper.h"
#include "Math/NumericLimits.h"
#include "Async/TaskGraphInterfaces.h"  // Core
#include "Serialization/JsonReader.h"   // Json
#include "Serialization/JsonSerializer.h" // Json

int32 FStockAnalyzeContext::GetStockDataCount() const
{
    return StockData.Num();
}

float FStockAnalyzeContext::GetStockData(int32 Index) const
{
    const TSharedPtr<FJsonValue>& Element = StockData[Index];
    const TSharedPtr<FJsonObject>& Stock = Element->AsObject();
    const TSharedPtr<FJsonValue>* FieldPtr = Stock->Values.Find(TEXT("close"));

    if (!FieldPtr)
        return 0.0f;

    const TSharedPtr<FJsonValue>& Field = *FieldPtr;

    check(Field && !Field->IsNull());
    return FCString::Atof(*(Field->AsString()));
}

FAutoConsoleTaskPriority CPrio_StockTasks(
    TEXT("TaskGraph.TaskPriorities.StockTasks"),
    TEXT("Task and thread priority for stock analyzation."),
    ENamedThreads::HighThreadPriority,
    ENamedThreads::NormalTaskPriority,
    ENamedThreads::HighTaskPriority
);

class FTaskCompletion_StockAnalyze
{
    FStockAnalyzeContext* Context;

public:
    FTaskCompletion_StockAnalyze(FStockAnalyzeContext* InContext) : Context(InContext)
    {}

    FORCEINLINE TStatId GetStatId() const
    {
        RETURN_QUICK_DECLARE_CYCLE_STAT(FTaskCompletion_StockAnalyze, STATGROUP_TaskGraphTasks);
    }

    static ENamedThreads::Type GetDesiredThread() { return ENamedThreads::GameThread; }

    static ESubsequentsMode::Type GetSubsequentsMode() { return ESubsequentsMode::TrackSubsequents; }

    void DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)
    {
        check(IsInGameThread());

        Context->CompletionDelegate.ExecuteIfBound(Context->Result);
        Context->bRunning = false;
    }
};

class FTask_StockMax
{
    FStockAnalyzeContext* Context;

public:
    FTask_StockMax(FStockAnalyzeContext* InContext) : Context(InContext)
    {}

    TStatId GetStatId() const {
        RETURN_QUICK_DECLARE_CYCLE_STAT(FTask_StockMax, STATGROUP_TaskGraphTasks);
    }

    static ENamedThreads::Type GetDesiredThread() { return CPrio_StockTasks.Get(); }
    static ESubsequentsMode::Type GetSubsequentsMode() { return ESubsequentsMode::TrackSubsequents; }

    void DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)
    {
        // process data 
        float Result = TNumericLimits<float>::Min();
        int32 Count = Context->GetStockDataCount();
        for (int32 i = 0; i < Count; i++)
        {
            float Value = Context->GetStockData(i);
            if (Value > Result)
                Result = Value;
        }

        // write resut to context
        Context->Result.X = Result;
    }
};


class FTask_StockMin
{
    FStockAnalyzeContext* Context;

public:
    FTask_StockMin(FStockAnalyzeContext* InContext) : Context(InContext)
    {}

    TStatId GetStatId() const {
        RETURN_QUICK_DECLARE_CYCLE_STAT(FTask_StockMin, STATGROUP_TaskGraphTasks);
    }

    static ENamedThreads::Type GetDesiredThread() { return CPrio_StockTasks.Get(); }
    static ESubsequentsMode::Type GetSubsequentsMode() { return ESubsequentsMode::TrackSubsequents; }

    void DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)
    {
        // process data 
        float Result = TNumericLimits<float>::Max();
        int32 Count = Context->GetStockDataCount();
        for (int32 i = 0; i < Count; i++)
        {
            float Value = Context->GetStockData(i);
            if (Value < Result)
                Result = Value;
        }

        // write resut to context
        Context->Result.Y = Result;
    }
};


class FTask_StockAverage
{
    FStockAnalyzeContext* Context;

public:
    FTask_StockAverage(FStockAnalyzeContext* InContext) : Context(InContext)
    {}

    TStatId GetStatId() const {
        RETURN_QUICK_DECLARE_CYCLE_STAT(FTask_StockAverage, STATGROUP_TaskGraphTasks);
    }

    static ENamedThreads::Type GetDesiredThread() { return CPrio_StockTasks.Get(); }
    static ESubsequentsMode::Type GetSubsequentsMode() { return ESubsequentsMode::TrackSubsequents; }

    void DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)
    {
        // process data 
        float Result = 0;
        int32 Count = Context->GetStockDataCount();
        for (int32 i = 0; i < Count; i++)
        {
            float Value = Context->GetStockData(i);
            Result += Value;
        }

        // write resut to context
        Context->Result.Z = Result / Count;
    }
};

class FTask_LoadFileToJson
{
    FStockAnalyzeContext* Context;

public:
    FTask_LoadFileToJson(FStockAnalyzeContext* InContext) : Context(InContext)
    {}

    TStatId GetStatId() const {
        RETURN_QUICK_DECLARE_CYCLE_STAT(FTask_LoadFileToJson, STATGROUP_TaskGraphTasks);
    }

    static ENamedThreads::Type GetDesiredThread() { return CPrio_StockTasks.Get(); }
    static ESubsequentsMode::Type GetSubsequentsMode() { return ESubsequentsMode::TrackSubsequents; }

    void DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)
    {
        TSharedPtr<FJsonObject> JsonObject;

        // load file from Content folder
        FString FilePath = Context->DataFilePath;
        FString FileContent;
        FString FullPath = FPaths::Combine(FPaths::ProjectContentDir(), FilePath);
        if (FPaths::FileExists(FullPath))
        {
            if (FFileHelper::LoadFileToString(FileContent, *FullPath))
            {
                TSharedRef< TJsonReader<> > Reader = TJsonReaderFactory<>::Create(FileContent);
                FJsonSerializer::Deserialize(Reader, JsonObject);
            }
        }

        // write resut to context
        if (JsonObject)
            Context->StockData = JsonObject->GetArrayField(TEXT("stock"));
    }
};

// Sets default values
AForkJoinDemo::AForkJoinDemo()
{
}

void AForkJoinDemo::AsyncAnalyzeStockData(const FString& FilePath)
{
    if (TaskContext.bRunning)
        return;

    FTaskDelegate_StockAnalyzeComplete CompletionDelegate;
    CompletionDelegate.BindUFunction(this, "OnAnalyzeComplete");

    TaskContext = {};
    TaskContext.bRunning = true;
    TaskContext.CompletionDelegate = CompletionDelegate;
    TaskContext.DataFilePath = FilePath;

    FGraphEventRef LoadJson = TGraphTask<FTask_LoadFileToJson>::CreateTask().
        ConstructAndDispatchWhenReady(&TaskContext);

    // data process tasks
    FGraphEventArray RootTasks = { LoadJson };
    FGraphEventRef CalMax = TGraphTask<FTask_StockMax>::CreateTask(&RootTasks, ENamedThreads::AnyThread).
        ConstructAndDispatchWhenReady(&TaskContext);

    FGraphEventRef CalMin = TGraphTask<FTask_StockMin>::CreateTask(&RootTasks, ENamedThreads::AnyThread).
        ConstructAndDispatchWhenReady(&TaskContext);

    FGraphEventRef CalAverage = TGraphTask<FTask_StockAverage>::CreateTask(&RootTasks, ENamedThreads::AnyThread).
        ConstructAndDispatchWhenReady(&TaskContext);

    // compeletion
    FGraphEventArray CalTasks = { CalMax, CalMin, CalAverage };
    TGraphTask<FTaskCompletion_StockAnalyze>::CreateTask(&CalTasks, ENamedThreads::AnyThread).
        ConstructAndDispatchWhenReady(&TaskContext);

}
延伸阅读
Wiki: Fork-Join
</code></pre>
</details>

<details>
<summary>虚幻4中的C++单元测试</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/158673691
也许是我太擅长写 BUG 吧，反正我一直认为“单元测试”非常之重要：

如果写了一段代码，不知道怎么测试，大多数情况下是有些东西没想清楚；
如果不进行单元测试，出 BUG 的概率是非常高的。
之前在标准C++的开发环境中，也用过类似 GOOGLE gtest 之类的 C++ 单元测试框架，而UE4的C++有点特别。不过，用不用测试框架并不是关键。关键在于：

测试代码要在软件完整生命周期中一直发挥作用，而不是测一下就丢弃了；
要很好的组织测试代码；
要很方便的批量执行，并有良好的测试结果输出；
话虽然这么说，但拥有一个好用的测试框架会方便很多。最近我就尝试了使用 UE4 内部提供的 Automation 自动化测试功能，值得推荐。

5分钟上手 Automation 测试框架
咱们先看一下疗效吧：


可以使用 C++ 编写测试用例；Automation 会列出来，展示到上面这个窗口中，支持多级分类；见上图的②部分；
通过点击工具栏按键“Start tests”，就可以运行选中的所有测试用例，见上图的①；
测试结果会输出到③区域，并且在右侧的进度条也有相应的统计；
OK，看上去还不错吧！所以，咱们就不用自己费力整合 gtest 之类的第三方测试框架了，UE4内部已经有了一个这么好的单元测试框架了。

下面就来看一下怎么用，总共也就分三步：

首先要开启相关的插件。通过编辑器菜单“Editor-->Plugins”打开这个插件窗口，选中“Testing”分类，开启相关的插件：

然后，就是写测试用例的代码了。可以给项目添加一个或多个 .cpp 文件，用来存放测试代码，文件样例如下：
#include "CoreTypes.h"
#include "Misc/AutomationTest.h"

#if WITH_DEV_AUTOMATION_TESTS

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FMySimpleTest, "UnrealCookbook.MySimpleTest",
                                 EAutomationTestFlags::ApplicationContextMask |
                                     EAutomationTestFlags::SmokeFilter)

bool FMySimpleTest::RunTest(const FString& Parameters) {
  TestEqual(TEXT("My first test case"), 2, 1 + 1);

  TestEqual(TEXT("My second test case"), 2, 2 + 1);
  return true;
}

#endif  // WITH_DEV_AUTOMATION_TESTS
简单说明一下：
需要 include 这个"Misc/AutomationTest.h"头文件；
我们使用了一个条件编译宏：WITH_DEV_AUTOMATION_TESTS ，这样在 shipping build 将不会包含这些代码；
使用了 IMPLEMENT_SIMPLE_AUTOMATION_TEST 来定义一个简单的单元测试类：
第一个参数是类名；这个类实际上是 FAutomationTestBase 的派生类，即: class FMySimpleTest: public FAutomationTestBase；
第二个参数是一个字符串，中间可以用点号分割；用来产生上面那个窗口中的分类，例如：UnrealCookbook.MySimpleTest
实现上面定义的这个类的 RunTest() 方法，在里面编写自己的一些测试用例，可以利用基类的 TestEqual() 等函数来进行结果验证。
完成了测试用例代码之后，编译项目，并启动编辑器。在编辑器的 Window 菜单中，就可以打开最开始那个窗口了：

如果有测试用例没有通过的话，可以打开 Message Log 窗口来查看详情，包括错误信息、测试用例的代码位置都有清晰的呈现：

另外，除了上述的 Test 族函数的测试之外，UE_LOG 产生 Error 级别以上的 log 的话，测试用例也同样会失败。
测试 Actor 派生类的 C++ 代码
上面这种 Simple Automation Test 测试纯逻辑、数据计算之类的代码很方便，但是我还有大量的代码是需要在关卡中测试的，也就是需要使用 Actor 的派生类来写单元测试，这个能支持吗？答案当时是：可以的！

可以看一下引擎中的“FunctionalTesting”这个模块（UE4/Source/Developer/FunctionalTesting），我们可以利用其中提供的基类：class AFunctionalTest : public AActor。

需要做这样几步：

创建一个 AFunctionalTest 的派生类
重载 PrepareTest()、StartTest()、FinishTest()等函数，来完成测试用例的开发；在测试用例中，可以调用基类的 Assert 相关函数验证测试结果；
需要手动创建一个测试关卡，并把这个测试 Actor 丢到场景中；
同样，在编辑器开启 Automation 窗口，这次点击工具栏的“Run Level Test”就可以进行测试了。

下面是一个简单的 Actor 单元测试样例代码：

#pragma once
#include "CoreMinimal.h"
#include "FunctionalTest.h"
#include "MyFunctionalTestActor.generated.h"

UCLASS()
class CPPUNITTEST_API AMyFunctionalTestActor : public AFunctionalTest {
  GENERATED_BODY()

 public:
  virtual void StartTest() override {
    AFunctionalTest::StartTest();

    AssertIsValid(this, TEXT("My first functional test"));
    AssertValue_Int(1 + 1, EComparisonMethod::Equal_To, 2,
                    TEXT("My 2nd functional test"));
    AssertValue_Int(1 + 1, EComparisonMethod::Not_Equal_To, 2,
                    TEXT("My 3rd functional test"));
  }
};
测试 Actor 派生类的蓝图代码
既然 C++ 的 Actor 代码能测试，那么蓝图呢？当然也可以啦。

创建一个 AFunctionalTest 的派生类；
在 Event Graph 中，实现响应基类提供的 Prepare Test 和 Start Test 事件相应即可；同样是调用 Assert 族函数对测试结果进行验证即可；

小结
Automation 测试框架还是挺好用的，推荐大家用起来；
Simple Test、Actor Test 的管理足够用了，没什么好抱怨的；
另外，引擎还提供了 Complex Test、截屏对比测试，有需要的话，可以看看官方文档；
这个博客相关的完整工程在我的 GitHub 上：

UnrealCookbook.CppUnitTest
​github.com/neil3d/UnrealCookbook/tree/master/CppUnitTest
延伸阅读
引擎中还有很多测试代码供参考：

官方文档：Automation System Overview
官方文档：Automation Technical Guide
官方文档：Framework for Functional Testing
Automated Testing at Scale in Sea of Thieves | Unreal Fest Europe 2019：https://www.youtube.com/watch?
</code></pre>
</details>