
<details>
<summary>介绍一些UE4的实用插件</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/35547847
（1）蓝图截图插件：ODIN Tracker

解决节点繁多的蓝图截图问题，一键搞定！


Welcome
​odintracker.io/

（2）路径插件 Path Follow

支持绘制多种路径，很好用


Path Follow by Cooper in Code Plugins
​www.unrealengine.com/marketplace/path-follow
（3）ARTv1

UE4官方的动画绑定插件，注意maya的插件


ARTv1 by Epic Games in Epic Showcase,Code Plugins
​www.unrealengine.com/marketplace/maya-tools
还有很多免费插件可以用，大家可以到官方商城下载
</code></pre>
</details>

<details>
<summary>UE4[C++]各字符串类型变量转换</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/37726745
最近的工作涉及大量UE4字符串的操作，于是整理了一下，如有疏漏的话欢迎大家留言指教。

FString 转 FName

FString MyString = "Hello";
FName ConvertedFString = FName(*MyString);
FString 转 TCHAR*

TCHAR MyTchar = *SourceFString;
FString 转 FText

FString Str = TEXT("str");  
FText Text = FText::FromString(Str);  
std::string 转 FString

std::string MyString = "Happy"; 
FString HappyString(MyString.c_str());
FString 转 std::string

FString MyString= "Bunny";
std::string MyStdString(TCHAR_TO_UTF8(*MyString));
FText 转 FString

FString Name = NameDesc->GetText().ToString();  
FText 转 FName

没有直接方法，先转换成FString，再转换成FName
FString 转 Integer

FString TheString = "1108.1110";
int32 MyStringtoInt = FCString::Atoi(*TheString);
FString 转 Float

FString TheString = "1108.1110";
float MyStringtoFloat = FCString::Atof(*TheString);
Float/Int 转 FString

FString NewString = FString::FromInt(YourInt);
 
FString VeryCleanString = FString::SanitizeFloat(YourFloat);
FName 转 FString

TestHUDString = TestHUDName.ToString();
FName 转 FText

TestHUDText = FText::FromName(TestHUDName);
如有补充，后续会继续更新。



部分引用来源：

String Handling
​docs.unrealengine.com/en-us/Programming/UnrealArchitecture/StringHandling
微博同知乎名，不定期发布UE4使用小技巧，欢迎关注。
</code></pre>
</details>

<details>
<summary>UE4[C++]获取ActionMapping</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/38843449
本文谈一谈UE4 C++ 的输入绑定的方法，如有疏漏欢迎大家留言指教。

input.h

private:
	UInputComponent* InputComponent = nullptr;
	
	void InputEvent();
input.cpp


void UInput::BeginPlay()
{
	Super::BeginPlay();

	//获取输入组件
	InputComponent = GetOwner()->FindComponentByClass<UInputComponent>();


       //绑定事件
	if(InputComponent){
		InputComponent->BindAction("Kiss", IE_Pressed, this, &UInput::InputEvent);
	}
	// ...
	
}

void UInput::InputEvent()
{
	UE_LOG(LogTemp, Warning, TEXT("Kiss lovely bunny!"))
}
另一种方法可以重写继承自APawn类的SetPlayerInputComponent函数，具体实现方法在UE4的ThirdPersonTemplate（c++）ProjectNameCharacter.cpp中可以看到，在此不再赘述。
</code></pre>
</details>

<details>
<summary>[UE4基础]如何打开低版本项目</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/41711636
当我们使用高版本引擎打开低版本项目的的时候，会弹出如下对话框。


选择Open a copy，可创建一个项目副本


也可以选择More Options



选择Convert in-place，可以直接将项目提升至当前引擎版本
</code></pre>
</details>

<details>
<summary>UE4[C++]使用C++做特效——黑洞</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/41709219
本次给大家的是如何使用在UE4中使用C++制作黑洞特效。

新建项目，添加C++类BlackHole，这里设置为公开访问


创建，编译。

代码：

BlackHole.h

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "BlackHole.generated.h"

class USphereComponent;
class UStaticMeshComponent;

UCLASS()
class ARPG_API ABlackHole : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	ABlackHole();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

	UPROPERTY(VisibleAnywhere, Category = "Components")
		UStaticMeshComponent* MeshComp;

	/*物体碰到黑洞表面会被销毁*/
	UPROPERTY(VisibleAnywhere, Category = "Components")
		USphereComponent* InnerSphereComponent;

	/*黑洞的作用范围*/
	UPROPERTY(VisibleAnywhere, Category = "Components")
		USphereComponent* OuterSphereComponent;

	/*重叠事件*/
	UFUNCTION()
		void OverlapInnerSphere(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

	
	
};
BlackHole.cpp

#include "../Public/BlackHole.h"
#include "Components/SphereComponent.h"
#include "Components/StaticMeshComponent.h"


ABlackHole::ABlackHole()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	MeshComp = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("MeshComp"));
	//取消黑洞Mesh的碰撞，使黑洞可以吸入物体
	MeshComp->SetCollisionEnabled(ECollisionEnabled::NoCollision);
	RootComponent = MeshComp;

	InnerSphereComponent = CreateDefaultSubobject<USphereComponent>(TEXT("InnerSphereComp"));
	InnerSphereComponent->SetSphereRadius(100);
	InnerSphereComponent->SetupAttachment(MeshComp);

	//绑定重叠事件，使吸入的物体被销毁
	InnerSphereComponent->OnComponentBeginOverlap.AddDynamic(this, &ABlackHole::OverlapInnerSphere);

	OuterSphereComponent = CreateDefaultSubobject<USphereComponent>(TEXT("OuterSphereComp"));
	OuterSphereComponent->SetSphereRadius(3000);
	OuterSphereComponent->SetupAttachment(MeshComp);
}

// Called when the game starts or when spawned
void ABlackHole::BeginPlay()
{
	Super::BeginPlay();
	
}

void ABlackHole::OverlapInnerSphere(UPrimitiveComponent * OverlappedComponent, AActor * OtherActor, UPrimitiveComponent * OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)
{
	if (OtherActor)
	{
		OtherActor->Destroy();
	}
}

// Called every frame
void ABlackHole::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
	// Find all overlapping components that can collide and may be physically simulating.
	TArray<UPrimitiveComponent*> OverlappingComps;
	OuterSphereComponent->GetOverlappingComponents(OverlappingComps);

	for (int32 i = 0; i < OverlappingComps.Num(); i++)
	{
		UPrimitiveComponent* PrimComp = OverlappingComps[i];
		//检查是否模拟物理
		if (PrimComp && PrimComp->IsSimulatingPhysics())
		{
			// the component we are looking for! It needs to be simulating in order to apply forces.

			const float SphereRadius = OuterSphereComponent->GetScaledSphereRadius();
			const float ForceStrength = -2000; // Negative value to make it pull towards the origin instead of pushing away

			//添加径向力
			PrimComp->AddRadialForce(GetActorLocation(), SphereRadius, ForceStrength, ERadialImpulseFalloff::RIF_Constant, true);
		}
	}
}
之后编译，使用该类新建一个蓝图


给StaticMesh选一个模型后，编译放进场景里。

最终效果：





完成！
</code></pre>
</details>

<details>
<summary>UE4[C++]IK(逆向运动学)的实现方法</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/42140318
首先给出FK和IK的概念：

FK（Forward kinematics）正向运动学，通俗来说是给定父骨骼位置以及它的变换来得出子骨骼的位置以及变换。

IK（Inverse kinematics）逆向运动学，IK和FK恰好相反，即给出子骨骼位置，从而逆向推出骨骼节点链上父级节点的位置。

举个例子：

手臂的旋转属于FK的变换，而使用手去触碰物体导致的手臂及躯干的移动属于IK的变换。

本文中，IK的实现通过C++代码和动画蓝图实现。

代码部分：

（1）继承UAnimInstance类，新建UIKAnimInstance类。

这里声明的变量用于数据更新

UIKAnimInstance.h

// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimInstance.h"
#include "IKAnimInstance.generated.h"

/**
 * 
 */
UCLASS(transient, Blueprintable, hideCategories = AnimInstance, BlueprintType)
class IKSYSTEM_API UIKAnimInstance : public UAnimInstance
{
	GENERATED_BODY()
	
public:
	UPROPERTY(EditAnywhere,BlueprintReadWrite)
		FVector  LeftJointLoc = FVector(-15.97f, 1000.0f, -15.97f);
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		FVector  RightJointLoc = FVector(-16.8f, 26.9, 15.97f);
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		float LeftEffectorLoc = 0.0f;
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		float RightEffectorLoc = 0.0f;
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		float HipsOffset = 0.0f;
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		FRotator LeftFootRotation = FRotator(0.f,0.f,0.f);
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		FRotator RightFootRotation = FRotator(0.f, 0.f, 0.f);
	UIKAnimInstance(const FObjectInitializer& ObjectInitializer);
};
（2）继承Character类，新建类AIKCharacter

AIKCharacter.h

// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "Engine/SkeletalMeshSocket.h"
#include "Components/SkeletalMeshComponent.h"
#include "Kismet/KismetMathLibrary.h"
#include "Kismet/KismetSystemLibrary.h"
#include "IKAnimInstance.h"
#include "IKCharacter.generated.h"

UCLASS(config=Game)
class AIKCharacter : public ACharacter
{
	GENERATED_BODY()

	/** Camera boom positioning the camera behind the character */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
	class USpringArmComponent* CameraBoom;

	/** Follow camera */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
	class UCameraComponent* FollowCamera;
public:
	AIKCharacter();

	virtual void Tick(float DeltaSeconds) override;

	/** Base turn rate, in deg/sec. Other scaling may affect final turn rate. */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=Camera)
	float BaseTurnRate;

	/** Base look up/down rate, in deg/sec. Other scaling may affect final rate. */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=Camera)
	float BaseLookUpRate;

	float IKCapsuleHalfHeight = 0.f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = IK)
		float IKTraceDistance = 55.0f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = IK)
		float IKAdjustOffset = 2.0f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = IK)
		FName LeftFootSocket = "LeftFootSocket";

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = IK)
		FName RightFootSocket = "RightFootSocket";

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = IK)
		float IKHIspsInterpSpeed = 7.0f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = IK)
		float IKFeetInterpSpeed = 13.0f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = IK)
		float IKTimeout = 0.2f;

	UIKAnimInstance* AnimInstance ;

	FVector Impact = FVector(0.f, 0.f, 0.f);

	float Scale = 0.0f;
protected:
	/** Called for forwards/backward input */
	void MoveForward(float Value);

	/** Called for side to side input */
	void MoveRight(float Value);

	/** 
	 * Called via input to turn at a given rate. 
	 * @param Rate	This is a normalized rate, i.e. 1.0 means 100% of desired turn rate
	 */
	void TurnAtRate(float Rate);

	/**
	 * Called via input to turn look up/down at a given rate. 
	 * @param Rate	This is a normalized rate, i.e. 1.0 means 100% of desired turn rate
	 */
	void LookUpAtRate(float Rate);

	/** Handler for when a touch input begins. */
	void TouchStarted(ETouchIndex::Type FingerIndex, FVector Location);

	/** Handler for when a touch input stops. */
	void TouchStopped(ETouchIndex::Type FingerIndex, FVector Location);

	float IKFootTrace(float TraceDistance, FName SocketName);

	void UpdateCapsuleHalfHeight(float HipShifts, bool ResetDefault);

	UFUNCTION(BlueprintCallable,BlueprintPure,category="IK")
	FRotator NormalToRotator(FVector Normal);

	void IKUpdateFootOffset(float TargetValue, float &EffectorVal, float InterpSpeed);

	void IKUpdateFootRotation(FRotator TargetValue, FRotator &RotationVar, float InterpSpeed);

	void IKResetVars();

	bool IsMoving();

	UFUNCTION(BlueprintCallable, category = "IK")
	void IKUpdate(bool bEnable);

	USkeletalMeshComponent* Mesh = nullptr;
protected:
	// APawn interface
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;
	// End of APawn interface

public:
	/** Returns CameraBoom subobject **/
	FORCEINLINE class USpringArmComponent* GetCameraBoom() const { return CameraBoom; }
	/** Returns FollowCamera subobject **/
	FORCEINLINE class UCameraComponent* GetFollowCamera() const { return FollowCamera; }
};

AIKCharacter.cpp

// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.

#include "IKCharacter.h"
#include "HeadMountedDisplayFunctionLibrary.h"
#include "Camera/CameraComponent.h"
#include "Components/CapsuleComponent.h"
#include "Components/InputComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "GameFramework/Controller.h"
#include "DrawDebugHelpers.h"
#include "Components/SceneComponent.h"
#include "Components/ArrowComponent.h"
#include "GameFramework/SpringArmComponent.h"

//////////////////////////////////////////////////////////////////////////
// AIKCharacter



AIKCharacter::AIKCharacter()
{
	// Set size for collision capsule
	GetCapsuleComponent()->InitCapsuleSize(42.f, 96.0f);

	// set our turn rates for input
	BaseTurnRate = 45.f;
	BaseLookUpRate = 45.f;

	// Don't rotate when the controller rotates. Let that just affect the camera.
	bUseControllerRotationPitch = false;
	bUseControllerRotationYaw = false;
	bUseControllerRotationRoll = false;

	// Configure character movement
	GetCharacterMovement()->bOrientRotationToMovement = true; // Character moves in the direction of input...	
	GetCharacterMovement()->RotationRate = FRotator(0.0f, 540.0f, 0.0f); // ...at this rotation rate
	GetCharacterMovement()->JumpZVelocity = 600.f;
	GetCharacterMovement()->AirControl = 0.2f;

	// Create a camera boom (pulls in towards the player if there is a collision)
	CameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT("CameraBoom"));
	CameraBoom->SetupAttachment(RootComponent);
	CameraBoom->TargetArmLength = 300.0f; // The camera follows at this distance behind the character	
	CameraBoom->bUsePawnControlRotation = true; // Rotate the arm based on the controller

	// Create a follow camera
	FollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT("FollowCamera"));
	FollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName); // Attach the camera to the end of the boom and let the boom adjust to match the controller orientation
	FollowCamera->bUsePawnControlRotation = false; // Camera does not rotate relative to arm

	// Note: The skeletal mesh and anim blueprint references on the Mesh component (inherited from Character) 
	// are set in the derived blueprint asset named MyCharacter (to avoid direct content references in C++)

	//Get Capsule Half height
	IKCapsuleHalfHeight = GetCapsuleComponent()->GetScaledCapsuleHalfHeight();

	Mesh = GetMesh();
	if (!Mesh)
		return;
	PrimaryActorTick.bCanEverTick = true;
	PrimaryActorTick.bStartWithTickEnabled = true;
	
	Scale = GetActorScale().Z;
	
}

void AIKCharacter::Tick(float DeltaSeconds)
{
	/*if (Mesh->GetAnimInstance() == nullptr)
	{
		UE_LOG(LogTemp, Warning, TEXT("Get AnimInstance Failed!"));
		return;
	}*/
	AnimInstance = Cast<UIKAnimInstance>(Mesh->GetAnimInstance());
	if (AnimInstance == nullptr)
	{
		UE_LOG(LogTemp, Warning, TEXT("Tick Misssing AnimInstance!"));
		return;
	}

	IKUpdate(true);
}

//////////////////////////////////////////////////////////////////////////
// Input

void AIKCharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent)
{
	// Set up gameplay key bindings
	check(PlayerInputComponent);
	PlayerInputComponent->BindAction("Jump", IE_Pressed, this, &ACharacter::Jump);
	PlayerInputComponent->BindAction("Jump", IE_Released, this, &ACharacter::StopJumping);

	PlayerInputComponent->BindAxis("MoveForward", this, &AIKCharacter::MoveForward);
	PlayerInputComponent->BindAxis("MoveRight", this, &AIKCharacter::MoveRight);

	// We have 2 versions of the rotation bindings to handle different kinds of devices differently
	// "turn" handles devices that provide an absolute delta, such as a mouse.
	// "turnrate" is for devices that we choose to treat as a rate of change, such as an analog joystick
	PlayerInputComponent->BindAxis("Turn", this, &APawn::AddControllerYawInput);
	PlayerInputComponent->BindAxis("TurnRate", this, &AIKCharacter::TurnAtRate);
	PlayerInputComponent->BindAxis("LookUp", this, &APawn::AddControllerPitchInput);
	PlayerInputComponent->BindAxis("LookUpRate", this, &AIKCharacter::LookUpAtRate);

	// handle touch devices
	PlayerInputComponent->BindTouch(IE_Pressed, this, &AIKCharacter::TouchStarted);
	PlayerInputComponent->BindTouch(IE_Released, this, &AIKCharacter::TouchStopped);

}




void AIKCharacter::TouchStarted(ETouchIndex::Type FingerIndex, FVector Location)
{
		Jump();
}

void AIKCharacter::TouchStopped(ETouchIndex::Type FingerIndex, FVector Location)
{
		StopJumping();
}

float AIKCharacter::IKFootTrace(float TraceDistance, FName SocketName)
{
	bool ValidHit = false;
	FHitResult OutHit;
	float Offset = 0.f;
	FVector SocketVec = Mesh->GetSocketLocation(SocketName);
	FVector ActorVec = GetActorLocation();
	FVector StartVec = FVector(SocketVec.X, SocketVec.Y, ActorVec.Z);
	FVector EndVec = FVector(SocketVec.X, SocketVec.Y, ActorVec.Z - IKCapsuleHalfHeight - TraceDistance);

	
	FCollisionQueryParams RV_TraceParams = FCollisionQueryParams(FName(TEXT("RV_Trace")), true, this);
	RV_TraceParams.bTraceComplex = true;
	RV_TraceParams.bTraceAsyncScene = true;
	RV_TraceParams.bReturnPhysicalMaterial = false;

	ValidHit = UKismetSystemLibrary::LineTraceSingle(
		GetWorld(),
		StartVec,
		EndVec,
		ETraceTypeQuery::TraceTypeQuery1,
		true,
		TArray<AActor*>(),
		EDrawDebugTrace::None,
		OutHit,
		true,
		FLinearColor::Yellow
	);
	if (ValidHit)
	{
		FVector HitVector = OutHit.Location - OutHit.TraceEnd;

		//UKismetSystemLibrary::PrintString(GetWorld(), HitVector.ToString());

		Offset = IKAdjustOffset + HitVector.Size() - TraceDistance;
		Offset = UKismetMathLibrary::SelectFloat(Offset, 0.f, ValidHit);		
	}

	Impact = OutHit.Normal;
	return Offset;
}

void AIKCharacter::UpdateCapsuleHalfHeight(float HipShifts, bool ResetDefault)
{
	float fShift = IKCapsuleHalfHeight - (FMath::Abs(HipShifts) / 2);
	float fTarget = UKismetMathLibrary::SelectFloat(IKCapsuleHalfHeight, fShift, ResetDefault);
	float finterp = FMath::FInterpTo(
		IKCapsuleHalfHeight,
		fTarget,
		GetWorld()->GetDeltaSeconds(),
		IKHIspsInterpSpeed
	);
	GetCapsuleComponent()->SetCapsuleHalfHeight(finterp, true);

}

FRotator AIKCharacter::NormalToRotator(FVector Normal)
{

	float XRoll =FMath::RadiansToDegrees(FMath::Atan2(Normal.Y, Normal.Z));
	float YPitch = FMath::RadiansToDegrees(FMath::Atan2(Normal.X, Normal.Z) * (-1));
	FRotator Rot = FRotator(YPitch, 0.f, XRoll);
	UE_LOG(LogTemp, Warning, TEXT("%f , %f , %f"), &Rot.Roll, &Rot.Pitch, &Rot.Yaw);
	return Rot;
}

void AIKCharacter::IKUpdateFootOffset(float TargetValue, float &EffectorVal, float InterpSpeed)
{
	float fInterp = FMath::FInterpTo(EffectorVal, TargetValue, GetWorld()->GetDeltaSeconds(), InterpSpeed);
	EffectorVal = fInterp;
}

void AIKCharacter::IKUpdateFootRotation(FRotator TargetValue, FRotator &RotationVar, float InterpSpeed)
{
	FRotator rInterp = FMath::RInterpTo(RotationVar, TargetValue, GetWorld()->GetDeltaSeconds(), InterpSpeed);
	RotationVar = rInterp;
}

void AIKCharacter::IKResetVars()
{
	/*Reset Foot Loction*/
	IKUpdateFootOffset(0.0f, AnimInstance->RightEffectorLoc, IKFeetInterpSpeed);
	IKUpdateFootOffset(0.0f, AnimInstance->LeftEffectorLoc, IKFeetInterpSpeed);
	/*Reset Foot Rotation*/
	IKUpdateFootRotation(FRotator(0.f, 0.f, 0.f), AnimInstance->RightFootRotation, IKFeetInterpSpeed);
	IKUpdateFootRotation(FRotator(0.f, 0.f, 0.f), AnimInstance->LeftFootRotation, IKFeetInterpSpeed);
	/*Reste Hips Loction*/
	IKUpdateFootOffset(0.0f, AnimInstance->HipsOffset, IKHIspsInterpSpeed);
	UpdateCapsuleHalfHeight(0.0f, true);
}

bool AIKCharacter::IsMoving()
{
	if (GetVelocity().Size() > 0)
		return true;
	return false;
}

void AIKCharacter::IKUpdate(bool bEnable)
{
	if (bEnable == false)
	{
		return;
	}
	if (AnimInstance == nullptr)
	{
		UE_LOG(LogTemp, Warning, TEXT("IKUpdate Misssing AnimInstance!"));
		return;
	}
	/*Trace Foot offset*/
	float LeftFootOffset = IKFootTrace(IKTraceDistance, LeftFootSocket);
	FRotator Normal = NormalToRotator(Impact);
	IKUpdateFootRotation(Normal, AnimInstance->LeftFootRotation, IKFeetInterpSpeed);
	//UKismetSystemLibrary::PrintString(GetWorld(),FString::Printf(TEXT("Rotation is %f ,%f ,%f"),GetActorRotation().Pitch , GetActorRotation().Roll, GetActorRotation().Yaw), 4.0f);
	float RightFootOffset = IKFootTrace(IKTraceDistance, RightFootSocket);
	Normal = NormalToRotator(Impact);
	IKUpdateFootRotation(Normal, AnimInstance->RightFootRotation, IKFeetInterpSpeed);

	/*Update Hip translation*/
	bool pickA = FMath::Min(LeftFootOffset, RightFootOffset) < 0;
	float HipOffset = UKismetMathLibrary::SelectFloat(FMath::Min(LeftFootOffset, RightFootOffset), 0.f, pickA);
	IKUpdateFootOffset(HipOffset, AnimInstance->HipsOffset, IKHIspsInterpSpeed);
	UpdateCapsuleHalfHeight(HipOffset, false);

	/*Update Foot Locations*/
	IKUpdateFootOffset(LeftFootOffset - HipOffset , AnimInstance->LeftEffectorLoc, IKFeetInterpSpeed);
	IKUpdateFootOffset(RightFootOffset - HipOffset, AnimInstance->RightEffectorLoc, IKFeetInterpSpeed);

}

void AIKCharacter::TurnAtRate(float Rate)
{
	// calculate delta for this frame from the rate information
	AddControllerYawInput(Rate * BaseTurnRate * GetWorld()->GetDeltaSeconds());
}

void AIKCharacter::LookUpAtRate(float Rate)
{
	// calculate delta for this frame from the rate information
	AddControllerPitchInput(Rate * BaseLookUpRate * GetWorld()->GetDeltaSeconds());
}

void AIKCharacter::MoveForward(float Value)
{
	if ((Controller != NULL) && (Value != 0.0f))
	{
		// find out which way is forward
		const FRotator Rotation = Controller->GetControlRotation();
		const FRotator YawRotation(0, Rotation.Yaw, 0);

		// get forward vector
		const FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
		AddMovementInput(Direction, Value);
	}
}

void AIKCharacter::MoveRight(float Value)
{
	if ( (Controller != NULL) && (Value != 0.0f) )
	{
		// find out which way is right
		const FRotator Rotation = Controller->GetControlRotation();
		const FRotator YawRotation(0, Rotation.Yaw, 0);
	
		// get right vector 
		const FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);
		// add movement in that direction
		AddMovementInput(Direction, Value);
	}
}
蓝图部分：

本示例中使用的是官方的第三人称模板。

编译代码，将模板中的蓝图ThirdPersonCharacter的基类选择刚才编译的AIKCharacter。


打开ThirdPersonCharacter使用的动画蓝图ThirdPerson_AnimBP，将基类改为UIKAnimInstance。


Event Graph 中，使用模板中的蓝图


Anim Graph中，使用连接如下节点


Transform Modify节点如下配置



Two Bone IK 节点：


最后把Cached Pose连接至最终Pose


大功告成！
</code></pre>
</details>

<details>
<summary>UE4[C++]使用Timer定时器</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/43332146
这次我们使用Ｃ++计时器写一个定时爆炸的地雷。

在UE4蓝图中，我们可以使用KismetSystemLibrary中的Delay函数来设置下一节点的延迟。

而我们在UE4C++项目中，可以使用Timer定时器来实现同样的效果。

UE4的定时器——FTimerManager

（1）SetTimer 用于创建定时器，以设定间隔调用特定的本地函数

template<class UserClass>
void SetTimer
(
    FTimerHandle & InOutHandle,
    UserClass * InObj,
    typename FTimerDelegate::TUObjectMethodDelegate_Const< UserClass >::FMethodPtr InTimerMethod,
    float InRate,
    bool InbLoop,
    float InFirstDelay
)
实际应用中可如下使用：

World->GetTimerManager().SetTimer(TimerHandle,Callback,Rate,bLoop,FirstDelay);

TimerHandle 管理Timer的Handle

Callback 要调用的函数

Rate 调用该函数的秒数

bLoop 是否循环

FirstDelay 要持续多久

（2）ClearTimer 可清理之前设置的定时器，使其不再执行。

void ClearTimer
(
    FTimerHandle & InHandle
)
具体功能实现上，思路如下

首先，我们新建一个AdvanceTimer函数用于定时

void ATimerItem::AdvanceTimer()
{
	--CountdownTime;
	UpdateTimerDisplay();
	if (CountdownTime < 1)
	{
		//We're done counting down, so stop running the timer.
		OnExplode();
		GetWorldTimerManager().ClearTimer(CountdownTimerHandle);
		CountdownText->SetText(TEXT("BOOOOM!"));
	}
}
更新地雷倒计时函数UpdateTimerDisplay

void ATimerItem::UpdateTimerDisplay()
{
	CountdownText->SetText(FString::FromInt(FMath::Max(CountdownTime, 0)));
}
地雷爆炸的函数OnExplode

void ATimerItem::OnExplode()
{
	UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), p_explosion, GetActorTransform());

	TArray<FHitResult> OutHits;

	FVector MyLocation = GetActorLocation();

	FCollisionShape MyColSphere = FCollisionShape::MakeSphere(500.f);

	DrawDebugSphere(GetWorld(), MyLocation, MyColSphere.GetSphereRadius(), 50, FColor::Red, true);

	bool bIsHit = GetWorld()->SweepMultiByChannel(OutHits, MyLocation, 
		MyLocation, FQuat::Identity,ECC_WorldStatic, MyColSphere);

	if (bIsHit)
	{
		for (auto& Hit : OutHits)
		{
			UPrimitiveComponent* MeshComp = Cast<UPrimitiveComponent>(Hit.GetActor()->GetRootComponent());

			if (MeshComp == nullptr)
			{
				return;
			}
			if (MeshComp->Mobility == EComponentMobility::Movable)
			{
				if (MeshComp->IsSimulatingPhysics())
				{
					MeshComp->AddRadialImpulse(MyLocation, 500.f, 2000.f, ERadialImpulseFalloff::RIF_Constant, true);
				}
				else
				{
					UE_LOG(LogTemp, Warning, TEXT("Simulate physics!"));
					MeshComp->SetSimulatePhysics(true);
					MeshComp->AddRadialImpulse(MyLocation, 500.f, 2000.f, ERadialImpulseFalloff::RIF_Constant, true);
				}
			}
		}
	}
	Destroy();
}
BeginPlay函数

// Called when the game starts or when spawned
void ATimerItem::BeginPlay()
{
	Super::BeginPlay();
	
	UpdateTimerDisplay();
	GetWorldTimerManager().SetTimer(CountdownTimerHandle, this, &ATimerItem::AdvanceTimer, 1.0f, true);
}
构造函数

ATimerItem::ATimerItem()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = false;

	CountdownText = CreateDefaultSubobject<UTextRenderComponent>(TEXT("CountdownNumber"));
	CountdownText->SetHorizontalAlignment(EHTA_Center);
	CountdownText->SetWorldSize(150.0f);
	CountdownText->AttachTo(RootComponent);
	CountdownTime = 3;
}
头文件

// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "TimerItem.generated.h"

class UTextRenderComponent;

UCLASS()
class SCP_API ATimerItem : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	ATimerItem();

	FTimerHandle TimerHandle;

	UTextRenderComponent* CountdownText;

	UPROPERTY(BlueprintReadWrite)
	bool bUseCountdownText;

	int32 CountdownTime;

	/*-------Countdown Timer--------------*/
	void UpdateTimerDisplay();

	void AdvanceTimer();

	/*Countdown Timer handle */
	FTimerHandle CountdownTimerHandle;

	UFUNCTION()
	void OnExplode();

	UFUNCTION(BlueprintCallable)
	void OnUsed();

	UPROPERTY(EditAnywhere)
	float DelayTime = 3.f;

	UPROPERTY(EditAnywhere)
	UParticleSystem* p_explosion;
protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;
public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;		
};
</code></pre>
</details>

<details>
<summary>UE4[蓝图]蝙蝠侠探照灯效果的制作</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/45682461
昨天看了B站一个介绍蝙蝠侠的视频，突发奇想做了一个蝙蝠侠探照灯。

那么，教程来了！

首先在场景中加入一个Spot Light，找到Light Function属性。


这里需要一个材质,新建材质 M_Light_batman

材质属性如下：


导入素材图片


在材质中连接引线


Apply、保存，把刚才的材质加在Light Function中


构造光线、大功告成！
</code></pre>
</details>

<details>
<summary>UE4[BP/C++]使用PS4手柄玩虚幻</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/48215107
最近研究了一下如何用PS4手柄控制来游戏的操作。

需要准备的：

（1）PS4手柄一个

（2）MicroUSB连接线或者PS4手柄蓝牙连接器

（3）PS4手柄驱动

一、驱动PS4手柄

驱动下载地址：Ryochan7/DS4Windows

下载完成后，解压压缩包

找到DS4Windows.exe，双击启动


使用有线或者蓝牙将手柄和电脑连接，这里本人使用的是有线连接。


如果Controller这里显示了手柄的ID，那么证明已经连接成功了。

如果没有，请到控制面板\硬件和声音\设备和打印机寻找设备是否显示。


二、按键映射

UE4中提供了如下按键

Gamepad_LeftX
Gamepad_LeftY
Gamepad_RightX
Gamepad_RightY
Gamepad_LeftTriggerAxis
Gamepad_RightTriggerAxis
Gamepad_LeftThumbstick
Gamepad_RightThumbstick
Gamepad_Special_Left——Share键
Gamepad_Special_Right——Options键
手柄正面按键

Gamepad_FaceButton_Bottom——×键
Gamepad_FaceButton_Right——○键
Gamepad_FaceButton_Left——□键
Gamepad_FaceButton_Top——△键
手柄侧面按键

Gamepad_LeftShoulder——L1键
Gamepad_RightShoulder——R1键
Gamepad_LeftTrigger——L2键
Gamepad_RightTrigger——R2键
十字键

Gamepad_DPad_Up
Gamepad_DPad_Down
Gamepad_DPad_Right
Gamepad_DPad_Left

摇杆方向

Gamepad_LeftStick_Up
Gamepad_LeftStick_Down
Gamepad_LeftStick_Right
Gamepad_LeftStick_Left
Gamepad_RightStick_Up
Gamepad_RightStick_Down
Gamepad_RightStick_Right
Gamepad_RightStick_Left
Gamepad_LeftThumbstick_Button——L3键
Gamepad_RightThumbstick_Button——R3键
PS：以上是官方提供的通用手柄绑定事件

PS2：像PS键、触控板键等事件的绑定可能是在索尼的PS SDK中，需要额外进行定制



三、Project Settings

我按照目前主流FPS游戏的按键分配简单的配置了一下，可以作为参考：


在蓝图中同样可以进行配置：


按键绑定事件的具体流程在本篇中不再赘述了，如果需要教程的话，请在评论区留言。

参考资料：

[1] List of Key/Gamepad Input Names
</code></pre>
</details>

<details>
<summary>UE4[C++]使用引擎插件</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/49558324
在UE4C++开发过程中，可能会遇到使用UE4引擎插件的情况。

直接包含插件头文件是不行的，一下是具体流程。

一、打开项目的Bulid.cs文件，在DependencyModuleNames中，填入要使用的插件名称

	public YourGame(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
	
		PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore",
             "FacialAnimation" });
二、关闭引擎编辑器，在项目的uproject文件右键，选择Generate Visual Studio Project Files，引擎会发现新引入的模块。

之后重新载入sln文件，此时引用插件的头文件时，可以正常编译。

觉得有帮助的朋友们，Please——
</code></pre>
</details>

<details>
<summary>UE4[蓝图]下雪效果及雪的材质的实现</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/51038902
已经进入冬季了可是迟迟不下雪，那么只好在虚幻引擎中实现了。

事前准备：

1、一张雪花贴图


网上找的雪花贴图
2、新建一个材质 M_Snow

（1）将材质结果节点的Blend_Mode设置为Translucent

（2）之后按照下图所示连接节点：


因为这张贴图通道有点问题，所以只用到了Alpha通道。

（3）为了体现雪花下落的过程，这里用到了粒子动态模糊效果。


3、新建粒子系统P_Snow

（1）添加如下节点：


（2）Emitter节点处右键TypeData（类型数据）

选择New GPU Sprites。

这样做的好处是，使用GPU处理计算，可以同时处理数千个粒子，从而展现更丰富的粒子。

（3）Required中，选择刚才我们创建的材质 M_Snow

（4）Spawn中，设置生成数量


（5）LifeTime设置粒子存活时间


（6）InitialSize设置粒子大小


（7）InitialVelocity设置初始速度


（8）InitialLocation设置初始位置


（9）InitialRotation给雪花设置一个旋转量，让它可以看起来自然旋转下落

（10）Collision设置粒子的碰撞，这里粒子碰撞后使用Kill销毁。


（11）复制一个雪花粒子，调整不同的参数，让我们的雪花更有层次感。


最终效果：
</code></pre>
</details>

<details>
<summary>UE4[蓝图]动态积雪材质的实现（一）</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/51150141
续上篇文章《UE4[蓝图]下雪效果及雪的材质的实现》，本篇继续制作积雪效果。

主要应用的两个材质分两篇来写，一个是物体上的积雪，另一个是地面上的积雪。

最终效果：

第一部分：地面上积雪材质的实现

（1）新建一个材质M_Snow_Gather，本教程使用的贴图是引擎自带的StarterContent下的砖块贴图，将Diffuse贴图和Normal贴图转换成Parameter方便我们在材质实例中进行替换


（2）设置一个标量参数Snow Amount（默认0.7）使我们可以在材质外控制雪的数量。


（3）对Diffuse贴图进行插值计算


左边的这个Clamp连接至下图Lerp的Alpha，给贴图连接个标量Darken，可控制贴图的颜色深浅


（4）对法线贴图进行一下效果的优化，增加地面的凹凸感



VertexColor连接的那个Clamp和凹凸贴图偏移处理过的法线相乘，增加其对比度。最后和原始法线叠加。

（5）材质总览


（6）最终效果


我们在下一篇文章中，将讲解如何实现动态积雪的效果。

感兴趣的朋友欢迎关注+订阅本专栏，专栏更新会第一时间提醒哦！
</code></pre>
</details>

<details>
<summary>UE4[蓝图]动态积雪材质的实现（二）</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/52509664
上篇讲完地面的材质，本篇来实现动态积雪效果。

物体上的积雪材质

新建一个材质，名为M_CobbleStone_Snow。

导入Starter Content內容包，里面有我们接下来要使用的贴图。

为了体现物体表面上的积雪效果，这里在材质属性中使用世界位移以及多边形细分乘数。

在Tessellation中启动Flat Tessellation。


基本颜色，这里我使用的鹅卵石贴图，T_CobbleStone_Pebble_D。


粗错度


法线


世界偏移


雪的数量，这里添加了一个标量，为接下来做准备


雪的覆盖范围，这里添加了一个标量，为接下来做准备



Clamp节点的值作为BaseColor、Normal等节点的Alpha

多边形细分乘数


完整如下


接下来，使用刚才创建好的材质创建一个材质实例，并给场景中Mesh使用该材质实例。

在场景中体现动态效果。

首先，给要产生积雪的效果的物体添加一个Actor Tag，在Details中可以看到。

Tag中输入：Snow


打开关卡蓝图，在这里对材质中的参数进行更新，达到一个动态积雪的效果。

在BeginPlay事件中，使用创建动态材质实例节点对地面和物体进行初始化。


调用事件SnowFall和Create and Set Mat


SnowFall事件，这里添加了一个时间轴，使雪的数值随时间变化，达到积雪的效果。



时间轴，添加Float track ，设置下雪量和覆盖范围的参数


Create And Set Mat事件，用来设置参数的一个事件。




点击播放，配合空中雪花的飘落，我们就可以看到一个降雪——》积雪的效果了。
</code></pre>
</details>

<details>
<summary>UE4[BP&C++]AbilitySystem研究实践——神速力技能</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/53341180
最近研究了一下AbilitySystem插件的使用。

下面是实际效果。

这几天我会整理一下具体使用，稍后放出教程全文。
</code></pre>
</details>

<details>
<summary>UE4Paragon角色资源正常导出FBX方法</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/53593439
自从2018年3月份Epic官方宣布Paragon角色资源免费放出后，这些高品质角色包成为了部分开发者的练习素材。


有些开发者在使用一段时间后，想要对这些角色进行二次修改就需要将模型导出使用。

然而并非所有Paragon角色都能正常导出，部分角色如：Shinbi通过一般方法，我们只能在输出的FBX文件中得到角色的骨骼，却没有角色的Mesh模型。显然这没有正常导出。

那么如何将这些角色模型正常导出呢？

非常——简单！

以下是修改Shinbi骨骼模型资源之后的导出FBX再导入的视频。

我会按照需求来决定是否放出教程，最后感谢大家支持！

——————————分割线——————————

2019年1月8日更新

看到有很多人想知道导出方法，那么今天放出导出教程。

之前尝试将UE4官方资源Shinbi的模型导出，发现导出的FBX文件中只有骨骼数据，没有模型


重复导出两次仍是这样的结果，决定查看一下模型数据

检查发现，Clothing那里多了一些东西。


会不会是Clothing的数据影响了FBX的导出呢？

于是删掉Clothing里的东西，重新导出。


我们成功了！

有了模型，我们便可以把它导入3DS max和Maya里制作额外的东西了，至于如何Key动画就不再本文中赘述了。
</code></pre>
</details>

<details>
<summary>UE4[蓝图]只需一秒！最速实现【二段跳】</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/53930750
我是刘茗，一个专注各种有趣玩法的开发者。

本次带来的是二段跳的教程。

在许多动作游戏中，都有着【二段跳】这样的游戏系统。本文将教大家一个最快实现二段跳的方法。

在Character头文件中，我们可以找到：

最大跳跃次数的定义

    /**
     * The max number of jumps the character can perform.
     * Note that if JumpMaxHoldTime is non zero and StopJumping is not called, the player
     * may be able to perform and unlimited number of jumps. Therefore it is usually
     * best to call StopJumping() when jump input has ceased (such as a button up event).
     */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Replicated, Category=Character)
    int32 JumpMaxCount;
在Character.cpp中，这个参数会在CanJumpInternal_Implementation函数中被使用。


因此，继承Character类的对象可以修改上述参数来实现


当我们把这个参数改成2的时候……二段跳已完成！

通过修改这个参数，我们还可以实现三段跳、四段跳、各种跳都可以！

看到这里，觉得不够过瘾的朋友们在这里附上……彩蛋

跳跃系统的分析与研究

首先看一下Jump函数：


这里发现bPressedJump被设置成了true，那么这个变量在哪里被使用了呢？在CheckJumpInput函数中。


const bool bDidJump = CanJump() && CharacterMovement->DoJump(bClientUpdating);
在上面这一行代码中，我们发现这里调用了CharacterMovement组件的DoJump函数。

跳转到DoJump函数中


这里对Velocity的Z值进行了赋值，以及设置了运动模式为Falling。

显然——

这个便是Jump功能真正实现函数了。

此外，Character类还提供了一些蓝图接口供开发者定制。

	/** Let blueprint know that we were launched */
	UFUNCTION(BlueprintImplementableEvent)
	void OnLaunched(FVector LaunchVelocity, bool bXYOverride, bool bZOverride);

	/** Event fired when the character has just started jumping */
	UFUNCTION(BlueprintNativeEvent, Category=Character)
	void OnJumped();
在跳跃和落地时，可以添加一些定制化的功能。
</code></pre>
</details>

<details>
<summary>UE4[蓝图&C++]关于一些找不到的蓝图节点</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/54460581
我是刘茗，一个喜欢解决问题的游戏开发者。

虚幻引擎的版本更迭很快，因此蓝图节点或者函数的名称会随着版本更新变化。

因此许多初学者在网络上看到一些比较旧一些的教程时，经常出现找不到视频中调用的节点或者函数的情况。


比如上图这个函数，在4.17版本的时候就已经改名了。现在到4.21版本入坑的初学者们当然找不到这个节点。

不用上网去问，我们有方便的解决办法：

首先打开Git上下载的源码版的工程（没有的话，新建一个C++工程）

打开工程，按下Ctrl+Shift+F


输入我们找不到的函数名称。


很快，编译器在头文件中找到这个函数的定义。

双击打开，进行跳转。


我们发现，上面提示着：

DEPRECATED(4.17, "Use AttachToComponent instead.")

使用AttachToComponent作为代替。
</code></pre>
</details>

<details>
<summary>UE4[BP]角色换装系统的实现</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/54900203
我是刘茗，一个专注【妹纸】（划掉）游戏的开发者。

实现效果：

前期准备：

角色模型、和角色骨骼相同的衣服模型

这里使用的是官方商城的LP287Character素材包

首先，使用各个部位的模型组合角色


新建一个枚举类，E_Cloth。

添加如下类型，服装种类按照个人需求添加


创建一个PickUp类，添加如下组件


给Mesh设置一个喜欢的模型，并调整好Sphere的大小。

添加以下变量。

分别是SkeletalMesh、E_Cloth、bool、Character类型。

将NewMesh和ClothType属性公开，这样可以方便在场景中进行修改。


为Sphere组件添加Overlap事件。Set Render Custom Depth节点是为了给模型添加一个描边效果，这里先不用添加。



回到Character类，添加ChangeCloth自定义事件。

通过传入的枚举类型，可以设置对应的Mesh


依然是在Character类中，添加如下函数，作用是将播放动画的模型设置为Mesh。


回到Pickup类，添加一个按键事件，这里我设Interaction事件为F键。这里调用了


保存，编译。现在可以通过F键来拾取物品实现换装效果了。
</code></pre>
</details>

<details>
<summary>UE4[C++]为虚幻引擎配置Visual Studio</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/56769102
大家好，我是刘茗，一个热爱游戏事业的开发者。

受硬件因素的影响，有些开发者打开C++项目的加载速度特别慢。

这时候我们需要对VS进行一些设置来加快项目的读取。

一、配置Visual Assist X（使用版本：VAX2210）

打开VAX的Options，将Format after paste取消掉


二、VS部分设置（VS2017）

工具——》选项——》找到文本编辑器，按下图设置


现在，可以感觉到加载速度变快了

——————————————————————————

2019.6.28更新

三、禁用VS默认的声明灯泡

工具——》选项——》找到文本编辑器——》C++


四、为VA的CreateImplement设置快捷键



分配一个快捷，本人设置的是Alt+I
</code></pre>
</details>

<details>
<summary>UE4[Settings]Viewport启动默认出现鼠标光标</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/56783527
有些开发者编辑完关卡后按下Play发现，需要在界面上按下鼠标才能获取游戏的控制。

如何设置默认不出现光标呢？

首先打开Editor Preferences，勾选Game Gets Mouse Control


设置完成后，以后启动就可以直接控制游戏角色了。
</code></pre>
</details>

<details>
<summary>UE4[C++]在虚幻引擎实现单例模式</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/57218085
大家好，我是刘茗，一位热爱游戏行业的开发者。

什么是单例模式？

确保一个类只有一个实例，并为其提供一个全局访问入口
在UE4中创建单例的方式有两种：

第一种方法：使用C++方式进行创建一个单例类。

新建Object类

Singleton.h

// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "Singleton.generated.h"

/**
 * 
 */
UCLASS(BlueprintType,Blueprintable)
class ACTION_API USingleton : public UObject
{
	GENERATED_BODY()
public:
	USingleton(const FObjectInitializer& ObjectInitializer);
	static USingleton* GetInstance() {
		if (SingletonInstance == nullptr)
			SingletonInstance = NewObject<USingleton>();
		return SingletonInstance;
	};
private:
	static USingleton* SingletonInstance;
};
Singleton.cpp

// Fill out your copyright notice in the Description page of Project Settings.

#include "Singleton.h"

//USingleton* USingleton::SingletonInstance = nullptr;
USingleton::USingleton(const FObjectInitializer& ObjectInitializer)
	:Super(ObjectInitializer)
{

}
新建GameInstance类

.cpp

// Fill out your copyright notice in the Description page of Project Settings.

#include "MyGameInstance.h"
#include "Singleton.h"

USingleton* USingleton::SingletonInstance = nullptr;
UMyGameInstance::UMyGameInstance()
{
	Singleton = USingleton::GetInstance();
}

void UMyGameInstance::StartGameInstance()
{
	Super::StartGameInstance();
}

FGameInstancePIEResult UMyGameInstance::StartPlayInEditorGameInstance(ULocalPlayer* LocalPlayer, const FGameInstancePIEParameters& Params)
{
 	FGameInstancePIEResult StartResult = Super::StartPlayInEditorGameInstance(LocalPlayer, Params);
	UE_LOG(LogTemp, Warning, TEXT("StartPlayInEditorGameInstance :Create Singleton"));
	return StartResult;
}
第二种，使用UE4提供的方式

根据Rama的教程所述，

创建一个继承自UObejct的类，之后在项目设置（Project Settings->Engine->General setting）中设置Singleton class

注意，单例类需要标注UClass(Blueprintable, BlueprintType)。

参考资料：

Global Data Access, Data Storage Class Accessible From Any CPP or BP Class During Runtime
</code></pre>
</details>

<details>
<summary>UE4[C++]攀爬系统的设计</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/58560526
先上视频占位，教程随后附上
</code></pre>
</details>

<details>
<summary>UE4[BP]LookAt的使用及效果展示</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/59228843
使用动画蓝图中LookAt Node，人物模型来自网络
</code></pre>
</details>

<details>
<summary>UE4[BP]简单AI集群的实现展示</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/59229152
使用目标点生成，行为树驱动AI攻击
</code></pre>
</details>

<details>
<summary>UE4[C++]自定义Object/Trace Channel</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/59507553
本文作为攀爬系统的补充篇，介绍一下C++自定义Trace Channel的使用

在Project Settings中，可以添加我们想要的Channel


添加之后，我们可以在：

项目名/Config/DefaultEngine.ini中找到我们添加的通道。


为了更便于程序员辨识和使用，我们可以在"项目名.h"文件中定义添加的通道，方便全局使用。

#pragma once

#include "CoreMinimal.h"

#define TRACE_CLIMB ECC_GameTraceChannel1
之后我们可以在LineTrace中使用了

Example：

UKismetSystemLibrary::SphereTraceSingle(this, Start, End, 20.f, UEngineTypes::ConvertToTraceType(TRACE_CLIMB), false, ActorsToIgnore, EDrawDebugTrace::None, Hit, true);
UEngineTypes提供了转换函数，方便我们进行类型转换

	/** Convert a trace type to a collision channel. */
	static ECollisionChannel ConvertToCollisionChannel(ETraceTypeQuery TraceType);

	/** Convert an object type to a collision channel. */
	static ECollisionChannel ConvertToCollisionChannel(EObjectTypeQuery ObjectType);

	/** Convert a collision channel to an object type. Note: performs a search of object types. */
	static EObjectTypeQuery ConvertToObjectType(ECollisionChannel CollisionChannel);

	/** Convert a collision channel to a trace type. Note: performs a search of trace types. */
	static ETraceTypeQuery ConvertToTraceType(ECollisionChannel CollisionChannel);
</code></pre>
</details>

<details>
<summary>UE4[C++]关于源码版引擎编译的坑</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/62470691
编译流程
首先克隆EpicGames在的Git里的UnrealEngine页面下载源码的压缩包。

运行Setup.bat——》GenerateProjectFiles.bat——》生成UE4.sln——》启动vs进行编译

（1）Setup.bat下载过慢的问题
解决方法：使用多线程下载

打开cmd，输入多线程命令，threads=线程数


（2）运行Generate.bat 时出现 .NETFramework,Version=v4.6.* 问题
解决办法：打开vs2017安装器，找到单个组件那里

按照提示的信息，安装对应的.NET framework版本


（3）编译运行后，出现缺少模块、Program等问题
重新编译整个项目


</code></pre>
</details>

<details>
<summary>UE4[安卓]华为手机和打包项目的坑</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/63474566
大家好，我是刘茗。

在国内环境下，安卓平台的开发真是苦不堪言。

最近在研究安卓平台项目的开发，首先测试的环境是华为P20Pro。

然后……就遇到了问题。

首先介绍一下打包流程。

引擎版本：UE4.22 Github源码版。

操作系统：WIndows10

目标平台：安卓

一、安装安卓SDK

首先，找到引擎安装目录UnrealEngine-release\Engine\Extras\AndroidWorks


打开目录


这里使用Windows系统，所以打开WIn64文件夹

运行CodeWorksforAndroid-1R7u1-windows.exe，安装Android SDK。

安装流程选择一个英文目录，这里我使用的C盘为安装的路径。

一直点下一步，同意所有授权条款。

之后开始下载安装，这里可能会出现各种情况。有条件的话，请开启虚拟专用网络进行下载安装。

二、安装结束后，对手机进行设置。

首先选择开发者选项。


启用USB调试。

这里需要提前安装好 华为手机助手

使用USB连接电脑，选择传文件模式

在弹出的对话框中，选择【允许连接电脑】

之后打开CMD，输入adb devices，可以查看所有连接到电脑的设备。

三、打包设置

首先确认好要输出的纹理格式，这里我选择的ETC2

ETC1

所有Android设备均支持，但无法压缩透明纹理（其保存为未压缩）。如果需要透明度来获得更好的压缩，建议使用RGB和单独的透明纹理。

ETC2

所有OpenGL 3.x类设备均支持，并支持透明度压缩。

ATC

Qualcomm Adreno GPUs支持，并支持透明度压缩。

DXT

Nvidia Tegra GPUs支持，并支持透明度压缩。

PVRTC

PowerVR GPUs支持，并支持透明度压缩。

ASTC

最新的纹理压缩格式，可指定块大小来进行质量控制，支持透明度压缩。可在部分设备上使用，为Vulkan Level 1所必需。

在Project Settings中检查地图设置，设置好默认地图，不然打包完什么都看不到


在Platforms中，检查安卓设置


如果不想要obb文件的话，勾选下面这个选项


设置好之后，可以进行打包了。

选择目标文件夹开始打包，打包完成后会出现如下几个文件。


使用USB连接手机，运行Install.bat文件进行安装。

这时候就出现了问题，无法安装到设备。

这个时候可以先使用上文提到的cmd的adb devices指令，先查看是否成功连接。

之后再根据错误提示，检查安卓SDK的环境变量是否正确。

最后检查到了手机……

华为的系统有一个叫 监控ADB安装应用的选项

如果开启的话，是无法通过bat安装进去的。


关闭它，再次安装，成功！



如果遇到更多问题的话，我会继续补充。
</code></pre>
</details>

<details>
<summary>UE4[C++]项目编译相关的坑</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/67566012
大家好，我是刘茗。

最近总结了一些C++项目编译的经验。

一、项目文件夹体积过大的问题

问题原因：项目名\Binaries\Win64路径下有许多带编号的.dll和.pdb文件，这是因为在引擎中使用Compile功能生成的，删掉这些编号文件，可以缩小体积。

解决办法：停止在引擎中编译，使用VS进行编译即可。


二、代码没有语法问题，却出现编译错误

问题原因：未知

解决办法：删除项目路径下 .vs、Intermediate、Saved等文件夹，重新Generate再进行编译。

三、出现函数过时等编译报错问题

解决办法：修改为提示推荐函数

四、Link错误、无法解析的外部符号

解决办法：

（1）检查Build.cs中是否包含引用模块、头文件是否包含、是否定义函数，RPC函数是否实现_Implementation函数、GetLifetimeReplicatedProps函数等。

（2）删除Intermediate文件夹，并重新Generate

五、错误C2280：尝试引用已删除的函数

解决办法：检查是否使用类对象，改成类指针

六、 LINK : fatal error LNK1104: 无法打开文件 XXX.dll

解决办法：看看游戏进程有没有关掉
</code></pre>
</details>

<details>
<summary>UE4[C++]TArray的快速优化</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/72227908
大家好，我是刘茗，这次带来的是UE4 TArray的部分优化技巧。

在UE4中，TArray是一种动态大小的数组，是虚幻引擎中最常用的容器类。

灵活使用TArray可以得到效率的提升。

优化零：

如果我们想要添加独有的元素，可以使用AddUnique这个函数添加。

如果元素存在，返回数组下标。

如果不存在，则添加


优化一：

如果实现知道数组中有多少元素，或者上限，可以事先预留内存空间

使用Reserve函数，可以确保在这个函数内最多只进行一次配置


优化二：

使用TArray作为函数参数使用时，使用它的引用。

void AppendMyArray(int32 N, TArray<AActor*> _Char);
如果直接传递数值，函数会在数组传递给AppendMyArray之前，制作数组的拷贝，会很占用系统性能。

void AppendMyArray(int32 N, TArray<AActor*>＆ _Char);
优化三：

默认情况下，TArray会根据用户的删减来重新排列存储空间，这同样会有效率问题。

使用RemoveAt

此函数会移除该索引的元素，并将之后的元素重新排列。

2. 使用RemoveAtSwap


如果对数组的顺序没有要求的话，使用RemoveAtSwap函数会在移除该索引的元素之后，将最后一个元素移动到移除后的空间里，而非移动所有元素。

优化四：

因为TArray是动态数组，所以我们可以使用TInlineAllocator。


第一个参数，内联元素的数量，这个分配器保留了分配器被实例化的存储空间。当这个空间被用尽时，分配器会移动元素到由第二分配器创建的溢出空间中。对于TArray来说，这意味着在栈上声明的数组将会对这些元素直接在栈上保留空间。作为类或结构体的一部分声明的TArray将会把内联分配存储为该类或结构体的一部分，对作为该数组一部分添加的前N个元素将不会进行动态分配。

我们可以把

TArray<AActor*> MyArray;

改为：

TArray<AActor*, TInlineAllocator<32>> MyAllocatedArray;

这样，我们就不用对前32个被添加到数组的元素进行任何动态分配，因为它们正好能填入作为TInlineAllocator一部分的栈的区域。在33个元素之后，所有元素都被移动到第二分配器存储。

优化五：

在优化四的结尾处，MyAllocatedArray的类型名显得有些长了，因此可以声明我们的数组类型。

使用typedef

typedef TArray<AActor*, TInlineAllocator<32>> AllocateArrayType;
AllocateArrayType MyArray;

//迭代
for (AllocateArrayType::TIterator Iter(MyArray); Iter; ++Iter)
{
	AActor* MyActor = *Iter;
	MyActor->YourFunction();
}
</code></pre>
</details>

<details>
<summary>C++如何输出双引号</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/72784658
C++中是不能直接用双引号输出双引号的

string str = " "" ";
以上代码在编译器中是会报错的。

解决办法是：

C++中所有的特殊字符都可以通过添加转义符"\"，因此可以在双引号前加一个\

例如：

int main()
{
	string str = "\"Working hard for my baby bunny\"";
	cout << str << endl;
}
\\printf："Working hard for my baby bunny"
</code></pre>
</details>

<details>
<summary>UE4[C++]UGameplayStatics类实用分析</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/71254108
大家好，我是刘茗。

UGameplayStatics是一个很实用的静态类，我们不需要拥有指向此类的任何实例的指针，并且可以直接从任何地方调用函数。


多图预警！

多图预警！

多图预警！

使用引擎版本：4.22

（1）SpawnObject

UFUNCTION(BlueprintCallable, Category = "Spawning", meta = (BlueprintInternalUseOnly = "true"))
 	static UObject* SpawnObject(TSubclassOf<UObject> ObjectClass, UObject* Outer); 
return NewObject<UObject>(Outer, ObjectClass, NAME_None, RF_StrongRefOnFrame);
作用创建一个Object

（2）生成相关函数


BeginSpawningActorFromBlueprint
作用：从蓝图中生成实例，但不会自动执行它的构造脚本
BeginDeferredActorSpawnFromClass
作用：生成一个Actor类的实例，但是不会自动执行它的构造脚本
FinishSpawningActor
作用：结束生成Actor，执行构造脚本
注意：BeginSpawningActorFromClass已在4.9版本被弃用
（3）Actor函数相关


1.GetActorArrayAverageLocation

作用：获取Actor数组的平均位置

2.GetActorArrayBounds

作用：获取Actor数组的边界

（4）获取Actor相关


GetAllActorsOfClass

获取此类的Actor数组

GetAllActorsWithInterface

获取拥有此接口的Actor数组

GetAllActorsWithTag

获取此Tag的Actor数组

（5）Get相关



获取UGameInstance、APlayerController、APawn、ACharacter、APlayerCameraManager等

（6）关卡流相关


StreamLevel的加载卸载

（7）关卡相关


（8）全局相关


获取AGameModeBase、AGameStateBase、对象的UClass

GetGlobalTimeDilation在下面连接有实际应用

大侠刘茗：UE4[BP&C++]AbilitySystem研究实践——神速力技能
17 赞同 · 5 评论文章


游戏的暂停、世界渲染等

（9）伤害相关



作用：应用范围伤害、点伤害、伤害等。

（10）摄像机相关


播放世界相机震动

（11）粒子相关



在目标生成粒子、Attch生成粒子等

（12）音效相关







音效太多了，和粒子类似

（13）贴花相关


（14）碰撞相关



（15）SaveGame相关



保存游戏与加载游戏

（16）时间相关


（17）其它工具函数


世界原始位置等

以上整理了17类GameplayStatic的函数，后续版本有更新的话待补充，欢迎大家指教！
</code></pre>
</details>

<details>
<summary>UE4[Plugin]通过插件和UI改变太阳光位置</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/77066756
大家好，我是刘茗。

前几天刷UE4官方频道，看到一个很有意思的插件：

Sun Position Calculator

这是一个可以通过时间来确定太阳位置的插件。

使用引擎版本:4.22.3

首先，新建一个项目。

在插件中找到这个插件并启动


在内容管理器中勾选【显示引擎内容】【显示插件内容】


在如下路径找到BP_SunPosition


拖入场景中，它的细节参数中有Location、Date、Time等参数的调节，记得绑定Sky Sphere


新建一个控件蓝图（UserWidget)，并添加一个Slider


为Slider添加事件OnValueChanged

输入如下蓝图


新建一个PlayerController，将Widget添加到视口上


在世界设置中，设置好GameMode

下面是Level的设置，有以下几点需要注意：

Level中一定要有BP_ Sky _Sphere(天空球蓝图)
天空求中要绑定方向光
DirectionLight要设置为可移动
提前预设好BP_SunPosition的参数，效果才会好一些
下面是实际效果：

以上是对Sun Position Calculator这个插件的初探了，感谢大家的耐心阅读！

PS:七夕点赞的一定是大佬！
</code></pre>
</details>

<details>
<summary>UE4[C++]UEnum枚举相关使用</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/68704087
大家好，我是刘茗。

在C++11标准中，除了传统的枚举enum关键字之外， 还新增了一个概念： enum class

enum class组合具有class封装性的特性，作用域是确定的

在UE4中声明枚举有两种方式

//第一种
UENUM()
namespace EWeapon
{
    enum Type
    {
        EW_Handgun,
        EW_shotgun
    };
}

// 第二种
UENUM()
enum class EWeapon : uint8
{
	EW_Handgun,
	EW_shotgun
};
对于枚举中的元素，我们可以使用UMETA来对它进行修饰。

//必须添加BlueprintType标识
UENUM(BlueprintType)
enum class EWeapon : uint8
{
	EW_Handgun        UMETA(DisplayName="Handgun"),//如果想要显示中文，需要设置编码格式为UTF-8
	EW_shotgun        UMETA(DisplayName="shotgun"),
};
如果枚举索引不想从0开始的话，使用下面的格式：

UENUM(BlueprintType)
enum class EWeapon : uint8
{
	EW_Handgun =1        UMETA(DisplayName="Handgun"),
	EW_shotgun           UMETA(DisplayName="shotgun"),
};
枚举指针的获取：

const UEnum* EnumPtr = FindObject<UEnum>(ANY_PACKAGE, TEXT("EWeapon"), true);
UEnum继承自UField

实用函数：

通过名字获取索引

int32 GetIndexByName(FName InName, EGetByNameFlags Flags = EGetByNameFlags::None) const;
通过索引获取名字

FName GetNameByIndex(int32 Index) const;
通过值获取索引下标

FORCEINLINE int32 GetIndexByValue(int64 InValue) const
通过下标获取值

FORCEINLINE int64 GetValueByIndex(int32 Index) const
通过下标获取显示名称

virtual FText GetDisplayNameTextByIndex(int32 InIndex) const;
获取索引最大值

int64 GetMaxEnumValue() const;
检查索引是否有效，加强代码稳定性

	/** Checks if enum has entry with given value. Includes autogenerated _MAX entry. */
	bool IsValidEnumValue(int64 InValue) const;

	/** Checks if enum has entry with given name. Includes autogenerated _MAX entry. */
	bool IsValidEnumName(FName InName) const;
</code></pre>
</details>

<details>
<summary>UE4[C++]ARPG项目中游戏技能系统浅析（一）AttributeSet属性集</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/79854718
大家好，我是刘茗。

ActionRPG示例项目是UE4中一个展示GameplayAbilitySystem的项目。

使用技能系统的第一步，那就是启用 GameplayAbilities 插件并创建属性集类

下文GAS为GameplayAbilitySystem的简称

一、GAS插件启动

目前GAS是作为UE4的一个引擎插件使用的，所以要先去启动。

打开插件设置，找到GameplayAbilities插件启动


二、代码文件结构




三、按键绑定（PC端）


普攻：左键

技能：F键（进入坦克）

翻滚：右键

切换武器：鼠标滑轮

道具栏：Tab键

自动挂机：回车

暂停：ESC键

使用道具：R键

道具栏界面，点击右上角的加号可以增加Souls用来购买技能和装备。


使用GAS需要添加UAbilitySystemComponent，在ActionRPG.Build.cs文件中添加了GAS模块


项目中使用的是派生类URPGAbilitySystemComponent


URPGAbilitySystemComponent在ARPGCharacterBase的构造函数中添加：


四、创建属性集

因为此系统仅在C++中支持，因为属性集必须是UAttributeSet的C++子类。

在ARPG项目中，定义了如下属性：

生命、法力、攻击力、防御力、暴击、移动速度等。


这里使用的数据结构是FGameplayAttributeData，它内部存储两个数据：基数值和当前值。


获取/修改通过Get/Set函数


	UPROPERTY(BlueprintReadOnly, Category = "Damage", ReplicatedUsing = OnRep_DefensePower)
	FGameplayAttributeData DefensePower;
	ATTRIBUTE_ACCESSORS(URPGAttributeSet, DefensePower)
#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName)

这个宏注册了这个属性的4个基础函数

FGameplayAttribute Get##PropertyName##Attribute()

float Get##PropertyName()

void Set##PropertyName

void Init##PropertyName

void URPGAttributeSet::OnRep_Mana()
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(URPGAttributeSet, Mana);
}
GAMEPLAYATTRIBUTE_REPNOTIFY这个宏用于RepNotify函数中，在客户端中修改属性

URPGAttributeSet在RPGCharacterBase.h中声明了变量，并作为Character的友元



	// Create the attribute set, this replicates by default
	AttributeSet = CreateDefaultSubobject<URPGAttributeSet>(TEXT("AttributeSet"));
在Character的构造函数中，创建了属性集对象
</code></pre>
</details>

<details>
<summary>UE4[C++]ARPG项目中游戏技能系统浅析（二）GameplayEffect</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/80516257
大家好，我是刘茗。

本篇是对ARPG项目分析的第二部分。

上一篇的传送门在此：https://zhuanlan.zhihu.com/p/79854718

一、UGameplayEffect

游戏性效果是游戏性技能系统更改属性的方法，其中包括：

对属性的基数值进行更改，例如角色受到伤害时，减小生命值。
临时基数值更改，例如BUFF。
随时间推移而应用的永久性更改，例如自动回血回蓝。
与大多数游戏技能系统不同，无论在本机还是蓝图代码中，GameplayEffect通常不覆盖基类UGameplayEffect。相反，GameplayEffect被设计成完全通过变量来配置。

ARPG中的近战攻击在下面的蓝图中实现。


GA_MeleeBase中绑定的效果为GE_MeleeBase。


ARPG项目中近战效果的继承关系

UGameplayEffect
                 ——>GE_DamageBase
                                    ——>GE_MeleeBase
打开GE_MeleeBase蓝图可以看到，开发者对GE进行几项配置：


（1）持续时间


GE的持续时间分别有3类：Instant（瞬间生效），Infinite（效果一直持续），Has Duration（有持续时间）。

在这里，近战效果为瞬间生效。

（2）效果执行


二、UGameplayEffectExecutionCalculation

效果执行中，有计算效果类。

UGameplayEffectCalculation
                           ——》UGameplayEffectExecutionCalculation
                                                                     ——》URPGDamageExecution
在URPGDamageExecution类中，重写了Execute函数。

virtual void Execute_Implementation(const FGameplayEffectCustomExecutionParameters& ExecutionParams, OUT FGameplayEffectCustomExecutionOutput& OutExecutionOutput) const override;
Execute函数用来确定此效果何时来执行。

RelevantAttributesToCapture这个数组用来存储参与计算相关的属性

protected:
	/** Attributes to capture that are relevant to the calculation */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=Attributes)
	TArray<FGameplayEffectAttributeCaptureDefinition> RelevantAttributesToCapture;
在数据结构中，定义了防御系数，攻击系数，以及攻击数值。

因为要通过ARPG的攻击计算公式，因此需要获取Target（目标 || 敌方）的防御系数，以及Source（技能发起者 || 我方）的攻击系数和伤害值。

struct RPGDamageStatics
{
	DECLARE_ATTRIBUTE_CAPTUREDEF(DefensePower);
	DECLARE_ATTRIBUTE_CAPTUREDEF(AttackPower);
	DECLARE_ATTRIBUTE_CAPTUREDEF(Damage);

	RPGDamageStatics()
	{
		// Capture the Target's DefensePower attribute. Do not snapshot it, because we want to use the health value at the moment we apply the execution.
		DEFINE_ATTRIBUTE_CAPTUREDEF(URPGAttributeSet, DefensePower, Target, false);

		// Capture the Source's AttackPower. We do want to snapshot this at the moment we create the GameplayEffectSpec that will execute the damage.
		// (imagine we fire a projectile: we create the GE Spec when the projectile is fired. When it hits the target, we want to use the AttackPower at the moment
		// the projectile was launched, not when it hits).
		DEFINE_ATTRIBUTE_CAPTUREDEF(URPGAttributeSet, AttackPower, Source, true);

		// Also capture the source's raw Damage, which is normally passed in directly via the execution
		DEFINE_ATTRIBUTE_CAPTUREDEF(URPGAttributeSet, Damage, Source, true);
	}
};
在URPGDamageExecution构造中添加了捕获到的属性：

URPGDamageExecution::URPGDamageExecution()
{
	RelevantAttributesToCapture.Add(DamageStatics().DefensePowerDef);
	RelevantAttributesToCapture.Add(DamageStatics().AttackPowerDef);
	RelevantAttributesToCapture.Add(DamageStatics().DamageDef);
}

这里添加了目标的免疫伤害的Tag：




三、Effect的应用

在技能释放后，会调用URPGGameplayAbility::ApplyEffectContainer函数，应用Effect效果。


UFUNCTION(BlueprintCallable, Category = Ability, meta = (AutoCreateRefTerm = "EventData"))
virtual TArray<FActiveGameplayEffectHandle> ApplyEffectContainer(FGameplayTag ContainerTag, const FGameplayEventData& EventData, int32 OverrideGameplayLevel = -1);

UFUNCTION(BlueprintCallable, Category = Ability, meta = (AutoCreateRefTerm = "EventData"))
virtual FRPGGameplayEffectContainerSpec MakeEffectContainerSpec(FGameplayTag ContainerTag, const FGameplayEventData& EventData, int32 OverrideGameplayLevel = -1);
ApplyEffectContainer执行两项操作：

首先，它会去查找与传入的Tag相匹配的FRPGGameplayEffectContainer。

如果找到了，它将创建FRPGGameplayEffectContainerSpec，其中包含TargetData和EffectSpecs的列表。

然后，它会应用该ContainerSpec，对目标造成实际伤害。

目标数据是FGameplayAbilityTargetDataHandle，它指向包含碰撞结果、actor或其他游戏特定对象的多态目标结构数组。

EffectSpecs是FGameplayEffectSpecHandle数组，指向要应用的效果以及捕获的属性值列表。

在捕获Effect和Target Data之后，可在日后转发、修改和执行它们。但在近战中，它会在捕获后立即执行。

使用GAS的游戏可能都需要实现与ApplyEffectContainer类似的系统，以便将蓝图逻辑放入父能力中，而将要执行的效果列表放入子蓝图中。但是，每个游戏都会略有不同，如果游戏包含客户端预测定位，那么它将比ARPG中使用的版本复杂得多。
</code></pre>
</details>

<details>
<summary>UE4[C++]如何启动真加载界面</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/98575524
大家好，我是刘茗。

最近研究了下真加载界面的制作，在此分享下制作经验。

一、首先新建一个YourGameInstance类

重写Init函数，在UObjectGlobals.h文件中，FCoreUObjectDelegates里声明了很多实用的静态Delegate。

找到PreLoadMap和PostLoadMapWithWorld，并把它们在Init函数中进行绑定。


Super::Init();
FCoreUObjectDelegates::PreLoadMap.AddUObject(this, &UMarinGameInstance::BeginLoadingScreen);
FCoreUObjectDelegates::PostLoadMapWithWorld.AddUObject(this, &UMarinGameInstance::EndLoadingScreen);
PreLoadMap委托将在最初加载地图的时候进行广播，

而PostLoadMapWithWorld会在地图成功加载完成的时候进行广播。

在YourGameInstance头文件中，声明绑定的函数。

//YourGameInstance.h
public:
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Loading Screen")
	TSubclassOf<UUserWidget> WidgetTemplate;

	UPROPERTY()
	UUserWidget* LoadingWidget;

private:
	UFUNCTION()
		virtual void BeginLoadingScreen(const FString& MapName);
	UFUNCTION()
		virtual void EndLoadingScreen(UWorld* LoadedWorld);
BeginLoadingScreen函数

BeginLoadingScreen(const FString& MapName)
{
	if (!IsRunningDedicisplayTime = 60.f;//最短播放时间
		LoadingScreen.bAutoCompleteWhenLoadingCompletes = true;//如果加载完成 自动关闭
		LoadingScreen.bMoviesAreSkippable = true;//影片是可以跳过的
		LoadingScreen.bWaitForManualStop = true;//需要玩家主动中断
		LoadingScreen.PlaybackType = EMoviePlaybackType::MT_Normal ;
		LoadingScreen.WidgetLoadingScreen = FLoadingScreenAttributes::NewTestLoadingScreenWidget();

		LoadingWidget = CreateWidget<UUserWidget>(this, WidgetTemplate);

		if (LoadingWidget)
		{
			TSharedPtr<SWidget> WidgetPtr = LoadingWidget->TakeWidget();
			LoadingScreen.WidgetLoadingScreen = WidgetPtr;
			UE_LOG(LogTemp, Log, TEXT("Get WidgetPtr"));
		}
		else
		{
			UE_LOG(LogTemp, Log, TEXT("No WidgetPtr"));
		}
                //作为加载界面的影片 路径为Content/Movies
		LoadingScreen.MoviePaths.Add("Loading_Screen_HD_with_Sound");
		GetMoviePlayer()->SetupLoadingScreen(LoadingScreen);
	}
}
EndLoadingScreen(UWorld* LoadedWorld)
{
	UE_LOG(LogTemp, Log, TEXT("EndLoadingScreen"));
	if (!IsRunningDedicatedServer())
	{
		if (LoadingWidget)
		{
			LoadingWidget->RemoveFromParent();
			LoadingWidget->MarkPendingKill();
		}
	}
}
二、设置对应的UI

新建一个YourGameInstance类的蓝图

打开项目设置，选择对应游戏实例蓝图


在GameInstance蓝图中，设置对应的UI


以上是本功能的基本流程，更深入的部分，以后会专门再开一篇文章来解说。

特别注意：如果在项目设置的影片中添加了影片，则不会在加载过程中应用LoadingWidget
</code></pre>
</details>

<details>
<summary>UE4[C++]添加自定义模块</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/101179587
大家好，我是刘茗。

在项目开发过程中，有时会出现新增模块的需求。

文章所用引擎版本：Unreal 4.24.1

为什么需要自定义模块？
纵观UE4的源码目录，UE4的代码主要有四个部分：


仔细观察，会发现它们都是由大大小小的模块所组成。

在游戏最终发布时有些模块是游戏需要的，有些是不需要的。因此UE4在Unreal Build Tool中引入了模块机制。


通过配置，我们可以很方便的看到这个模块的用途，是作为编辑器的模块，还是作为游戏、客户端、服务器或者是独立程序的一个模块。

一、用编辑器打开项目名.uproject文件
在Modules的下面增加自定义的模块描述

  "Modules": [
    {
      "Name": "YourProject",
      "Type": "Runtime",
      "LoadingPhase": "Default"
    },
    {
      "Name": "YourModule",
      "Type": "Runtime",
      "LoadingPhase": "Default"
    }
  ]
在这里可以加入其它配置项，具体配置在

Engine\Source\Runtime\Projects\Public\ModuleDescriptor.h

二、创建模块
游戏模块至少要包含一个头文件、一个C++文件和一个编译文件 (*.Build.cs)，因此我们在项目的Source文件夹下创建一个自定义模块的文件夹。

并添加如下内容：

一个叫做Public的文件夹，用来存放头文件[YourModuleName].h
一个叫做Private的文件夹，用来存放源文件[YourModuleName].cpp、预编头文件（PreCompileHeader）[YourModuleName]PrivatePCH.h，可以将模块内通用的头文件发在这个头文件中，可以加快编译。
一个编译文件，[YourModuleName].Build.cs，方括号内为自定义的模块名称。
三、Build文件
打开[YourModuleName].Build.cs，输入如下代码

// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class YourModuleName: ModuleRules
{
	public YourModuleName(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
	
		PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore" });

		PublicIncludePaths.AddRange(new string[] {"YourModuleName/Public"});
 
		PrivateIncludePaths.AddRange(new string[] {"YourModuleName/Private"});

		// Uncomment if you are using Slate UI
		//PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });
		
		// Uncomment if you are using online features
		// PrivateDependencyModuleNames.Add("OnlineSubsystem");

		// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true
	}
}
四、模块头文件、源文件
#pragma once
//-----------------HEADER----------
#include "ModuleManager.h"

class YourModuleNameClass: public IModuleInterface
{
public:

	/* This will get called when the editor loads the module */
	virtual void StartupModule() override;

	/* This will get called when the editor unloads the module */
	virtual void ShutdownModule() override;
};

//-----------------CPP----------
#include "LoadingScreenModule.h"

void YourModuleNameClass::StartupModule()
{

}

void YourModuleNameClass::ShutdownModule()
{

}

IMPLEMENT_GAME_MODULE(YourModuleNameClass, YourModuleName);
五、重新生成项目
为了防止文件冲突， 删除掉Binaries和Intermediate文件夹之后再点击Uproject右键Generate。

重新生成之后，编译通过就可以看到我们注册的模块了。


六、注意事项
在UE4游戏中，至少要使用 IMPLEMENT_PRIMARY_GAME_MODULE 注册一个模块。其他模块可以使用另一个可选的 IMPLEMENT_GAME_MODULE 方法进行注册。在这里新增的模块并不是做为主模块使用，因此使用IMPLEMENT_GAME_MODULE注册。

出现多个游戏性模块时，我们可以在Target.cs 文件中找到ExtraModuleNames，添加自定义的模块名称。
</code></pre>
</details>

<details>
<summary>UE4[程序分享]Switch游戏机甲战魔开发经验和优化（上）</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/99213921
大家好，我是刘茗。

本篇本章是翻译自Switch独占游戏【DAEMON X MACHINA】（机甲战魔）团队在Unreal JP的经验分享。

DAEMON X MACHINA是2019年9月13日在Switch平台发售的独占动作机甲游戏。基于UE4.20版本开发。


分享分为两部分：引擎篇和特效篇

一、引擎篇
引擎篇主要讲解的是：针对UE4的机能进行灵活使用的案例以及问题点和对应处理方法。

机体相关

（1）机体的组成

机体模型高为5~6m，使用了Character、CharacterMovement组件的派生类。

模型由数个SkeletalMesh通过Attach组成。

目的是为了

1.机甲的换装

2.机甲的一些部件是可动的

3.武器的换装

作为父骨骼的主体SkeletalMesh，用于播放全身动画。其余的头、身体、手脚等部分Attach到作为主体的Mesh上，通过SetMasterPoseComponent设置。

MainMesh(SkeletalMesh)
    ---Head
    ---Hand
    ---Body
    ---Foot
    ---Weapon
    ---额外部件
设置类似于之前换装流程，传送门：

大侠刘茗：UE4[BP]角色换装系统的实现
71 赞同 · 19 评论文章

（2）武器是Actor，可方便分离替换

（3）机体的破坏是通过播放VFX的同时替换掉模型。

驾驶员相关（Avatar）

驾驶员类同样是从Character类派生，因为涉及到驾驶员的人体改造，所以驾驶员同样由多个SkeletalMesh组成。

驾驶员的模型构成：

通过模型、材质、贴图和材质参数的替换实现角色定制，游戏中35名以上的NPC都是使用同样的系统组成的。

角色头部调用了SetMasterPose

敌人相关


小型敌人由Pawn类派生，使用单个模型。


Boss同样由Pawn类派生，模型依然为一个，但是弱点部位Attach了多个Actor。

这里带来了一个问题：

Attach过多会给CPU带来效率问题（因为是Switch平台）。

关卡的组成

远处场景面积大小为4x4km，而玩家可活动的范围为2x2km的正方型。


游戏中通过配置时间与气候，内置了15种场景。

例如雨天地图通过替换光照、天空球、环境特性等制作。


关卡的NavMesh

因为场景中拥有可破环的建筑物，所以需要重新计算AI的可行动范围。因此项目组使用了Dynamic Modifiers Only


Cutscene相关

本作遇到了一个问题是在切换过场使毛发的物理效果会出现问题。

于是项目组采用了如下解决办法：

在LevelSequencePlayer的OnCameraCut触发时进行处理，通过控制全身物理效果的ON/OFF进行切换，并保存头发模型的Animation Pose Snapshot再进行使用。


UI相关

项目组使用RichText来解决无法在对话中显示图标的问题。

按键绑定相关

由于Switch拥有陀螺仪，所以也添加了陀螺仪相关的配置


网络相关

使用OnlineSubsystemSwitch，移动相关的处理被移交到Client方。

性能优化对策

Move相关,CharacterMovementComponent对CPU的负荷较高，因此将一部分角色从Character类转变为Pawn类
减少Attach的对象
导航相关,抑制Primitive组件的导航更新，UNavigationSystemV1::SetUpdateNavOctreeOnComponentChange(false)
在战斗前后和对象破坏时切换
Generate Overlap Event的判定越大CPU负荷越大
未参加战斗的角色会关闭
地图对象,地图中放置的可破坏对象很多，因为坏掉之后都不会动，所以静止时要关闭功能，Actor和Component都要停止Tick，关闭Generate OverlapEvents，可动性设置为EComponentMobility：Static，SetMobility（EComponentMobility：Static）
子弹相关的优化，玩家可能会在短时间内发射上百发子弹，会导致CPU负荷较大，随着UObject的增多，GC的负荷也会增大。解决办法是使用对象池。
AActor：不是通过SetAcctorLocation而是通过MoveComponent移动，RootComponent->MoveComponent（…，MOVESOM SkipPhysicsMove，…）;
蓝图相关，
(1)绝对不要用蓝图的Tick，
(2)使用C++的，动画蓝图的事件图表也可以用C++来写
(3)多余的UFUNCTION和UPROPRTY会增加UObject数
(4)Blueprint NativeEvent即使没有BP使用，成本也很大
(5)C++就可以使用的函数就不用加UFUNCTION
内存相关
r.RenderTargetPoolMin 200，将默认的阈值400变为200，对本作内存溢出的问题贡献很大
Engine/Content/EngineMaterials/DefaultBloomKerne.uasset编辑器中显示引擎内容并打开该资产编辑Maximum Texture Size属性
2048→1024
UMG相关优化
(1)Visibility被设定为“Hidden”的Widget会继续使用CPU，因此多数都设置为Collapsed。
(2)可以使用InvalidationBox进行性能优化

</code></pre>
</details>

<details>
<summary>UE4[美术分享]Switch游戏机甲战魔开发经验（下）特效分享</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/135320847
大家好，我是刘茗。

本篇本章是翻译自Switch独占游戏【DAEMON X MACHINA】（机甲战魔）团队在Unreal JP的经验分享。

上篇传送门：

大侠刘茗：UE4[分享]Switch游戏机甲战魔开发经验和优化（上）
73 赞同 · 1 评论文章

DAEMON X MACHINA美术篇

VFX的分享者名为菊地悟，从业经历20年


一、卡通渲染的方向性

本作的机甲选择了卡通渲染风格，方向大致为以下几点：

1.牢记差异化

2.模仿80年代机甲动画和漫画的颜色和对比度

3.简单且有特征性

二、VFX制作计划

项目开始时，项目组的情况是这样的：

多数人员没有UE经验（有经验者包括菊地老哥在内共两人）。

素材准备时间有限，需要创造大量素材。

没有专门的TA或VFX工程师

菊地老哥是在UE4中首次制作VFX，探索环境构建，工作流程等。

在这种情况下，菊地老哥选择的方针是：先不做过于复杂的素材，重点放在易用的和方便复用的素材上。

三、VFX制作过程中重视的几个要点

要拥有可以作为动作游戏资产的功能
减少加工负荷
减少工时
卡通表现
质量感（机甲对象的表现）
在VFX组内进行彻底的信息共享
三、开发环境

UE 4.20 （Cascade）

DCC工具：

Maya

3ds Max

Substance Designer

Houdini

四、材质

（1）项目中的材质划分：

1.通过【Usage】来划分

2.【通用】和【专用】划分

3.【有光照】和【无光照】划分

（2）混合模式和游戏要素：


项目中，半透明材质的混合模式主要使用Masked。


Masked也可以做成半透明的效果，却没有像Translucent那样吃资源。且不必考虑绘制顺序，还能兼顾卡通风格的处理表现和处理负荷。

五、相关资源


子弹相关

（1）导弹


（2）狙击步枪


（3）子弹的符号化


烟雾相关

（1）消散效果


通过粒子的动态属性控制，并不直观而且很麻烦


因此，可以在“Color Over Life模块”中，分别控制它的Alpha曲线，这样会更直观。

（2）UV滚动带来的锯齿

解决方案：


在Panner节点中，勾选fractional part来提高精度，消除锯齿
Compression Setting中选择Grayscale，即使是低分辨率也会更圆滑一些。



（3）大量烟雾遮挡画面带来的问题


根据相机距离，在烟雾上面开个洞。

爆炸相关


玩家或敌人坠落时的VFX，要传达完成击落的感觉，以及从机体上掉落武器的效果

采取的方法是纵向强调坠落地点

滑行移动相关


机体的滑行移动的轨迹部分：

（1）轨迹在PC运行是没问题的

（2）在实机上轨迹会有暴凸的现象

原因：


轨迹的尾部会受到动画缩放的影响，取消Size by life可以消除这种效果

范围爆炸


使用抹除和径向模糊效果

推进器

尾焰是模型


地面烟尘


</code></pre>
</details>

<details>
<summary>UE5-EA版安装流程</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/375561771
大家好，我是刘茗。

UE5终于来了，直播中介绍的各个新特性也令人十分激动。

那么直接开始安装吧！

首先安装Epic平台，然后在下面的网站获取安装权限

https://www.unrealengine.com/zh-CN/blog/unreal-engine-5-is-now-available-in-early-access
​www.unrealengine.com/zh-CN/blog/unreal-engine-5-is-now-available-in-early-access
然后点击获取UE5抢先体验版


开始冲！


UE5的示例项目在首页的靠近下面的位置下载

https://www.unrealengine.com/zh-CN/unreal-engine-5?lang=zh-CN
​www.unrealengine.com/zh-CN/unreal-engine-5?lang=zh-CN

虚幻引擎5

虚幻引擎5
​www.unrealengine.com/zh-CN/unreal-engine-5?lang=zh-CN



准备升级配置吧！


</code></pre>
</details>

<details>
<summary>[UE5]解决提示无法打包，缺少SDK的问题</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/494569066
UE5正式版终于发布了，配套的Lyra示例项目也令人激动呢！

但是打包Lyra的同时，也遇到了一些缺少SDK的问题，下面我们来看看如何解决吧！

官网下载SDK
https://developer.microsoft.com/zh-cn/windows/downloads/windows-sdk/

下载 .NET Core 3.1 (Linux、macOS 和 Windows)

使用Visual Studio Installer升级VS
C:\Program Files\dotnet\host\fxr\3.1.23\hostfxr.dll 拷贝到Epic Games\UE_5.0\Engine\Binaries\ThirdParty\DotNet\Windows\host\fxr\3.1.9路径下
问题分析：

可能是中文路径问题？

可能是电脑内有多个DoNet版本，导致UE5无法定位DotNet的dll位置
完成以上步骤打包打包成功！

</code></pre>
</details>