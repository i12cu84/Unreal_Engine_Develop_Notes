
<details>
<summary>C++到底是怎么编译的？</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/365820917
g++编译可执行文件：

g++ main.cpp -o main.exe
应该有不少人都好奇过：“g++编译器帮我们做了什么？怎么就让C++的代码变成一个可以完成对应代码指令的可执行二进制文件了？”，这里我们就稍微打破一点砂锅，问多一点。

从一个.cpp文件到可执行文件，在g++编译器中的实现大致也分为四个步骤：预处理、编译、汇编和链接。


预处理(Preprocessing)：进行宏(#define)的替换，删除注释，插入#include的头文件等操作，文件后缀名.i；
编译(Compilation)：将预处理后的代码文件“翻译”成汇编语言的文件，文件后缀名.s；
汇编(Assembly)：将汇编语言文件“翻译”成机器代码的二进制文件，文件后缀名.o；
连/链接(Linking)：引入代码中使用到的“库”文件，生成可执行文件。
用一个可能是世界上最简单的C++程序作为开始：

// main.cpp

int main() {
    return 0;
}
这个程序甚至连printf("Hello World!"); 都没有。

1 预处理 Preprocessing
g++ -E main.cpp > main.i
-E参数可以让g++单独执行预处理操作，以下是预处理后的代码文件main.i：

# 1 "main.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "main.cpp"


int main() {
    return 0;
}
预处理主要进行宏#define的替换，删除注释，插入#include的头文件等操作，你可以试着给main.cpp添加宏、注释以及引用，然后再输出预处理文件来进行观察：g++是不是都完成了这些操作。

2 编译 Compilation
g++ -S main.i
-S参数可以让g++单独执行编译操作，以下是编译后的汇编语言文件main.s（看不懂也没关系）：

 	.file	"main.cpp"
	.text
	.def	__main;	.scl	2;	.type	32;	.endef
	.globl	main
	.def	main;	.scl	2;	.type	32;	.endef
	.seh_proc	main
main:
	pushq	%rbp
	.seh_pushreg	%rbp
	movq	%rsp, %rbp
	.seh_setframe	%rbp, 0
	subq	$32, %rsp
	.seh_stackalloc	32
	.seh_endprologue
	call	__main
	movl	$0, %eax
	addq	$32, %rsp
	popq	%rbp
	ret
	.seh_endproc
	.ident	"GCC: (x86_64-posix-sjlj-rev0, Built by MinGW-W64 project) 8.1.0"
编译将预处理后的代码文件“翻译”成汇编语言的文件，能读懂汇编语言的同学应该将上面的代码和源文件的代码对应起来，这里就不再讲解太多了，简单来说，这一步是为汇编步骤里面翻译成机器语言而做准备。

3 汇编 Assembly
g++ -c main.s
-c 参数可以让g++单独执行汇编操作，以下是汇编后的二进制文件main.o （二进制也没法展示啊，那给你们看个乱码吧）：


汇编将汇编语言文件“翻译”成机器代码的二进制文件，因为机器执行代码都是以01数据作为基础的，所以需要继续将汇编语言翻译成机器代码，你可能会想“为什么不让C++直接翻译到机器代码呢？”，汇编语言出现的更早，汇编语言的高效得益于对硬件的定向适配，不同硬件往往有不同的汇编语言，移植性差，而C/C++这类“高一级”的语言，都想脱离硬件捆绑，做到全平台适配，所以为了让一份代码在各平台都能运行，就让“编译+汇编”两个步骤来抹去不同平台的“翻译差异”。

好了，现在只差最后一步了。

4 连/链接 Linking
g++ main.o -o main
-o 参数和编译流程无关，其作用是指定可执行文件名，g++使用机器代码文件main.o ，进行链接操作，在这里的示例你可能并不能理解链接还做了什么，因为理论上main的执行并不需要再依赖其他库了。

但当你在main.cpp中使用其他库文件的时候，那就是另外一码事了。

比如你想要printf("Hello World!"); ，那你就需要#include<iostream>引用头文件， 而我们知道在C++实践中，往往使用的是声明和定义分离的方法，仅仅在头文件中声明函数变量等，而另在文件中进行相应的定义实现，观察整个流程，你会发现我们只在预处理阶段引入了头文件的代码，而头文件对应的定义文件呢？这就是链接步骤的作用！

我们使用的“库文件”是已经预编译汇编好的文件，g++就负责把他们在“丢到”一起，打成一个包，也就是最后的可执行文件了。



到这里，所有的编译过程就结束了！

当然，这是非常简化的编译流程介绍，相信你读到这里，应该对其中的细节还抱有更多的疑问，比如C++代码是如何编译成汇编语言的、链接里面的静态库和动态库的区别、链接是如何组织这些文件让程序可以运行的...（有空有兴趣再写吧）

参考&扩展阅读：
[1] C++静态库与动态库 - 吴秦 - 博客园

[2] gcc/g++ 实战之编译的四个过程

[3] gcc编译器为什么不直接编译成机器代码？
</code></pre>
</details>

<details>
<summary>《图解UE4渲染体系》Part 0 引擎基础</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/493147444
在介绍UE4渲染体系前，我们有必要来先看一下UE4是用什么样的方式来构建游戏场景数据的。

1 Object
在UE4中当我们说Object，通常是指代引擎代码中的UObject类，它是引擎里管理绝大部分类和对象的基石，这是因为它提供了非常多的开发者需要的功能特性，例如元数据、反射、垃圾回收、序列化、编辑器支持等一系列功能。


与Unity中的物体容器GameObject相比（名字上类似），个人理解UObject存在更像是一种UE4提供的开发核心工具箱，各种需要高复用性的核心功能都集成到里面，不仅仅说场景里的各个物体需要用到UObject提供的功能，不可见的底层数据管理同样也需要使用到这些。

2 Actor
Actor通常指代引擎代码中的AActor类，所有可以放置到游戏场景中的"物体"都是一个Actor，例如角色、怪物、光(ALight)、场景(AStaticMeshActor)、摄像机(ACameraActor)等等。它提供的功能和Unity的GameObject就比较相似了，作为一个容器包含一个"物体"的各种内容，自然地AActor继承自UObject类，在UObject的基础上，还提供了网络同步、创建销毁、帧更新等功能。


对很多刚接触的开发者来说，可能Actor的名字看起来有点突兀，UE4并没有特别说明该名称的由来，个人理解，Actor单词本身的意思是演员，如果可以把游戏看作一场演出的话，其中就是各位出演角色各司其职，角色和怪物完成各种交互、光照(就像打光师)完成场景光照、场景物体可以各种移动变化、摄像机完成拍摄等等。


3 Component
Component通常指代引擎代码中的UActorComponent类，继承UObject，是所有组件类型的基类，通常挂载在Actor实例下，如同之前所介绍的，Actor本身是一个容器，而Actor具体的特性则由其具有的Component决定，如在世界场景中的位置旋转缩放(USceneComponent)、模样(UMeshComponent)等等。


Component对于Actor来说并不是必选的，可以存在没有组件的空Actor、不需要空间位置的Actor、不需要模样的Actor等等，这样在我们DIY自己需要的Actor时，就可以尽可能少地引入不需要的内容了。

4 Level
Level通常指代引擎代码中的ULevel，也被叫做关卡，是UE4中用于组织游戏场景的基本单位，由一系列可见和不可见的Actor组成，同时还包含Level自身的一些属性，比如关卡属性、关卡蓝图等等，和Unity中的Scene概念相通。


5 World
World，引擎代码中的UWorld，如果说Level代表场景，那World代表承载这个场景的世界，Level必须放在World中才能显示出其中的内容，对于一些以关卡切换来转换游戏场景的游戏来说，他们一个Level就是一个World，这样的概念可能有点多余，但是在很多开放世界的项目中，一个World同时可能不止一个Level，很多3A游戏的无缝多场景切换也是得益于流式关卡(Streaming Level)的使用。


6 Script
除了以上的基本概念，还有脚本(Script)存在于世界的各个Actor中，脚本可以用于给Actor添加不同的行为，脚本可以是C++定义编写的，也可是蓝图定义的，从功能上看，脚本和Component十分相像，但在UE4的组织形式上看，脚本并非是一种Component，而更像是一种对Actor的补充，从程序员角度来讲，就像是对Actor一些接口的覆写(Override)，例如自定义BeginPlay、Tick、EndPlay等（对应Unity中的Start、Update、End）时Actor应该有的操作。


顺带一提
你可能已经发现在提到引擎代码中的类名时，相比名称会多出一个前缀(Prefix)，这是UE4中一种编码规范，用来指代该类的类别：

T：模板类，例如TArray；
U：继承UObject的类；
A：继承AActor的类；
S：继承SWidget的类；
I：抽象界面类；
E：枚举；
F：其他多数类（不在UObject继承体系内）
参考文献
[1] 0向往0，剖析虚幻渲染体系（01）- 综述和基础
[2] UE4官方文档，Actor生命周期
[3] UE4官方文档，代码规范
</code></pre>
</details>

<details>
<summary>《UE4开发笔记》Tip 0 Rider的五个必备技巧</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/499847829
在UE4的C++工程和源码开发中，过去常使用Visual Studio系列来作为IDE，但VS始终对UE4工程支持的并不友好，小番茄Visual Assist X系列插件的安装也是十分玄学，时不时就失灵。


JetBrains推出了Rider For UE4，经过一段时间的试用，感觉在日常开发上可以完胜VS+VA的，虽然还在测试版本，可能经过近年来的打磨，基本上是没碰到过什么大毛病。

这里总结Rider在写代码时一些能够大大提高效率的功能，文章内附上的快捷键是在Visual Studio模式下的。


File → Settings→ KeyMap
1-编辑器快捷键
有时候在代码里需要新起一行，有时候需要在上方，有时候需要在下方，如果光标直接在行内，使用Enter会把一行拆断，所以我们常常是使用Home->Enter/End->Enter的两步方式实现，右手需要按两次，比较费事，这在Rider中是有快捷键的：

Ctrl+Enter：上方新起一行
Shift+Enter：下方新起一行
Ctrl和Shift的上下关系稍微有点反直觉，可以自行在Setting->KeyMap里修改。

其他的行编辑快捷键：

Ctrl+L：删除行
Ctrl+D：复制行/选中块
Ctrl+Alt+Shift+↑/↓：上下移动行（不破坏块结构，还蛮神奇，就是反应有时候有点慢）
除了Rider自身在代码左侧提供的代码块折叠功能，还可以手动选中需要折叠的区域，然后使用快捷键折叠：

Ctrl+M, H：折叠选中（Hide）
Ctrl+M, E：展开(Expand)
Ctrl+M, S：折叠(Shrink)
2-搜索快捷键

全局快速搜索(Search Everywhere)
双击Shift/Ctrl+T：全局快速搜索(Search Everywhere)（非常推荐使用），精简版的Find in Files，找一些项目里关键类的文件比较方便；
Ctrl+F：在文件中查找，文件中选中内容再搜索可以不用再填写搜索内容；
Ctrl+Shift+F：在所有文件中搜索，搜索速度会慢一点，但比快速搜索更全；
Ctrl+Shift+T：搜索文件，用于按名字搜索文件（快速搜索中自动包含该选项）；

快速搜索当前文件类/方法/成员
Alt+\：用于快速搜索当前文件内的一些类/方法/成员。
3-导航快捷键
除了用上面提到的文件内搜索方法来进行导航，还有一些文件内更加直接的快速导航的方法：

Ctrl+[：移到方法/类定义的第一行
Alt+↑：移动到上一个方法
Alt+↓：移动到下一个方法
Ctrl+G：移动到指定行/列号

结构视图(Structure)
一种比较特殊的文件内快速导航是结构视图(Structure)，可以以列表的方式直接查看当前文件内的类、方法、成员函数等的情况，打开的快捷键是Ctrl+Alt+F，也可以在左下角找到选项页按钮。

代码页(Tab)的导航快捷键：

鼠标中键单击Tab：关闭Tab页（就不用点小叉叉了）
Ctrl+F4：关闭当前Tab页（你甚至可以不用鼠标）
Alt+←/→：左右切换显示的Tab页
Ctrl+Tab：使用Switcher快速切换Tab页（类似于Windows的快速窗口切换）
Shift+F4：使用独立新窗口打开Tab页
文件级别的导航快捷键：


最近文件(Recent Files)
Ctrl+,：最近文件
Ctrl+Shift+,：最近修改过的文件

关联导航菜单
Alt+`：导航菜单（当前文件/选中内容）
Alt+Shift+L：在解决方案目录里定位当前文件
类/函数定义相关的导航快捷键：

F12：找到定义(Definition)/使用(Usage)
Shift+F12：查找使用(Usage)

快速展示使用的浮窗
Alt+Shift+F12：快速展示使用(Usage)
Ctrl+F12：查找实现(Implementation)
Ctrl+Shift+F11：找到类型声明(Type Declaration)
4-书签视图(Bookmarks)
在项目里阅读大量的代码时，经在各个文件各个函数中导航来导航去的，一来二去的就容易在其中迷失了自我，Rider提供了书签(Bookmarks)管理我们常去的代码位置或者一些传送门。


书签管理界面（当前无书签）
打开书签的快捷键：Alt+2，或者在编辑器左下角可以找到，这是所有书签的管理页，其中还有自定义书签名、添加书签列表等操作。


书签旗帜
Ctrl+K, K：在当前行添加普通书签，会看到行号旁边多出一个旗帜；

助记符选择界面

助记符书签
Ctrl+F11：添加有助记符号的书签，可以给这个书签添加一个助记符旗帜来代替普通的旗帜，更加有标示性；

书签列表浮窗
Ctrl+`：弹出一个书签列表浮窗，单击书签可以快速预览对应的代码内容。
5-继承视图(Hierarchy)
在想了解各个类之间的继承关系时，Rider提供了一个非常有用的功能，就是继承视图(Hierarchy)。


继承视图(Hierarchy)-父类(Supertypes)
选中需要查看的类，然后使用Ctrl+E, H就可以打开对应的继承视图，上面有两个选项比较关键，第一个是查看自己继承了哪些父类(Supertypes)，第二个是查看自己有哪些子类(Subtypes)。

使用继承视图要比自己一个个的按F12然后在各个文件之间脑补出各个类的继承关系要直接了当的多。

参考文章
[1]Rider官方使用文档 - JetBrains
</code></pre>
</details>

<details>
<summary>《图解UE4渲染体系》Part 1 多线程渲染</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/503787596
上回书 《Part 0 引擎基础》 说到，我们粗略地知道UE4是以哪些类来管理一个游戏场景里的数据的，但这仅仅是我们开始探索UE4渲染体系的一小步。

本回主要介绍UE4渲染体系中比较宏观顶层的一部分——多线程渲染，具体的多线程中，又分为：

游戏线程(GameThread)
渲染线程(RenderThread)
RHI线程(Render Hardware Interface Thread)

今日主角团
为什么是多线程？

完成渲染的基础过程
用来描述“渲染”的最基础的理论就是像图上的那样，CPU调用图形API提供的DrawCall命令（也叫绘制指令），在命令中说明需要渲染的数据、属性等等，然后CPU等待GPU返回渲染结果，完成渲染。对于那些渲染频率不高的场景，这种方式并没有什么问题，但在游戏这种需要实时性渲染的高频率场景下，问题就显现出来了。

游戏引擎完成渲染不只有提交DrawCall这一个任务，除了这个以外，CPU要花费非常多的时间在处理游戏逻辑运算和准备渲染数据上，比如处理用户的输入、执行游戏脚本、更新物理和动画、可见性剔除等等等等。


单线程下的游戏线程等待
假如引擎把所有的事都交由GameThread来完成，当GameThread把当前这一帧该做的事都做完了，准备好要渲染的数据，提交到GPU后，GameThread就只能等待渲染结果，但GameThread接受到当前这一帧的用户输入后，完全可以去执行下一帧的各种任务，但单线程的机制并不允许这样的事情。

多核心的CPU和多线程并发并行的操作系统在今天已经不是什么稀罕事了，将与渲染相关的任务从GameThread中剥离出来，让GameThread专注处理游戏逻辑上的的各种计算任务，让RenderThread专门和GPU来完成渲染任务，就成了自然而然的事情。


渲染线程从游戏线程中剥离出渲染任务
加入RenderThread后，每次GameThread处理完各种任务，准备好渲染数据，把数据发送给RenderThread，然后就继续处理下一帧的任务了，RenderThread收到数据，进行一些数据处理后（比如可见性剔除），向GPU提交DrawCall，等待渲染结果，完成渲染。

那RHIThread是什么呢？UE4中RHI的提出可能有很多原因：

支持跨平台多种图形API
并行提交DrawCall
其他各种各样的性能优化
首先是针对跨平台多种图形API，由于不同平台支持的图形API不同，Windows限定的Direct3D、MacOS限定的Metal以及跨平台(包括移动端)的OpenGL和Vulkan，在有RHIThread之前，RenderThread会根据不同的图形API来选择DrawCall，这肯定会增加不少工作量，维护也更加复杂。

"All problems in computer science can be solved by another level of indirection." —— Jay Black
如果把这件事交由单独的一个线程来做，岂不美哉？这不，RHIThread就来了。


RHI线程从渲染线程中剥离图形API维护
RenderThread准备好渲染数据后，向RHIThread提交一个与图形API无关的RHIDrawCommand，RHIThread掏出来一个表，查找当前平台的图形API里哪一句是对应的DrawCall，然后再向GPU提交DrawCall，等待渲染结果，完成渲染。这样一来，RenderThread就可以在自己的任务上专注（方便优化），在RHIThread上完成对各个平台的图形API版本迭代维护。


DrawCall阻塞等待现象
当然这是从工程优化角度上RHIThread存在的理由，当然RHI还有一些更加直接的存在理由，那就是为了支持并行化提交DrawCall。在一些比较旧的图形API里，DrawCall都是阻塞的，即一个线程提交DrawCall时，不允许其他线程提交。图形API调用GPU计算后，GPU本身计算渲染是需要时间的，而在这时间里，图形API如果能准备好下一次DrawCall，那必然是更好的。


并行化的DrawCall提交
随着技术更新，一些新的图形API开始提供一些并行化提交DrawCall的方式，在没有RHI的时候，难道让UE4跑多个RenderThread吗？好像也不太合理，RenderThread里面除了提交DrawCall的其他部分也不需要多个线程来完成，那需要单独提出来多线程化的任务就顺理成章地变成了RHIThread了。

总结
可以看到UE4渲染体系中多线程渲染的设计并不是一开始就是这样，而是跟随着技术的需求在不断发展进步的（新的UE5里面估计又改了不少了）。

本回并没有着重讨论各种线程内部细节的任务，也没有非常深入的讲解各个线程之间是如何传递具体的命令和数据的，因为讲起来那篇幅真的就太长了，之后再慢慢地整理吧，网络上的资料也很多，大家可以自行拓展阅读。

参考文献
[1] 可可西, UE4之Game、Render、RHI多线程架构, 博客园
[2] 0向往0, 剖析虚幻渲染体系（02）- 多线程渲染, 博客园
[3] 醉里挑灯看剑, Unreal Engine中的RHI线程, 知乎
[4] leonwei, 基于UE4的多RHI线程实现, CSDN
</code></pre>
</details>

<details>
<summary>《UE4开发笔记》Tip 1 编译完全指南</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/509308558
在UE4的蓝图项目里，所有的编译任务都在编辑器(Editor)中来完成，对蓝图的编辑只需要点击编辑器内置的编译(Compile)按钮就可以，一切看起来那么和谐。


但在UE4的C++项目里，编译这件事就开始变得魔幻起来了，IDE(VS/Rider)里面有提供编译，编辑器里面又有提供编译，这些编译涉及到的东西可能就不是点一个按钮那么简单了。

本次编写的编译指南主要包含以下3个和编译相关的常见问题：

IDE中不同的编译选项有什么不同？是用Development Editor？还是DebugGame？…；
Hot Reload和Live Coding；
在修改源码的引擎的项目里，编译总是会把引擎源码也一起编译了（时间老长了）？如何避免这样的问题？
1 不同的编译选项？

在IDE里面，能看到UE4默认的Development Editer Win64编译选项，点开下拉栏我们能看到更多的选项（不得不吐槽一句Rider的选项组织方式），大部分人在开发的时候基本上也就是使用默认的选项了，不过作为一名合格的工程师，刨根问底是我们的天性，所以其他选项和默认选项到底有什么不同呢？


这事吧，其实UE4官方文档也有写，但UE4官方维护的文档一直有个毛病就是：读的都是字，连起来就看不懂了。四处翻找了一些资料过后，找了一些民间比较通俗的解释来“补充”一下文档里各个编译选项的意思。




首先编译选项的名字分为三部分：

第一部分是状态(State)，表示当前引擎和项目的开发状态，分为Debug、DebugGame、Development、Shipping以及Test；
第二部分是目标(Target)，表示当前编译运行的程序的目标（比如要做什么），分为Empty(也就是空)、Editor、Client以及Server；
第三部分也比较好理解，就是平台(Platform)，指编译运行的目标平台。
状态(State)：

Debug：同时在引擎和游戏项目的编译中包含用于调试的符号(debug symbols)，适合用于在IDE中调试C++的代码（引擎或者游戏项目），可以完整的看到调试过程中的代码流程和变量数据内容；
DebugGame：对引擎代码进行优化编译，只在游戏项目的编译中包含用于调试的符号，适合用于只调试游戏代码；
Development：默认选项，不对代码进行优化编译，虽然也可以Debug，但是调试过程中可能会出现部分代码跳过（被优化），部分变量的数据内容显示不完整等问题；
Shipping：最佳性能的编译配置，用于游戏发布的编译，不包含任何开发相关的编译内容引入。
Test：相比Shipping来说，只是启用了一些控制台命令、统计数据和性能分析工具，适合用于最终产品测试场景。
目标(Target)：

Empty：空就是指那些没有第二部分的编译选项，比如DebugGame Win64，只编译构建游戏项目的独立可执行版本，但需要提前对当前平台进行内容的烘焙(Cook，在编辑器中执行)；只包含客户端(Client)和服务器(Server)的代码，不包含编辑器(Editor)（所以就不会启动编辑器了）；
Editor：包含所有代码(Editor/Client/Server)，代表是在项目开发阶段，你会使用编辑器来编辑运行项目，编译运行后会启动编辑器打开项目；
Client：只包含客户端的代码，在一些UE4的联网多人游戏项目里面会使用到；
Server：只包含服务器的代码，在一些UE4的联网多人游戏项目里面会使用到。
总结来看：

在日常编辑器中的开发时，如果需要对一些代码进行比较细致的调试，如果Development Editor无法解决，那就尝试使用Debug Editor或者DebugGame Editor；
在仅编译可执行程序时，应该选用Empty目标的编译选项，不过需要提前在编辑器中对游戏项目进行烘焙(Cook)，因为IDE中的编译并不会对游戏项目的素材进行处理（看成是数据包部分）；
Shipping用于发布，性能最好，Test用于在Shipping的基础上进行最小程度的后续测试。
2 Hot Reload？Live Coding!

当使用XXX Editor的选项进行编译运行后，会启用编辑器打开当前的游戏项目，你可以在其中对游戏进行配置、搭建等等，如果只是对里面的一些蓝图进行修改，还是可以只通过Compile编译按钮来解决，但是如果修改了C++代码呢？你可能会发现编译按钮也能帮你把C++里面的修改实时反应到编辑器里。


这其实归功于UE4中的热重载(Hot Reload)功能，在没有这个功能前，C++项目的开发只能先关掉编辑器，然后重新在IDE中编译项目，再重启编辑器，这一套流程想想也是非常耗时的（要不然为什么有蓝图呢？）。

在这些情况下你会触发UE4编辑器的热重载功能：

在编辑器(Editor)打开的情况下，在IDE中编译项目（仅编译项目）；
使用编辑器中的编译(Compile)按钮；
在编辑器中新建一个C++类（可以不启用）。
热重载的功能无疑加快了开发的速度，但在使用过程中，大家也陆续发现了不少问题，比如在一些特定操作流程下，热重载会导致一些与修改过的C++代码相关的蓝图保存后，关闭编辑器重启，会看到这些蓝图其中的内容和保存前并不一样（更多情况下是失效了，只能通过版本回退来解决），尽管热重载在大多数情况下表现正常，但其中存在的问题对很多人来说还是有不少的影响。


UE4也是为了有一套更加“完美”的C++开发方案，在4.22版本推出了另一种方法：Live Coding(实时编程？)，在编译按钮的下拉栏中可以看到这个方法默认没有被启用，“目前”这还是一个实验中(Experimental)的方法（最新的UE5中也仍然是），但在大家的试用下，这已经是一套比较稳定的方法了。

Live Coding是UE4基于Live++技术开发的一套实时编译方案，这项技术能保证修改的C++代码在编辑器中实时正确编译，并且不会有热重载那样会导致各种各样的隐藏问题，这项技术甚至能让你在编辑器运行游戏(PIE，Play in Editor)时，让修改的代码内容实时反应到运行的游戏中。


在Compile中开启Live Coding后，需要手动地在IDE中重新编译一遍项目，以确保热重载生成的相关文件被清除(Build日志中可以看到上面的日志内容)。


编译项目并重启编辑器会看到会多出一个Live Coding的CompileLog窗口（可以设置隐藏），在你修改完项目中的C++代码后，按下Ctrl+Alt+F11就可以启动Live Coding的编译流程，然后只需要等待编译结束（编译失败并不会导致崩溃，会提示错误信息），修改的内容就会实时地反应到编辑器中，这个快捷键是全局的，无论是否在编辑器，这个快捷键都可以触发启动，你也可以手动地点编辑器中的Compile按钮来启动，这并不会触发热重载，因为这时热重载已经被关闭了。

但这个技术被叫做实验性也是有一定原因的，在UE4中还是有一些限制，比如：

难以实时修改.h头文件中的代码；
难以实时修改.cpp文件中的类构造函数。
难以实时修改仅仅指的是他们的修改和编译很有可能无法反应到编辑器中，并不会导致编辑器崩溃，也不会干扰正常编译，只是不会达到预期效果，从而让你感觉出了Bug似的。想要这些修改内容生效的话，就需要关闭编辑器，在IDE中重新编译一遍项目，再使用编辑器打开，这也是Live Coding目前来看唯一的“不方便”了，但足以应付绝大多数的开发情况（初期搭建项目结构的时候会头疼一点，推荐使用热重载）。


Live Coding的这些问题，目前看来有希望在UE5中逐步解决，在新的UE5中已经加入了Reinstancing技术来改善这一问题，具体可以看UE5的官方文档。

总结来说：

热重载(Hot Reload)仍然是UE钦定的默认编译方式，毕竟在大部分情况下他都是正常的，适合在快速项目初期进行使用，避免反复的重启编辑器，拖延开发进度，但这一功能在未来大概率是会被UE淘汰掉的；
Live Coding能够较为完美的完成任务（在一定的限制条件下），它甚至能在游戏运行时编译代码修改的内容，编译速度更快，这一方式将随着问题的解决而逐渐成为主流。
3 如何不编译引擎源码？
对于那些仅仅使用Epic启动器安装引擎的开发者来说，可以忽略这一小节，因为这个问题只会出现在自己编译UE4源码的时候…

编译引擎源码通常需要很长时间，性能差一点的花个小半天，性能好一点一个小时以内（主要取决于CPU核心数量和硬盘访问速度），当你编译好引擎源码后，使用引擎创建一个C++项目，然后使用IDE打开这个项目，一切照常，当你点下开始编译的按钮后，奇怪的事发生了：怎么又开始重新编译引擎了！


这是为什么呢？参考文章《定制UE4引擎，如何避免…》，可以发现这主要是因为预编译版引擎和源码编译版引擎在创建项目时，创建项目工程文件时有不同的操作，如果是源码编译版引擎，则会在项目工程中引入引擎的所有工程（如下图）。


那么如何避免呢？还是有方法的，参考文章里的原理，引擎在创建项目时，会判断引擎是预编译版本(Binary Build)还是源码编译版本(Source Build)，判断的方法是检测引擎%Engine-Folder%\Engine\Build路径下的文件夹里是否有以下两个文件之一：

InstalledBuild.txt：代表是预编译版本；
SourceDistribution.txt：代表是源码编译版本。



文件本身是空的，其实改一下名字就行（其实可以写个脚本），修改文件名过后，游戏项目工程本身还是没有修改的，所以还要重新生成一下游戏项目工程，右键项目的.uproject文件，选择Switch Unreal Engine Version，然后就会自动生成新的工程文件，Rider中会检测到文件更新，并更新项目结构（VS还没有测试过），切换到Binary Build下的项目就不会再引入引擎的编译了。

参考文献
[1]Shadowriver, Differences between build configurations, UE4-Forms
[2]UE4官方文档, 编译游戏项目
[3]风之神韵老师, UE4的编译配置详解
[4]Unreal Engine Community Wiki, Hot Reload and Live Coding
[5]UE5官方文档, Live Coding
[6]天空游荡的鱼, 定制UE4引擎，如何避免C++项目重编引擎
</code></pre>
</details>