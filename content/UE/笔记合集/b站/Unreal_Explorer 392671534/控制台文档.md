
<details>
<summary>【UE4】控制台文档—上</summary>
<pre><code>
https://www.bilibili.com/read/cv12369392/
r.AccelPredrawBatchTime r.PredrawBatchTime覆盖值显示加载屏幕或类似的时候，玩家不会注意到，或0使用r.PredrawBatchTime。默认为0。
r.AccelTargetPrecompileFrameTime r.TargetPrecompileFrameTime在显示加载屏幕或类似的时候覆盖r.TargetPrecompileFrameTime的值，以在播放器不会注意的时候做更多的工作，或者0使用r.TargetPrecompileFrameTime。默认为0。
r.AllowCachedUniformExpressions 允许统一表达式被缓存。
r.AllowDepthBoundsTest 如果为true，则在渲染光照灯时使用启用深度边界测试。
r.AllowDownsampledStandardTranslucency 允许标准半透明度以较小的分辨率呈现为优化
这与使用混合调制的材料不兼容。用2来忽略这些。
<0：关
0：打开，除非使用混合调制的材料被使用（默认）> 0：打开并忽略使用混合调制的任何材料
r.AllowGlobalClipPlane 使网状着色器支持平面反射所需的全局剪切平面，这在PS4上增加了大约15％的BasePass GPU成本。
r.AllowLandscapeShadows 允许风景阴影
r.AllowOcclusionQueries 如果为零，则遮挡查询将不会用于剔除原语。
r.AllowPointLightCubemapShadows 当0时，将防止点光源立方体贴图阴影被使用，光线将被遮蔽。
r.AllowPrecomputedVisibility 如果为零，则预先计算的可见性将不会用于剔除原语。
r.AllowSimpleLights 如果这是真的，我们允许简单的（即粒子）灯
r.AllowStaticLighting 是否允许生成和使用任何静态光照，如光照贴图和阴影贴图。
仅使用动态照明的游戏应将其设置为0以节省一些静态照明开销。
r.AllowSubPrimitiveQueries 启用子基元查询，当前仅由层次实例化静态网格使用。1：启用，0禁用。禁用时，整个代{过}{滤}理使用一个查询。
r.AllReceiveDynamicCSM 哪些原语应该只接收动态的CSM阴影。0：只有标记为bReceiveCSMFromDynamicObjects的基元。1：所有原语（默认）
r.AlsoUseSphereForFrustumCull 性能调整。如果> 0，则在用于平截头体剔除的盒子之前使用球体剔除。
r.AmbientOcclusion.AsyncComputeBudget 定义使用EAsyncComputeBudget的哪个级别来平衡AsyncCompute与Gfx的工作。
只有当SSAO的计算版本处于活动状态（需要CS支持，由cvar启用，单向传递，不支持正常）时，
这个问题才是重要的。这是一个低级别的开发人员调整，以在支持AsyncCompute的硬件上获得最佳性能。
0：最少AsyncCompute
1：…（默认）
2：…
3：…
4：大部分AsyncCompute
r.AmbientOcclusion.Compute 如果SSAO应该使用ComputeShader（不适用于所有平台）或PixelShader。
[异步]计算着色器版本是在制品，没有优化，需要硬件支持（不是移动/ DX10 / OpenGL3），
不使用正常，允许它在EarlyZPass后运行（与AyncCompute
一起使用时性能更好）AyncCompute目前仅功能在PS4上。
0：PixelShader（默认）
1：（WIP）如果可能的话使用ComputeShader，否则回退到0
2：（WIP）如果有效则使用AsyncCompute，否则回落到1
3：（WIP）如果可能的话使用AsyncCompute，否则回落到’1’
r.AmbientOcclusion.FadeRadiusScale 允许缩放环境光遮蔽衰落半径（SSAO）。
0.01：最小… 1.0：正常（默认），<1：小，> 1：大
r.AmbientOcclusionLevels 定义在环境遮挡计算过程中使用多少个mip级别。调整算法时这很有用。
<0：根据后处理设置/音量和r.AmbientOcclusionMaxQuality中的质量设置决定（默认）
0：无（禁用AmbientOcclusion）
1：一个
2：2（成本额外的性能，软加法）
3：三少但可以闪烁）
r.AmbientOcclusionMaxQuality ScreenSpace Ambient Occlusion
100中的后过程音量质量级别定义最大限制值：不超过后过程音量的质量级别（默认）
0…99：将后处理音量的质量级别限制为最大设置通过此cvar
-100…0：即使postprocessvolume要求较低的质量，也执行不同的质量（绝对值）。
r.AmbientOcclusionMipLevelFactor 根据SSAO步骤ID控制mipmap级别
0：总是查看HZB mipmap级别0（内存缓存垃圾）
0.5：样本数量取决于后处理设置（默认值）
1：进入更高的mipmap级别（质量损失）
r.AmbientOcclusionRadiusScale 允许缩放环境遮挡半径（SSAO）。
0：关，1.0：正常，<1：小，> 1：大
r.AmbientOcclusionStaticFraction 允许覆盖Ambient Occlusion静态分数（请参阅后处理量）。分数在0和1之间。
<0：使用默认设置（默认-1）
0：对静态光照没有影响，0是空闲的，意味着没有额外的渲染通过
1：AO影响统计照明
r.AMDD3D11MultiThreadedDevice 如果这是真的，在AMD硬件上创建一个多线程的D3D11设备（解决驱动程序bug）。
更改只会在新游戏/编辑器实例中生效 - 不能在运行时更改。
r.AMDDisableAsyncTextureCreation 如果为true，则在AMD硬件上使用同步纹理创建（解决驱动程序错误的方法）
更改将仅在新的游戏/编辑器实例中生效 - 不能在运行时更改。
r.Android.DisableOpenGLES31Support 禁用对OpenGLES 3.1 API的支持。（仅适用于Android）
0 =使用OpenGLES 3.1 API（提供设备和项目支持）[默认]
1 = OpenGLES 3.1将被禁用，OpenGL ES2将被使用。
r.Android.DisableVulkanSupport 禁用对vulkan API的支持。（仅适用于Android）
0 =将使用vulkan API（提供设备和项目支持）[默认]
1 =禁用vulkan，将使用opengl回退。
r.AndroidDisableThreadedRendering 设置是否允许对特定Android设备配置文件进行线程渲染。
0 =允许线程渲染[默认]
1 =禁止在启动时创建渲染线程
r.AOApplyToStaticIndirect 是否将DFAO应用于间接遮蔽，即使对于静态间接来源（光照贴图+固定天窗+反射遮挡）
r.AOAsyncBuildQueue 是否异步构建网格的距离场体积数据。
r.AOClearHistory
r.AOComputeShaderNormalCalculation 是否使用距离场正常计算的计算着色器版本。
r.AOGlobalDFClipmapDistanceExponent Exponent用于派生每个剪贴图的大小，以及r.AOInnerGlobalDFClipmapDistance。
r.AOGlobalDFResolution 全球距离场的解析。较高的值会增加保真度，但也会增加内存和组成成本。
r.AOGlobalDFStartDistance 沿着圆锥轨迹的世界空间距离切换到使用全局距离场而不是物距距离场。
这必须足够大，以隐藏全球距离场的低分辨率性质，但较小的值会导致更快的锥体追踪。
r.AOGlobalDistanceField 是否使用全局距离场来优化遮挡锥轨迹。
全景距离场是通过在观看者在关卡中移动时将对象距离场合成为剪贴图而创建的。
r.AOGlobalDistanceFieldCacheMostlyStaticSeparately 是否主要将静态基元与可移动基元分开进行缓存，这在可移动基元被修改时降低了全局DF更新成本。添加另外12Mb的体积纹理。
r.AOGlobalDistanceFieldLogModifiedPrimitives 是否记录引起全局距离字段更新的原始修改（添加，删除，更新转换）。
这对于追踪为什么更新全局距离字段总是花费很多，因为它应该大部分被高速缓存。
r.AOGlobalDistanceFieldPartialUpdates 是否允许部分更新全球距离场。分析时，禁用这个功能是非常有用的，并且可以在相机切割时获得最差的合成时间。
r.AOGlobalDistanceFieldRepresentHeightfields 是否把景观放在全球的距离场。改变这个不会传播，直到全球距离领域获得（飞回去）。
r.AOGlobalDistanceFieldStaggeredUpdates 是否允许较大的剪贴图更新频率较低。
r.AOHeightfieldOcclusion 是否从高度场（景观）计算AO
r.AOHistoryDistanceThreshold 放弃上一帧的DFAO结果所需的世界空间距离阈值。靠近墙壁时，较低的值可减少字符的重影，但会增加闪烁的伪影。
r.AOHistoryMinConfidenceScale 最小的信心可以减少历史的重量。将AO值从前景插值到背景上的像素错误地置信度为0.
值为1时，置信度被有效地禁用。对于低置信度的像素，较低的值会增加AO历史记录的收敛速度，但会引入抖动（历史记录被丢弃）。
r.AOHistoryStabilityPass 是否收集稳定的结果来填补时间重投影中的空洞。增加了一些GPU的成本，但提高了树叶的时间稳定性。
r.AOHistoryWeight 最后一帧的AO数量到最后的结果。较高的值增加稳定性，较低的值在遮挡物运动下具有较少的条纹。
r.AOJitterConeDirections
r.AOListMemory
r.AOListMeshDistanceFields
r.AOLogObjectBufferReallocation
r.AOMaxObjectBoundingRadius 大于此的对象将不会影响AO计算，从而提高性能。
r.AOMaxObjectsPerCullTile 确定在距离字段对象剔除数据结构中应该分配多少内存。太多=内存浪费，太少=由于缓冲区溢出闪烁。
r.AOMaxViewDistance AO计算的最大距离。
r.AOOverwriteSceneColor
r.AOSampleSet 0 =原始设置，1 =放松设置
r.AOScatterTileCulling 是否使用光栅化器将遮挡物对象合并到屏幕空间瓦片中。
r.AOSpecularocclusionMode 确定DFAO应该如何遮挡镜面
0：对镜面反射应用无方向的AO。
1 :(默认）将反射锥与由DFAO产生的未被遮挡的锥相交。这给出比0更准确的遮挡，但可以引出DFAO采样伪像。
r.AOStepExponentScale 指数用于沿圆锥方向分布AO样本。
r.AOUpdateGlobalDistanceField 是否更新全球距离场，对调试有用。
r.AOUseConesForGI
r.AOUseHistory 是否对距离场AO应用时间滤波器，这减少了闪烁，但也增加了遮挡物移动时的轨迹。
r.AOUseJitter 是否对Screen Grid DFAO使用4x时间超采样。当禁用抖动时，可以使用较短的历史记录，但会有更多的空间混叠。
r.AOViewFadeDistanceScale 当AO接近r.AOMaxViewDistance时AO会淡出的距离，为r.AOMaxViewDistance的一小部分。
r.AsyncPipelineCompile 0在请求时创建PSO
1 1异步创建管道状态对象（默认）
r.Atmosphere 定义气氛将呈现与否。仅由r.Atmosphere控制台命令更改。
启用/禁用Atmosphere，加载/卸载相关数据。
0：关闭（节省GPU内存）
1：开启（默认）
r.BasePassOutputsVelocity 启用在基本传递中呈现WPO速度。
0：渲染一个单独的pass / rendertarget，所有可移动的静态网格+动态。
1：在常规基础阶段渲染，添加一个额外的GBuffer，但允许基于时间的WPO的材质运动模糊。
r.BasePassWriteDepthEvenWithFullPrepass 0允许一次只读基本遍，它跳过一个MSAA深度解析，并允许被掩盖的材料获得EarlyZ（在clip（）时写入深度禁用EarlyZ）（默认）
1强制在基本遍中进行深度写入。当预备和基础阶段不匹配他们呈现的内容时，用于调试。
r.BinaryShaderCacheLogging 在项目中记录重复的着色器代码条目，并在生成二进制着色器缓存时报告着色器代码的详细信息。默认为0。
r.BlackBorders 为了在渲染图像周围绘制黑色边框
（防止后处理遍历，例如PostProcessAA中读取的伪像）
像素，0：关闭
r.Bloom.Cross 实验性的特点，使花苞内核更明亮的中心样本（1和3之间的值工作，而不会造成混叠）
现有的花绽降低匹配相同的亮度
<0为全息镜头耀斑样貌（仅限X）
0关闭（默认）
0十字形（X和Y）
r.Bloom.HalfResoluionFFT 实验半分辨率FFT Bloom卷积。
0：标准全分辨率卷积布卢姆。1：排除核心中心的半分辨率卷积。
r.BloomQuality 0：关闭，没有性能影响。
1：平均质量，性能影响最小。
2：平均质量，性能影响最小。
3：质量好。
4：质量好。
5：最好的质量，最显着的性能影响。（默认）
5：强制移动实验质量更高（在某些硬件上可能会很慢）
r.BufferVisualizationDumpFrames 当请求屏幕截图或电影转储时，也保存当前缓冲区可视化材料的转储
0：关闭（默认）
1：开启
r.BufferVisualizationDumpFramesAsHDR 当以HDR格式保存缓冲可视化材料时
0：不要覆盖默认的保存格式。
1：强制HDR格式缓冲可视化材料。
r.BufferVisualizationOverviewTargets 指定缓冲可视化概述中可以使用的后处理物料列表。在逗号之间不要留下任何空隙。
选择：
BaseColor
CustomDepth
CustomStencil
FinalImage
ShadingModel
MaterialAO
金属
透明度
粗糙度
SceneColor
SceneDepth
SeparateTranslucencyRGB
SeparateTranslucencyA
镜面
SubsurfaceColor
WorldNormal
AmbientOcclusion
CustomDepthWorldUnits
SceneDepthWorldUnits
PreTonemapHDRColor
PostTonemapHDRColor
r.BufferVisualizationTarget 当视口视图模式设置为“缓冲可视化”时，该命令指定要显示的各个通道中的哪一个。输入的值不是下面显示的允许值，将被忽略。
BaseColor
CustomDepth
CustomStencil
FinalImage
ShadingModel
MaterialAO
金属
透明度
粗糙度
SceneColor
SceneDepth
SeparateTranslucencyRGB
SeparateTranslucencyA
镜面
SubsurfaceColor
WorldNormal
AmbientOcclusion
CustomDepthWorldUnits
SceneDepthWorldUnits
PreTonemapHDRColor
PostTonemapHDRColor
r.Cache.DrawDirectionalShadowing 是否绘制由Lightmass生成的直接阴影采样点。
0关闭（默认），1打开
r.Cache.DrawInterpolationPoints 是否绘制间接光照在更新时插入的位置，这些位置存储在缓存中。
可能需要’r.CacheUpdateEveryFrame 1’也是有用的，否则点将会闪烁，因为他们更新。
0关闭（默认），1打开
r.Cache.DrawLightingSamples 是否绘制由Lightmass生成的间接照明采样点。
0关闭（默认），1打开
r.Cache.LightingCacheDimension 照明缓存的尺寸。这应该是r.LightingCacheMovableObjectAllocationSize的最大浪费的倍数。
r.Cache.LightingCacheMovableObjectAllocationSize 用于点亮动态对象的插值样本体积的分辨率。
1或2的值将导致每个对象的单个插值样本不能在移动下提供连续的光照，所以随着时间插入。
3或更多的值支持必要的填充以在移动中提供连续的结果。
r.Cache.LimitQuerySize 0关闭，1打开（默认）
r.Cache.QueryNodeLevel 照明样本八叉树的级别，其节点范围应该是针对八叉树查询的目标大小。
如果原始块大于0，则原始块将被分解为多个八叉树查询.0是根，12是叶级别
r.Cache.ReduceSHRinging 是否修改间接照明缓存SH采样以减少振铃。0关闭，1打开（默认）
r.Cache.SampleTransitionSpeed 使用单个样本照明时，控制两个点样本之间的转换速度（随时间推移而渐变）。
r.Cache.UpdateEveryFrame 是否每帧更新间接照明缓存分配，即使它们已被缓存。0关闭（默认），1打开
r.Cache.UpdatePrimsTaskEnabled 为ILC原语更新启用线程。将与其余的InitViews结尾重叠。
r.CapsuleIndirectConeAngle 当间接阴影方向来自预先计算的间接照明（不存在固定的天窗）时，使用的光源角度
r.CapsuleMaxDirectOcclusionDistance 来自胶囊的直接阴影的最大投射距离。这对性能有很大的影响。
r.CapsuleMaxIndirectOcclusionDistance 来自胶囊的间接阴影的最大投射距离。这对性能有很大的影响。
r.CapsuleMinSkyAngle 从预先计算的未被遮挡的天空矢量导出的最小光源角度（存在固定的天窗）
r.CapsuleShadowFadeAngleFromVertical 从垂直角度开始淡出间接阴影，以避免自我阴影伪影。
r.CapsuleShadows 是否允许在启用bCastCapsuleDirectShadow或bCastCapsuleIndirectShadow的皮肤组件上隐藏胶囊。
r.CapsuleShadowsFullResolution 是否以全分辨率计算胶囊阴影。
r.CapsuleSkyAngleScale 对从预先计算的未被遮挡的天空向量（存在的固定天窗）导出的光源角度进行缩放，
r.CatmullRomEndParamOffset catmul rom端点的参数偏移量。
r.CheckSRVTransitions 在设置SRV时，呈现目标的测试会正确过渡到SRV。
r.ClearCoatNormal 0禁用清除涂层正常。
0：关
1：开
r.ClearSceneMethod 选择如何在游戏模式下清除缓冲区（只影响延迟着色）。
0：没有清除
1：RHIClear（默认）
2：最大z处的四倍数
r.Color.Max 允许在颜色分级之后定义颜色通道中值1.0所映射到的位置。
值应该在1左右，较小的值会使高光变暗，较大的值会向白色移动更多的颜色，默认值：1
r.Color.Mid 允许定义在颜色分级之后颜色通道中的值0.5被映射到的位置（这与伽马校正类似）。
值应该在0.5左右，较小的值会使中间色调变暗，较大的值会使中间色调变亮，默认值：0.5
r.Color.Min 允许在颜色分级之后定义颜色通道中的值0被映射到的位置。
值应该在0左右，正值：灰度加到黑暗中，负值：更黑的值变黑，默认值：0
r.CompileMaterialsForShaderFormat 启用时，除了正在运行的平台之外，还将编译这种着色器格式的材料。
请注意，这些着色器已编译并立即抛出。这仅在通过r.DebugDumpShaderInfo直接检查输出时才有用。
r.CompileShadersForDevelopment 将其设置为0允许发布具有更多优化着色器的游戏，因为某些
编辑器和开发功能不再编译到着色器中。
注意：这应该在运输时完成，但是它还没有自动完成（功能需要成熟
，着色器将会随着着色器从开发缓存中不被共享而变慢）。
不能在运行时更改 - 可以放入BaseEngine.ini
0：关闭，着色器可以运行得更快
1：开启（默认）
r.CompositionGraphDebug 执行此命令可获得一帧合成图（后期处理和照明）的单帧转储。
r.CompositionGraphOrder 定义CompositionGraph中的节点以何种顺序执行（影响后处理和某些照明）。
选项1提供了更多的控制，这可以用来保存ESRAM，避免GPU同步，聚集性能计算着色器和控制AsyncCompute。
0：以root开始的树顺序，首先是所有输入，然后是依赖关系（传统UE4，未连接的节点没有执行）
1：RegisterPass（）调用顺序，除非依赖项（输入和附加）需要不同的顺序因为它提供更多的控制，执行所有注册的节点）
r.ContactShadows 0：禁用。
1：启用。
r.CopyLockedViews 将所有锁定的视图复制到r.LockView将接受的字符串中以重新加载它们。
r.CreateShadersOnLoad 是否在负载上创建着色器，这可以减少挂接，但使用更多的内存。否则，将根据需要创建它们。
r.CustomDepth 0：禁用功能
1：启用功能，按需创建纹理
2：启用功能，直到需要时才释放纹理（如果功能不应停止，则应为项目设置）
3：功能已启用，模板写入启用，纹理不释放，直到需要（应该是项目设置，如果功能不应该停滞）
r.CustomDepth.Order 当CustomDepth（和CustomStencil）得到渲染时
0：在GBuffer之前（对于AsyncCompute可以更高效，允许在DBuffer中使用pass，没有GBuffer混合贴花允许GBuffer压缩）
1：Base Pass（默认）
r.CustomDepthTemporalAAJitter 如果禁用，引擎将从自定义深度通行证中删除TemporalAA抖动。只有使用TemporalAA时才有效果。
r.D3D.RemoveUnusedInterpolators 在编译D3D的管道时启用删除未使用的插补器模式。
-1：不要实际删除，但让应用程序认为它（用于调试）
0：禁用（默认）
1：启用删除未使用
r.D3DCheckShadersForDouble 启用检查D3D微码的使用双。这在所有D3D11卡上都是不允许的。
0：不检查更快的编译
1：启用检查和错误，如果找到（默认）
r.D3DDumpAMDCodeXLFile 当启用r.DumpShaderDebugInfo时，这将生成一个运行CodeXL的批处理文件。
0：不生成额外的批处理文件（默认）
1：启用生成额外的批处理文件
r.D3DDumpD3DAsm 当启用r.DumpShaderDebugInfo时，这将生成一个带有fxc程序集的文本文件。
0：不生成额外的文件（默认）
1：启用生成额外的反汇编文件
r.DBuffer 启用DBuffer贴花材质混合模式。
DBuffer贴花在基本通过之前被渲染，允许它们正确地影响静态照明和天窗。
启用后，将强制执行完整的预备，这会增加CPU / GPU成本。几个纹理查找将在基础通道中完成，以获取贴图属性，从而添加像素工作。
0：关
1：开（默认）
r.DebugActionZone.ActionRatio 在没有定义的安全区域（0…1）的平台上，由FDisplayMetrics :: GetDisplayMetrics返回的操作区域比率
默认值：1.0
r.DebugSafeZone.Mode 安全区域可视化模式（0…2）
0：禁用（默认）
1：显示标题安全区域
2：显示操作安全区域
r.DebugSafeZone.OverlayAlpha 安全区域覆盖（0…1）的alpha值
默认为0.2
r.DebugSafeZone.TitleRatio 在没有定义安全区域（0…1）的平台上，FDisplayMetrics :: GetDisplayMetrics将返回的安全区域比率
默认值：1.0
r.Decal.FadeDurationScale 缩放每贴花淡出持续时间。较低的值会缩短使用寿命并缩短使用时间。默认值是1.0f。
r.Decal.FadeScreenSizeMult 控制每个贴花淡入淡出的屏幕大小。与每贴花屏幕尺寸淡入阈值相乘。较小意味着贴花淡化不那么积极。
r.Decal.GenerateRTWriteMaskTexture 打开或关闭贴图RT写入掩码纹理的生成
r.Decal.StencilSizeThreshold 控制每个贴花模板的通行证，允许更大（屏幕空间）贴花更快。它增加了每个贴花的开销，所以这个
<0：优化被禁用
0：优化被启用无论多么小（屏幕空间）贴花是
0…1：优化被启用，值定义触发的最小尺寸（屏幕空间）优化（默认0.1）
r.DefaultFeature.AmbientOcclusion 环境遮挡的引擎默认值（项目设置）是（后处理音量/摄像机/游戏设置仍然可以覆盖）
0：关闭，设置AmbientOcclusionIntensity为0
1：打开（默认）
r.DefaultFeature.AmbientOcclusionStaticFraction 引擎默认（项目设置）为AmbientOcclusion（后处理音量/摄像头/游戏设置仍然可以覆盖）
0：关闭，将AmbientOcclusionStaticFraction设置为0
1：打开（默认，花费额外的通行证，只有在有一些烘烤的照明时有用）
r.DefaultFeature.AntiAliasing 引擎默认（项目设置）AntiAliasingMethod是（后处理音量/摄像头/游戏设置仍然可以覆盖）
0：关（无抗锯齿）
1：FXAA（快于TemporalAA，但非静态情况下更闪烁）
2：TemporalAA默认）
3：MSAA（仅限正向着色）
r.DefaultFeature.AutoExposure AutoExposure的引擎默认（项目设置）是（后处理音量/摄像头/游戏设置仍然可以覆盖）
0：关闭，将AutoExposureMinBrightness和AutoExposureMaxBrightness设置为1
1：on（默认）
r.DefaultFeature.AutoExposure.Method 自动曝光方法的引擎默认值（项目设置）（后处理音量/相机/游戏设置仍然可以覆盖）
0：基于直方图（需要计算着色器，默认值）
1：基本自动曝光
r.DefaultFeature.Bloom Bloom的引擎默认值（项目设置）是（后处理音量/摄像头/游戏设置仍然可以覆盖）
0：关闭，将BloomIntensity设置为0
1：打开（默认）
r.DefaultFeature.LensFlare LensFlare的引擎默认（项目设置）是（后处理音量/相机/游戏设置仍然可以覆盖）
0：关闭，将LensFlareIntensity设置为0
1：开启（默认）
r.DefaultFeature.MotionBlur MotionBlur的引擎默认值（项目设置）是（后处理音量/相机/游戏设置仍然可以覆盖）
0：关闭，将MotionBlurAmount设置为0
1：打开（默认）
r.DeferSkeletalDynamicDataUpdateUntilGDME 如果> 0，那么骨架网格动态数据更新将被推迟到GDME。实验选项。
r.DeferUniformBufferUpdatesUntilVisible 如果> 0，那么不要更新原始的统一缓冲区，直到它可见。
r.DeferUniformExpressionCaching 是否推迟统一表达式的缓存，直到渲染命令需要它们为止。推迟更新更有效率，因为帧中的多个SetVectorParameterValue调用只会导致一次更新。
r.DemosaicVposOffset 此偏移量将添加到ES2色调着色器中用于去马赛克的光栅化位置。它存在解决一些Android设备上的偏移半像素的驱动程序错误。
r.DepthOfField.DepthBlur.Amount 此比例乘数仅影响CircleDOF DepthBlur特征（值定义半径达50％的公里数）。
x：将现有的深度模糊量乘以x
-x：用x（以公里计）覆盖现有的深度模糊量
1：无调整（默认）
r.DepthOfField.DepthBlur.ResolutionScale 这个缩放倍数只影响CircleDOF DepthBlur功能。这是一个暂时的黑客。
它通过1920年的分辨率增加（宽度）来抚平DepthBlur，只会影响比这更大的分辨率。
实际数学：float Factor = max（ViewWidth / 1920 - 1,0）; DepthBlurRadius * = 1 + Factor *（CVar - 1）
1：无调整（默认）
x：如果分辨率是1920，则没有变化，如果大于1920，则按半径缩放x
r.DepthOfField.DepthBlur.Scale 这个缩放倍数只影响CircleDOF DepthBlur功能。这在r.DepthOfField.DepthBlur.ResolutionScale之后应用。
0：禁用深度模糊
x：用x
x乘以现有的深度模糊半径：用x
1 覆盖现有的深度模糊半径：无调整（默认）
r.DepthOfField.FarBlur 仅影响CircleDOF的临时攻击
0：关闭
1：打开（默认）
r.DepthOfField.MaxSize 允许钳制高斯景深半径（为了更好的性能），默认值：100
r.DepthOfField.NearBlurSizeThreshold 强制禁用效果之前设置最小近模糊尺寸。目前只影响高斯自由度。
（默认值：0.01）
r.DepthOfFieldQuality 允许调整景深的质量。目前只能完全影响BokehDOF。高斯自由度是0关闭，否则打开。
0：关闭
1：低
2：高质量（默认，自适应，可以慢4倍）
3：非常高质量，适用于非实时过场动画，仅适用于CircleDOF（慢）
4：极高质量，适用于非实时过场动画，CircleDOF只有（很慢）
r.DetailMode 当前详细模式; 确定演员的组成部分是否应该更新/打勾。
0：低，只显示DetailMode低或高的对象
1：中，显示所有DetailMode中或高的对象
2：高，显示所有对象（默认）
r.DFFullResolution 1 =全分辨率距离场阴影，0 =具有双边上采样的一半分辨率。
r.DFShadowScatterTileCulling 是否使用光栅化器将对象分散到平铺网格上进行剔除。
r.DFShadowWorldTileSize 用于定向灯剔除的瓷砖的世界空间大小。
r.DFTwoSidedMeshDistanceBias 世界空间量扩大了双面网格的距离场表示。这对于使树阴影与标准阴影映射匹配很有用。
r.DiffuseColor.Max 允许通过将漫反射颜色重新映射到一个新值（0…1）进行快速材料测试，仅用于非内置发货！
1 :(默认）
r.DiffuseColor.Min 允许通过将漫反射颜色重新映射到一个新值（0…1）进行快速材料测试，仅用于非内置发货！
1 :(默认）
r.DisableDistortion 防止渲染造成扭曲效果。保存全屏幕帧缓存的内存。
·         r.DisableLODFade 为距离剔除禁用衰落
r.DiscardUnusedQuality 在内存中保留或丢弃未使用的质量级别的着色器映射。
0：保持内存中的所有质量水平。（默认）
1：丢弃负载上未使用的质量等级。
r.DisplayInternals 允许启用在引擎/渲染器上显示内部结构的屏幕打印输出。
这对于能够理解屏幕截图看起来不同的原因非常有用。
0：关闭（默认）
1：启用
r.DistanceFadeMaxTravel 玩家在淡出时间内可以行走的最大距离。
r.DistanceFieldAO 是否允许使用距离场AO特征，用于实现静态网格的可移动天空的阴影。
r.DistanceFieldBuild.Compress 是否将内存中的网格距离字段存储在内存中，这会减少占用的内存量，而且在使新层级可见时也会造成严重的中断。只有在你的项目没有在游戏中传输级别的情况下才能使用。
更改这将重新生成所有的网格距离字段。
r.DistanceFieldBuild.EightBit 是否以8位定点格式存储网格距离字段而不是16位浮点数。
8位使用内存的一半，但为大网格或细网格引入了伪像。
r.DistanceFieldBuild.UseEmbree 是否使用可见光线追踪器进行网格距离场的生成。
r.DistanceFieldGI
r.DistanceFields.AtlasSizeXY X和Y中全局网格距离场的最大大小图谱体积纹理。
r.DistanceFields.AtlasSizeZ Z中全局网格距离场图集的最大大小。
r.DistanceFields.DefaultVoxelDensity 确定网格的默认比例如何转换为距离场体素维度。
改变这将导致所有的距离场被重建。较大的值可能会非常快地消耗内存！
r.DistanceFields.MaxPerMeshResolution 最高分辨率（在一个维度上）允许单个静态网格资源，用于大规模限制网格的内存使用量。
改变这将导致所有的距离场被重建。像512这样大的值可以很快消耗内存！（一个资产的128Mb在512）
r.DistanceFieldShadowing 是否允许距离场阴影功能。
r.DoInitViewsLightingAfterPrepass 延迟InitViews的照明部分，直到完成之后。这可以提高线程吞吐量，并尽可能快地向GPU提供准备。实验选项;有一个未知的种族。
r.DontLimitOnBattery 0：限制使用电池的设备的性能（默认）
1：不要因设备有电池而限制性能。
r.DoTiledReflections 使用Tiled计算着色器计算反射环境
。0：关闭
1：开启（默认）
r.Downsample.Quality 定义Downsample通过的质量。我们稍后可能会添加更多质量级别。
0：低质量
0：高质量（默认值：3）
r.DownsampledOcclusionQueries 是否向下采样深度缓冲区发出遮挡查询
r.DrawRectangleOptimization 控制DrawRectangle（）的优化。启用时，可以使用三角形在某些情况下绘制四边形（视口大小为四边形）。
使用三角形允许以较低的分辨率进行稍快的后处理，但不能总是使用。
0：优化被禁用，DrawDenormalizedQuad总是渲染与四边形
1：启用优化，三角形可以渲染在指定的位置（默认）
r.DriverDetectionMethod 定义哪个实现用于检测GPU驱动程序（检查旧驱动程序以及日志和统计信息）
0：在注册表中迭代可用的驱动程序并选择具有相同名称的驱动程序，如果有问题，则使用下一个方法（发生）
1：主要adpater的驱动程序（可能不正确，当处理多个适配器）
2：使用DirectX的LUID（将是最好的，尚未实现）
3：使用Windows功能，使用主设备（可能是错误的，当API使用另一个适配器）
4：使用Windows功能，使用像DirectX Device（最新，最有前途）
r.DumpDrawListStats 转储与世界对象关联的所有场景的静态网格绘制列表统计信息。
r.DumpingMovie 允许将每个呈现的帧转储到磁盘（慢速帧，名称MovieFrame …）。
<= 0：关闭（默认），<0：保持打开，> 0：保持为n帧（n是指定的数字）
r.DumpRenderTargetPoolMemory 转储渲染目标池的分配信息。
r.DumpSCWQueuedJobs 设置为1时，将转储作业列表以帮助跟踪ShaderCompileWorker上发生的崩溃。
r.DumpShaderDebugInfo 当设置为1时，会导致所有被编译的材质着色器将调试信息转储到GameName / Saved / ShaderDebugInfo
调试信息依赖于平台，但通常包含着色器源的预处理版本。
如果r.ShaderDevelopmentMode被启用，全局着色器自动转储调试信息，这个cvar是不必要的。
在iOS上，如果将PowerVR图形SDK安装到默认路径，则会调用PowerVR着色器编译器，并在烹饪期间报告错误。
r.DumpShaderDebugShortNames 仅当r.DumpShaderDebugInfo = 1时有效。
设置为1时，将缩短名称工厂和着色器类型文件夹名称，以避免长路径问题。
r.DumpShaderDebugWorkerCommandLine 仅当r.DumpShaderDebugInfo = 1时有效。
设置为1时，将生成可与ShaderCompileWorker的-directcompile一起使用的文件。
r.DumpShadows 转储阴影设置（仅适用于开发人员，仅适用于非发货版本）
r.DumpTransitionsForResource 在给定资源转换时打印调用堆栈。目前只适用于DX11。要转储的资源的名称
r.DX11NumForcedGPUs Num强制GPU。
r.EarlyZPass 是否仅使用深度传递来初始化基本传球的Z剔除。在运行时无法更改。
注意：也看r.EarlyZPassMovable
0：关闭
1：很好的封堵器：没有被屏蔽，屏幕上很大
2：全部不透明（包括被屏蔽的）
x：使用内置的启发式（默认是3）
r.EarlyZPassMovable 是否将可移动物体渲染成深度只有通过。默认为打开。
注意：也请看r.EarlyZPass
r.EarlyZPassOnlyMaterialMasking 是否仅在早期的Z通道中计算材料的掩模不透明度。更改此设置需要重新启动编辑器。
注意：需要r.EarlyZPass == 2 && r.EarlyZPassMovable == 1
r.Editor.2DGridFade 调整以在2D视口中定义网格渲染。
r.Editor.2DSnapFade 调整以在2D视口中定义网格渲染。
r.Editor.2DSnapMin 调整以在2D视口中定义网格渲染。
r.Editor.2DSnapScale 调整以在2D视口中定义网格渲染。
r.Editor.3DGridFade 调整以在3D视口中定义网格渲染。
r.Editor.3DSnapFade 调整以在3D视口中定义网格渲染。
r.Editor.AlignedOrthoZoom 只影响编辑器的正视口。
0：每个正视口放大由视口宽度定义
1：所有正视口缩放互相锁定，以允许轴线彼此对齐。
r.Editor.MovingPattern 0：随着时间的推移关闭（默认值为1）
r.Editor.NewLevelGrid 是否显示新的编辑器级别网格
0：关闭
1：分析抗锯齿
2：基于纹理（默认）
r.Editor.OpaqueGizmo 0…1
0：遮挡的Gizmo部分透明（默认），1：Gizmo从不遮挡
r.EmitMeshDrawEvents 在每个绘图策略绘制调用周围发出一个GPU事件。/ n用于查看每个平局的统计数据，但是大大地扭曲了每次平局的总时间和时间。
r.EmitterSpawnRateScale 排放者的产卵率在全球范围内。发射器可以通过bApplyGlobalSpawnRateScale属性选择应用或忽略它。
r.EnableAsyncComputeTranslucencyLightingVolumeClear 是否使用异步计算清除半透明照明量。
r.EnableDebugSpam_GetObjectPositionAndScale 在FParticleSystemSceneProxy :: GetObjectPositionAndScale（）中启用或禁用调试日志垃圾邮件
r.EnableMorphTargets 启用变形目标
r.EnableStereoEmulation 仿真立体渲染
r.ExposureOffset 用于调整后期处理设置和眼睛适应的曝光。仅限开发者。0：默认
r.EyeAdaptation.Focus 仅适用于基本适应模式
0：统一权重
0：中心焦点，1是一个很好的数字（默认）
r.EyeAdaptation.MethodOveride
覆盖后处理卷中设置的眼睛适应方法-2：用自定义设置进行覆盖（用于测试基本模式）
-1：不覆盖
1：基于直方图
2：基本
r.EyeAdaptationQuality 定义眼睛适应质量，可以调整质量或性能。
<= 0：关闭（最快）
1：低质量（例如，基于非直方图，尚未实现）
2：正常质量（默认）
3：高质量（例如，屏幕位置局部化，尚未实现）
r.FastBlurThreshold 定义在高斯模糊优化的半径范围内（估计快25％ - 40％）。
这个优化使用的内存稍微少一点，并且在小的半径上有质量损失。
0：始终使用优化（最快，最低质量）
3：使用从3像素半径开始的优化（相当快）
7：使用从7像素半径开始的优化（默认）
15：几乎不使用优化高质量）
r.FastVramHzb 是否将HZB存储在快速VRAM中
r.FastVRamSceneColor 是否将场景颜色存储在快速VRAM中
r.FastVRamSceneDepth 是否将场景深度存储在快速VRAM中
r.FastVRamStaticLayoutFillWithGBuffers 是否使用GBuffers填充ESRAM，所有通过临时对象将不能分配。大部分静态照明的游戏将从使用GBuffers填充ESRAM而不是通过临时对象中获益。
注意：仅当r.FastVRamDynamicAllocation被禁用时才适用。
r.FeatureLevelPreview 如果1，快速设置菜单将包含启用功能级别预览模式的选项
r.Filter.LoopMode 控制何时使用动态或展开循环迭代高斯滤波。
这个过程用于高斯模糊，绽放和景深。动态循环允许
多达128个采样与32个展开循环样本相比，但是
在每次迭代时，为循环的停止测试增加额外的成本。
0：仅展开循环（默认值，限制为32个样本）。
1：如果需要多于32个采样，则回退到动态循环。
2：仅动态循环。
r.Filter.NewMethod 影响绽放和高斯景深。
0：旧方法（不按比例线性缩放）
1：新方法，可能需要资产调整（默认）
r.Filter.SizeScale 允许缩小或增加用于布卢姆和高斯景深的样本数（比例被限制以给出合理的结果）。
低于0.6的值很难被注意到
1完全质量（默认值）
1个样本（更慢）
<1个样本更少（更快，HDR内容的伪像或GaussianDOF的方形结果）
r.FinishCurrentFrame 如果打开，当前帧将被强制完成并呈现到屏幕而不是被缓冲。这会改善延迟，但会降低整体性能。
r.FlushRHIThreadOnSTreamingTextureLocks 如果设置为0，我们将不会对流式纹理进行任何刷新。这是安全的，因为纹理拖缆明确地处理这些危险。
r.Fog 0：禁用
1：启用（默认）
r.FogDensity 允许覆盖FogDensity设置（需要级别中的ExponentialFog）。
使用强大的值可以快速查看哪个像素受雾影响。
使用启动距离允许剔除像素可以加速渲染。
<0：使用默认设置（默认：-1）
= 0：通过给定值覆盖设置（0：关闭，1 =非常浓雾）
r.FogStartDistance 允许覆盖FogStartDistance设置（需要级别中的ExponentialFog）。
<0：使用默认设置（默认：-1）
= 0：按给定值覆盖设置（以世界单位）
r.ForceAMDToSM4 强制AMD设备使用SM4.0 / D3D10.0功能级别。
r.ForceDebugViewModes 0：设置没有效果。
1：强制调试视图模式可用，即使在已编译的版本上也是如此。2：即使在编辑器版本上也强制调试视图模式不可用。删除许多着色器排列，以实现更快的着色器迭代。
r.ForceHighestMipOnUITextures 如果设置为1，则UI组中的texut将具有最高的mip级别。
r.ForceIntelToSM4 强制英特尔设备使用SM4.0 / D3D10.0功能级别。
r.ForceLOD LOD级别强制关闭-1。
r.ForceLODShadow 仅用于阴影图生成的LOD级别，-1已关闭。
r.ForceNvidiaToSM4 Nvidia设备强制使用SM4.0 / D3D10.0功能级别。
r.Forward.LightGridPixelSize 光栅中单元的大小，以像素为单位。
r.Forward.LightGridSizeZ 光栅中Z片的数量。
r.Forward.LightLinkedListCulling 使用一个反向链表来存储剔除的灯光，消除多少灯光可以影响一个单元格的固定限制 - 而是成为一个全局限制。
r.Forward.MaxCulledLightsPerCell 控制为每个单元分配多少内存以进行轻剔除。当r.Forward.LightLinkedListCulling被启用时，这被用来计算一个全局的最大值，而不是每个单元的灯光限制。
r.ForwardBasePassSort 如何对移动基站进行排序：
0：基于硬件自动决定。
1：不分类。
2：排列绘图策略。
3：对绘图策略和其中的网格进行排序。
r.ForwardShading 是否在桌面平台上使用前向着色 - 需要Shader Model 5硬件。
正向着色具有较低的恒定成本，但支持的功能较少。0：关闭，1：开
这个渲染路径是一个正在进行的工作，有很多未实现的功能，特别是每个对象只应用一个反射捕捉，没有半透明动态阴影接收。
r.FreeSkeletalMeshBuffers 控制是否将骨架网格缓冲区保存在CPU内存中以支持骨架网格的合并。
0：保持缓冲区（默认）
1：空闲缓冲区
r.FrustumCullNumWordsPerTask 性能调整。控制用于平截头体剔除的ParallelFor的粒度。
r.FullScreenMode 定义我们如何做到全屏当被请求（例如命令行选项-fullscreen或在INI [SystemSettings]全屏=真）
0：正常全屏（呈现更快，超过VSYNC更多的控制，少GPU存储器，10bit色彩如果可能的话）
1：窗口全屏（应用程序和窗口模式之间快速切换，性能损失轻微），
任何其他数字的行为像0
r.FXSystemPreRenderAfterPrepass 如果> 0，则在预备后执行FX预渲染。这改善了流水线的性能。实验选项。
r.Gamma 伽玛输出
r.GBufferFormat 定义用于GBuffer的内存布局。
（影响性能，主要是通过带宽，法线质量和材料属性）。
0：精度较低（每个组件8bit，用于剖析）
1：低精度（默认）
3：高精度法线编码
5：高精度
r.GeneralPurposeTweak 对低级着色器开发有用，无需更改任何c ++代码即可快速获得迭代时间。
值映射到着色器内的Frame.GeneralPurposeTweak。
用法示例：在某个值上进行乘法调整，在不同的算法之间切换（默认值：1.0）
不要将它用于任何被检查的内容。编译出来在船上作弊有点困难。
r.GenerateLandscapeGIDAta 是否生成用于渲染实时全局照明的景观的低分辨率基本颜色纹理。
此功能需要GenerateMeshDistanceFields也被启用，并且会增加网格生成时间和内存使用量。
r.GenerateMeshDistanceFields 是否建立距离场AO所需的静态网格距离场，用于实现可移动的SkyLight阴影。
启用将增加网格生成时间和内存使用量。更改此值将导致重建所有静态网格物体。 作者：Unreal_Explorer https://www.bilibili.com/read/cv12369392/ 出处：bilibili
</code></pre>
</details>

<details>
<summary>【UE4】控制台文档—中</summary>
<pre><code>
https://www.bilibili.com/read/cv12369469
r.GPUBusyWait <= 0：关闭，> 0：保持GPU忙于n个单位的固定工作量，与分辨率无关。
这对于进行GPU时序实验非常有用。该值应该大致表示毫秒。
500人
r.GPUCrashDebugging 启用供应商特定的GPU崩溃分析工具
r.GPUDefrag.AllowOverlappedMoves 允许defrag重定位部分重叠。
r.GPUDefrag.EnableTimeLimits 限制花在GPU碎片整理上的CPU时间。
r.GPUDefrag.MaxRelocations 限制帧中总重定位的数量，而不管移动的字节数量是多少。
r.GPUParticle.AFRReinject 在AFR中运行时，切换优化以在下一个GPU上重新注入粒子注入，而不是执行纹理数据的缓慢GPU-> GPU传输
0：重新注入关闭
1：重新注入开启
r.GPUParticle.FixDeltaSeconds GPU颗粒修复增量秒。
r.GPUParticle.FixTolerance 在切换到修正增量秒之前，增加第二个容差。
r.GPUParticle.MaxNumIterations 使用固定增量秒时的最大迭代次数。
r.GPUParticle.Simulate 启用或禁用GPU粒子模拟
r.GPUSkin.Limit2BoneInfluences 是否使用2个骨骼影响，而不是使用默认值4来进行GPU蒙皮。在运行时无法更改。
r.GPUStatsEnabled 启用或禁用GPU状态记录
r.GPUStatsMaxQueriesPerFrame 限制每帧分配的时间戳数量。-1 =没有限制
r.GraphicsAdapter 用户请求选择一个特定的图形适配器（例如，当使用集成显卡与离散的一个）
此刻，这只适用于Direct3D 11.除非选择一个特定的适配器，否则我们拒绝微软适配器，因为我们不希望软件仿真。
-2：采取第一个满足条件
-1：赞成非整合，因为通常更快（默认）
0：适配器＃0
1：适配器＃1，…
r.HDR.Display.ColorGamut 输出显示的色域：
0：Rec709 / sRGB，D65（默认）
1：DCI-P3，D65
2：Rec2020 / BT2020，D65
3：ACES，D60
4：ACEScg，D60
r.HDR.Display.OutputDevice 输出显示的设备格式：
0：sRGB（LDR）
1：Rec709（LDR）
2：显式伽马映射（LDR）
3：ACES 1000 nit ST-2084（杜比PQ）（HDR）
4：ACES 2000 nit ST-2084 （Dolby PQ）（HDR）
5：ACES 1000 nit ScRGB（HDR）
6：ACES 2000 nit ScRGB（HDR）
r.HDR.EnableHDROutput 创建HDR兼容交换链并启用HDR显示输出。0：禁用（默认）
1：启用硬件特定的实现
r.HDR.UI.CompositeMode 合成UI层时使用的模式：
0：标准合成
1：Shader 合成，以改善HDR混合
r.HDR.UI.Level 合成HDR framebuffer时UI元素的亮度级别（默认值：1.0）。
r.HeightfieldGlobalIllumination
r.HeightfieldInnerBounceDistance
r.HeightfieldOuterBounceDistanceScale
r.HeightfieldTargetUnitsPerTexel
r.HighQualityLightMaps 如果设置为1，则允许高质量的光照贴图在固定光源的直接照明下不烘烤
r.HighResScreenshotDelay 当请求高分辨率的屏幕截图时，会有一个小的延迟，以使时间效应收敛。
默认值：4.使用低于默认值的值将禁用TemporalAA以改善图像质量。
r.HLOD 单一参数：0或1以禁用/启用HLOD系统
多个参数：强制X其中X是应强制进入视图的HLOD级别
r.HLOD.DistanceScale 计算用于静态网格过渡的离散HLOD距离的比例因子。（默认为1）
（更高的值使得HLOD转移得更远，例如，2是距离的两倍）
r.HLOD.ListUnbuilt 列出世界上所有未构建的HLOD角色
r.HLOD.MaximumLevel LOD层次结构允许显示多少（可用于限制高可伸缩性设置中的质量损失和流纹理内存使用情况）
-1：无最大级别（默认）
0：防止显示HLOD群集而不是单个网格
1：仅允许显示第一级的HLOD群集
2+：允许显示第三级的HLOD群集
r.HZBOcclusion 定义使用哪个遮挡系统。
0：硬件遮挡查询
1：使用HZB遮挡系统（默认，较少的GPU和CPU成本，更保守的结果）2：强制HZB遮挡系统（覆盖渲染平台首选项）
r.IndirectLightingCache 是否在动态对象上使用间接照明缓存。0关闭，1打开（默认）
r.InitialShaderLoadTime 花费时间在启动之前同步加载着色器缓存，然后再回到异步预编译/ predraw。默认为-1将同步执行所有工作。
r.InvalidateCachedShaders 通过对包含在common.usf中的ShaderVersion.ush进行唯一的更改来使着色器缓存无效。要启动实际的所有着色器的重新编译，请使用“recompileshaders changed”或按下“Ctrl Shift”。
ShaderVersion.ush文件应该被自动检出，但是需要检入才能在其他机器上生效。
r.KeepOverrideVertexColorsOnCPU 保持覆盖顶点颜色的CPU副本。可能需要一些蓝图/对象产卵。
r.KeepPreCulledIndicesThreshold
r.LandscapeLODBias 景观/地形网格的LOD偏差。
r.LensFlareQuality 0：关闭，但最好的性能
1：低质量，良好的性能
2：质量好（默认）
3：质量非常好，但性能差
r.LightFunctionQuality 定义允许调整质量或性能的灯光功能质量。 2：正常质量（默认） 3：高质量（例如，超级采样或着色，尚未实现）
<= 0：关闭（最快）
1：低质量
r.LightMaxDrawDistanceScale 应用于灯光的MaxDrawDistance的比例。对于在某些平台上更积极地淡出本地灯光很有用。
r.LightPropagationVolume 正在进行的工作的项目设置功能LightPropgationVolume。在运行时无法更改。
0：关闭（默认）
1：开启
r.LightShaftBlurPasses 光轴模糊通道的数量。
r.LightShaftDownSampleFactor 光轴的下采样系数。范围：1…8
r.LightShaftFirstPassDistance 与光线的距离的分数，以在第一径向模糊通过时模糊。
r.LightShaftNumSamples 每个光轴径向模糊通过的样本数量。也影响模糊距离随着每次通过而增加的速度。
r.LightShaftQuality 定义光轴质量（移动和非移动）。
0：关
1：开（默认）
r.LightShaftRenderToSeparateTranslucency 如果启用，光轴将渲染到单独的半透明缓冲区。
这确保了在光轴之前应用具有BL_BeforeTranslucnecy的后处理材料
r.LimitRenderingFeatures 允许快速减少渲染功能以提高渲染性能。
这只是在游戏中更改多个显示标志和控制台变量的一种快捷方式。
禁用更多功能数字越高
<= 0：关闭，订单在代码中定义（可以在订单处理时记录在此）
r.ListSceneColorMaterials 列出从场景颜色读取的所有材料。
r.LODFadeTime LOD花费多少时间（以秒为单位）。
r.LPV.DiffuseIntensity LPV扩散乘法器。
r.LPV.DirectionalOcclusionDefaultDiffuse
r.LPV.DirectionalOcclusionDefaultSpecular
r.LPV.EmissiveMultiplier 发射强度乘数
r.LPV.Intensity LPV强度的乘数。1.0是默认值。
r.LPV.Mixing 反射环境与间接着色（Ambient + LPV）混合。
0关闭，1打开（默认）
r.LPV.NumAOPropagationSteps LPV AO传播步数
0：嘈杂（适合调试）
1：正常（默认）
2：模糊
r.LPV.NumPropagationSteps LPV传播步骤的数量
r.LPV.RSMResolution 反射阴影映射分辨率（用于LPV） - 较高的值会导致较少的混叠伪像，但会降低性能
r.LPV.SpecularIntensity LPV镜面反射的乘法器。
r.LUT.Size 电影LUT的大小
r.MaterialEditor.UseDevShaders 切换材质编辑器是否使用包含编辑器引起的额外开销的着色器。如果在运行时更改，则材质编辑器必须重新打开。
r.MaterialQualityLevel 0对应于低质量材料，如材料质量开关所定义的，1对应于高，2对于中等。
r.MaxAnisotropy MaxAnisotropy应该在1到16的范围内。数值越高意味着在使用各向异性过滤时性能越好，但是性能上是成本的。缺省值是4。
r.MaxCSMRadiusToAllowPerObjectShadows 只有CSM半径小于此值的固定光源才会为动态对象创建每个对象阴影。
r.MaxForwardBasePassDraws 停止呈现静态移动基础通过指定次数后绘制。用于查看优化时网格渲染的顺序。
r.MaxQualityMode 如果设置为1，则不考虑性能影响，将某些系统设置改写为最高质量
r.MeshParticle.MinDetailModeForMotionBlur 设置网格粒子发出运动模糊之前的最小细节模式（低= 0，中= 1，高= 2，最大= 3）。设置为-1以完全禁用网格粒子运动模糊。默认为-1。
r.MeshReductionModule 什么网格减少模块选择的名称。如果空白，则选择存在的任何东西。
r.MinScreenRadiusForCSMDepth 阈值低于哪个网格将从CSM深度通道中剔除。
r.MinScreenRadiusForDepthPrepass 阈值低于哪个网格将从深度通过扑灭。
r.MinScreenRadiusForLights 阈值低于哪个灯将被淘汰。
r.MinYResolutionFor3DView 定义我们希望在3D视图中支持的最小Y分辨率
r.MinYResolutionForUI 定义我们要在UI中支持的最小Y分辨率（默认值为720）
r.MipMapLODBias 对所有2D纹理应用附加的mip贴图偏差，范围为-15.0至15.0
r.Mobile.AllowDistanceFieldShadows 0：不生成着色器置换，以便从固定方向灯渲染距离场阴影。
1：生成着色器置换以呈现来自静态定向光源的距离场阴影。（默认）
r.Mobile.AllowMovableDirectionalLights 0：不要生成着色器排列来渲染可移动的方向灯。
1：生成着色器排列来渲染可移动的方向灯。（默认）
r.Mobile.AlwaysResolveDepth 0：仅当使用贴花或调制阴影时，深度缓冲区在不透明通道后解析。（默认）
1：深度缓冲区在不透明传递后总是被解析。
r.Mobile.DisableVertexFog 设置为1以禁用所有移动着色器中的顶点起雾。
r.Mobile.EnableStaticAndCSMShadowReceivers 0：原始图像只能接收静态灯光的静态阴影。
1：原始图像可以从静止的灯光接收CSM和静态阴影。（默认）
r.Mobile.ForceDepthResolve 0：深度缓冲区通过切换渲染目标来解决。（默认）
1：深度缓冲区通过切换渲染目标并使用深度纹理进行绘制来解决。
r.Mobile.ForceRHISwitchVerticalAxis 预览移动渲染器时启用RHISwitchVerticalAxis。（用于测试GLES y轴翻转代码路径）
0：禁用RHISwitchVerticalAx（默认）。
1：启用RHISwitchVerticalAxis。
r.Mobile.SceneColorFormat 覆盖用于移动渲染器的场景颜色的内存布局（RGBA）。
不支持的重写格式默认使用默认值0 :(默认）根据项目设置和设备支持自动选择适当的格式。
1：PF_FloatRGBA 64Bit
2：PF_FloatR11G11B10 32Bit
3：PF_B8G8R8A8 32Bit
r.Mobile.Shadow.CSMShaderCulling
r.Mobile.Shadow.CSMShaderCullingCombineCasters
r.Mobile.Shadow.CSMShaderCullingDebugGfx
r.Mobile.Shadow.CSMShaderCullingDisableCasterTest
r.Mobile.Shadow.CSMShaderCullingTestBox
r.Mobile.TonemapperFilm 移动平台是否应该使用新的电影色调映射器
r.MobileContentScaleFactor 内容比例乘数（相当于iOS的contentScaleFactor支持Retina显示
r.MobileDynamicPointLightsUseStaticBranch 0：为0,1，… N个移动动态点光源生成独特的正向渲染基础通道着色器。（更快，但会产生更多着色器）
1：使用带有静态分支的共享着色器渲染一个或多个动态点光源（稍慢但会减少生成的着色器，推荐用于大多数游戏）。
r.MobileHDR 0：移动渲染在LDR伽玛空间。（建议针对低端手机的未点击游戏）
1：移动渲染HDR线性空间。（默认）
r.MobileHDR32bppMode 0：如果需要32bpp，移动HDR将使用最适合的32bpp模式。（默认）
1：使用马赛克编码强制移动32bpp HDR。
2：强制移动32bpp HDR与RGBE编码模式。（设备必须支持framebuffer获取）
3：强制移动32bpp HDR与直接RGBA8呈现。
r.MobileMSAA 移动时使用MSAA而不是时间AA：
1：使用时间AA（禁用MSAA）
2：使用2个MSAA（禁用时间AA）
4：使用4x MSAA（禁用时间AA）
8：使用8x MSAA（禁用时间AA）
r.MobileNumDynamicPointLights 在移动设备上支持的动态点灯数量。对于不需要动态点光源的游戏，将其设置为0将会减少生成的着色器的数量。
r.MobileReduceLoadedMips 减少用于非流式移动平台的加载纹理mipmap。
r.MobileTonemapperUpscale 在移动设备上，是允许作为色调映射器的一部分进行升级还是在可能的情况下作为单独的通道0：单独通过（默认）
1：作为色调映射器通道的一部分
r.MorphTarget.Mode 使用GPU来计算变形目标。
0：使用原始的CPU方法（每个形态循环，然后通过顶点）
1：启用GPU方法（默认）
r.MorphTarget.WeightThreshold 设置MorphTarget权重阈值（默认值：0.000000）。
r.MotionBlur.Amount 允许覆盖后处理设置（运动模糊的比例）
-1：覆盖（默认）
r.MotionBlur.Max 允许覆盖后处理设置（运动模糊的最大长度，以屏幕宽度的百分比表示）
-1：覆盖（默认）
r.MotionBlur.Scale 允许缩放后处理中的后处理强度/数量设置。
1：不要做任何缩放（默认）
r.MotionBlur2ndScale
r.MotionBlurDebug 定义我们是否记录运动模糊渲染的调试输出。
0：关闭（默认）
1：开启
r.MotionBlurFiltering 有用的开发变量
0：关闭（默认，着色器期望更好的质量）
1：开
r.MotionBlurQuality 定义运动模糊方法，可以调整质量或性能。
0：关，1：低，2：中，3：高（默认），4：非常高
r.MotionBlurScatter 基于分散的最大速度方法（较慢）。
r.MotionBlurSeparable 添加第二个运动模糊通道，可平滑噪点，以获得更高质量的模糊效果。
r.MotionBlurSoftEdgeSize 定义对象运动模糊模糊的程度（屏幕宽度的百分比），以允许软边运动模糊。
这与尺寸（最多32个样本，2.5约18个样本）成线性比例关系，屏幕分辨率
越小，性能越好，提供更精确的运动矢量，但是物体外部的模糊减少。
如果需要，可以像其他的motionblur设置一样暴露。
0：关（不自由，并且不会完全禁用），> 0,1.0（默认）
r.MSAA.CompositingSampleCount 影响编辑器3d对象的渲染质量。
1：没有MSAA，最低质量
2：2 MSAA，中等质量（中等GPU内存消耗）
4：4x MSAA，高质量（高GPU内存消耗）
8：8x MSAA，非常高质量（疯狂的GPU内存消耗）
r.MSAACount 与正向渲染器一起使用的MSAA示例数量。仅在渲染项目设置中启用MSAA时使用。
0：MSAA禁用（时间AA启用）
1：MSAA禁用
2：使用2个MSAA
4：使用4x MSAA
r.MultithreadedLightmapEncode 重建光照贴图之后的光照贴图编码是多线程完成的。
r.MultithreadedShadowmapEncode 重建光照贴图之后的阴影贴图编码是多线程完成的。
r.NormalCurvatureToRoughnessBias 将NormalCurvatureToRoughness启用的材质的屏幕空间正常变化偏差导致的粗糙度。有效范围[-1,1]
r.NormalCurvatureToRoughnessExponent 对于启用了NormalCurvatureToRoughness的材质的屏幕空间正常变化导致粗糙度的指数。
r.NormalCurvatureToRoughnessScale 调整NormalCurvatureToRoughness启用的材质的屏幕空间正常变化的粗糙度。有效范围[0，2]
r.NormalMapsForStaticLighting 是否允许任何静态照明使用法线贴图进行照明计算。
r.NumBufferedOcclusionQueries 缓存遮挡查询的帧数（包括当前的重新排列帧）。
更多的帧减少了CPU等待结果的机会，但增加了过时的查询工件。
r.NVIDIATimestampWorkaround 如果这是真的，我们禁用pre-maxwell硬件上的时间戳（驱动程序错误的解决方法）
r.OcclusionCullParallelPrimFetch 启用并行遮挡压缩原始获取。
r.OneFrameThreadLag 是否允许渲染线程落后于游戏线程一帧（0：禁用，否则启用）
r.OpenGL.AddExtensions 逗号分隔的OpenGL扩展列表添加到驱动程序报告的扩展字符串
r.OpenGL.StripExtensions 从驱动程序报告的扩展字符串中分离的逗号分隔的OpenGL扩展名列表
r.Paper2D.DrawTwoSided 画精灵是双面的。
r.ParallelBasePass 切换并行基础渲染。必须启用并行渲染才能产生效果。
r.ParallelGatherNumPrimitivesPerPacket 每个数据包的原语数。仅在r.Shadow.UseOctreeForCulling被禁用时使用。
r.ParallelGatherShadowPrimitives 切换平行聚集阴影基元。0 =关闭; 1 =开
r.ParallelInitViews 切换并行初始化视图。0 =关闭; 1 =开
r.ParallelPrePass 切换并行zprepass渲染。必须启用并行渲染才能产生效果。
r.ParallelShadows 切换并行阴影渲染。必须启用并行渲染才能产生效果。
r.ParallelShadowsNonWholeScene 切换并行阴影渲染非全景阴影。必须启用“并行阴影”才能产生效果。
r.ParallelTranslucency 切换并行半透明渲染。必须启用并行渲染才能产生效果。
r.ParallelVelocity 切换并行速度渲染。必须启用并行渲染才能产生效果。
r.ParticleLightQuality 0：没有灯。1：只有简单的灯光。2：简单+ HQ灯
r.ParticleLODBias 粒子系统的LOD偏差，默认为0
r.Photography.Allow 如果为1，则允许用户冻结场景，并可能使用漫游相机
截取屏幕截图。动态设置此项以允许或禁止按级别，
按场景等进行摄影（默认值：1）
r.Photography.AutoPause 如果为1，则摄影系统将尝试确保在摄影模式下水平被暂停。设置为0以管理从PlayerCameraManager蓝图回调手动暂停和取消暂停。注意：无论AutoPause值如何，Blueprint回调都会被调用。（默认：自动暂停（1）
r.Photography.AutoPostprocess 如果是1，则摄影系统将试图在摄影会议/摄影期间自动禁用HUD，字幕和一些标准的后处理效果，这些摄影会议/摄影会导致不良的摄影结果。设置为0，从PlayerCameraManager蓝图回调手动管理所有后期处理调整。注意：无论AutoPostprocess值如何，都将调用Blueprint回调。（默认：自动禁用（1）
r.Photography.Available （只读）如果为1，则摄影系统可能对用户可用。
否则，功能性的后端不可用。
r.Photography.EnableMultipart 如果为1，则允许摄影系统拍摄高分辨率照片，这些照片需要在以后拼接在一起的拼贴中呈现。（默认：1）
r.Photography.PersistEffects 如果为1，摄影模式中启用的自定义后期处理效果允许在摄影会话结束后继续存在于游戏中。在下次摄影开始之前，可能不会应用对该值的更改。（默认：禁用（0）
r.Photography.SettleFrames 拍摄照片前让渲染“解决”的帧数。有利于时间AA /平滑运作良好; 如果不使用任何时间效应，可以降低更快的捕获。（默认：10）
r.Photography.TranslationSpeed 移动漫游摄影机的正常速度（以每秒不实的单位）。（默认：100.0）
r.PostProcessAAQuality 定义后处理抗锯齿方法，可以调整质量或性能。
0：关闭，1：非常低（更快的FXAA），2：低（FXAA），3：中等（更快TemporalAA），4：高（默认TemporalAA），5：非常高，6：
r.PostProcessing.ForceAsyncDispatch 将强制异步调度后处理计算着色器的实现可用。
仅适用于非运送版本的测试。
r.PostProcessing.PreferCompute 将使用计算着色器进行后处理，其中实现可用。
r.PostProcessing.PropagateAlpha 0在后处理中禁用场景alpha通道支持。
0：禁用（默认）
1：启用
r.PostProcessingColorFormat 定义用于大多数后处理链缓冲区的内存布局（RGBA）。
0：默认值
1：强制PF_A32B32G32R32F 128Bit（不合理但很好的测试）
r.PrecomputedVisibilityWarning 如果设置为1，则在未预先计算可见性的情况下从视点渲染场景时将显示警告。
r.PredrawBatchTime 以毫秒为单位花费每帧预渲染着色器，或者-1以立即执行所有预渲染。
r.PreTileTextures 如果设置为1，那么纹理将在烹饪过程中平铺，预计在运行时进行烹饪
r.PreventInvalidMaterialConnections 控制用户是否可以在材料编辑器中建立连接，如果系统
确定它们可能导致编译错误
0：允许所有连接
1：防止无效连接
r.PreViewTranslation 为了限制浮世界空间位置的问题，我们通过
PreViewTranslation向量来抵消世界。这个命令允许禁止更新这个向量。
0：禁用更新
1：更新偏移量是每帧（默认）
r.ProfileGPU.AssetSummaryCallOuts 逗号分隔的列表，在最后的总结中值得特别提及（例如，“LOD，HeroName”
r.ProfileGPU.PrintAssetSummary必须为true才能启用此功能
r.ProfileGPU.Pattern 允许使用ProfileGPU过滤条目，模式匹配区分大小写。
最后可以使用’‘来获得以字符串开始的所有条目。
没有任何前导字符的’‘会禁用模式匹配，而是使用时间阈值（默认值）。
‘？’ 允许忽略一个字符。
例如AmbientOcclusionSetup，AmbientOcclusion *，Ambient ??? lusion ，
r.ProfileGPU.PrintAssetSummary 我们是否应该打印按资产汇总拆分（强烈建议使用r.ShowMateriaLDRawEvents）。
r.ProfileGPU.Root 允许在使用ProfileGPU时过滤树，模式匹配区分大小写。
r.ProfileGPU.Screenshot 分析GPU时是否应该执行屏幕截图。0：关，1：开（默认）
r.ProfileGPU.ShowEventHistogram 是否显示事件直方图。
r.ProfileGPU.ShowLeafEvents 允许profileGPU仅显示没有关联的事件的叶节点。
r.ProfileGPU.ShowTransitions 允许profileGPU显示资源转换事件。
r.ProfileGPU.ShowUI 在分析GPU之后是否应该显示用户界面分析器。
结果将始终转到日志/控制台
0：关闭，1：开启（默认）
r.ProfileGPU.Sort 以各种模式在树的每个级别独立排列TTY转储。
0：
按时间顺序排列1：按时间排列
2：按排列数
3：按垂直数排列
r.PS4DumpShaderSDB 是否转储用于着色器关联的着色器sdb文件。
0：禁用
1：启用）
r.PS4MixedModeShaderDebugInfo 是否编译着色器以允许混合模式着色器调试。这将会生成较慢的代码。
0：正常模式
1：混合模式）
r.RecompileRenderer 即时重新编译渲染器模块。
r.ReflectionCapture 更新所有反射捕获
r.ReflectionCaptureGPUArrayCopy 如果可能，调整大小时快速复制反射捕获数组。这样可以避免立方体贴图数组需要增长时在渲染线程上发生故障。
0关闭，1打开（默认）
r.ReflectionCaptureResolution 设置所有反射捕获立方体贴图的分辨率。应该通过项目的渲染设置来设置。必须是2的幂。默认为128。
r.ReflectionEnvironment 是否渲染反射环境功能，通过反射捕捉参与者实现局部反射。
0：关闭
1：打开并与场景混合（默认）2：打开并覆盖场景（仅在非发货版本中）
r.ReflectionEnvironmentBeginMixingRoughness 用光映射间接漫射捕获混合反射的最小粗糙度值。
r.ReflectionEnvironmentEndMixingRoughness 用光映射间接漫射捕获结束混合反射的最小粗糙度值。
r.ReflectionEnvironmentLightmapMixBasedOnRoughness 是否减少光照贴图混合与反射捕获非常光滑的表面。这对确保反射捕捉与亮度中的SSR /平面反射匹配很有用。
r.ReflectionEnvironmentLightmapMixing 是否将来自反射捕捉的间接镜面反射与来自光照贴图的间接漫反射混合起来用于粗糙表面。
r.ReflectionEnvironmentLightmapMixLargestWeight 当设置为1时，可以用来限制光照贴图混合，使得只有来自光照贴图的变暗才会应用于反射捕获。
r.RefractionQuality 定义允许调整质量或性能的失真/折射质量。
<= 0：关闭（最快）
1：低质量（尚未实现）
2：正常质量（默认）
3：高质量（例如，颜色边缘，尚未实施）
r.RenderLastFrameInStreamingPause 如果1在流暂停期间显示前一帧。如果为零，则屏幕保持黑屏。
r.RenderTargetPool.AllowMultipleAliasingDiscardsPerFrame 如果启用，则允许rendertarget在同一帧中被丢弃和重新获取。
这应该会提供更好的别名效率，但是会带来一些RHI线程/ GPU性能开销
（由于额外的命令列表刷新）
0：关闭（默认），1：开启
r.RenderTargetPool.Events 在一帧中随时间呈现渲染目标池事件。可选参数以KB为单位定义阈值。
要禁用视图，请使用不带任何参数的命令
r.RenderTargetPoolMin 如果渲染目标池大小（以MB为单位）低于此数字，则不会取消分配rendertargetsDefault为200 MB。
r.RenderTargetPoolTest 用特殊的颜色清除rendertarget池返回的纹理，
这样我们就可以更好地看到哪些通道需要清除。对于纹理纹理和非rendertargets尚不适用。
0：关（默认），1：开
r.RenderTargetSwitchWorkaround 某些移动平台需要解决方法，以避免与切换呈现目标相关的性能下降。
只在某些硬件上启用。这会影响花朵的质量。它的运行速度比正常的代码路径慢，但
仍然更快，因为它避免了许多渲染目标开关。（默认：0）
我们希望在所有的32位iOS设备上启用（1）（通过DeviceProfiles实现）。
r.RenderTimeFrozen 允许冻结基于时间的效果，以提供更确定的渲染分析。
0：关闭
1：开启（注意：这也会禁用遮挡查询）
r.ResetViewState 重置某些状态（例如TemporalAA索引）以使渲染更具确定性（用于自动截图验证）
r.RHICmdAsyncRHIThreadDispatch 实验选项做RHI调度异步。这可以使数据更快地流向RHI线程，并避免在帧结尾的数据块。
r.RHICmdBalanceParallelLists 允许启用对清单的预处理，试图在命令列表中平衡负载。
0：关闭
1：启用2：实验，使用以前的帧结果（在分屏等不做任何事情）
r.RHICmdBalanceTranslatesAfterTasks 渲染任务完成后，平衡平行翻译的实验选项。这最大限度地减少了延迟上下文的数量，但是增加了延迟来启动翻译。r.RHICmdBalanceParallelLists覆盖并禁用此选项
r.RHICmdBasePassDeferredContexts 如果使用延迟上下文来平行执行基本传递命令列表，则为true。
r.RHICmdBufferWriteLocks 只与RHI线程有关。调试选项来诊断缓冲锁问题。
r.RHICmdBypass 是否绕过rhi命令列表并立即发送rhi命令。
0：禁用（对于多线程渲染器是必需的）
1：启用（便于调试低级图形API调用，可以抑制多线程渲染器代码中的工件）
r.RHICmdCollectRHIThreadStatsFromHighLevel 这将推动RHI线程上的统计信息执行，所以你可以确定他们来自哪个高层次的传递。这对帧率有不利的影响。这是默认情况下。
r.RHICmdDeferSkeletalLockAndFillToRHIThread 如果> 0，则在RHI螺纹上做骨骼和布料拷贝。实验选项。
r.RHICmdFlushOnQueueParallelSubmit 提交后立即等待并行命令列表的完成。对于问题诊断。仅在某些RHI上可用。
r.RHICmdFlushRenderThreadTasks 如果为true，那么我们每次刷新渲染线程任务。对于问题诊断。这是一个更精细的cvars的主开关。
r.RHICmdFlushRenderThreadTasksBasePass 等待基本过程结束时完成并行渲染线程任务。r.RHICmdFlushRenderThreadTasks的更精细的版本。如果r.RHICmdFlushRenderThreadTasks或r.RHICmdFlushRenderThreadTasksBasePass> 0，我们将刷新。
r.RHICmdFlushRenderThreadTasksPrePass 等待预传结束时完成并行渲染线程任务。r.RHICmdFlushRenderThreadTasks的更精细的版本。如果r.RHICmdFlushRenderThreadTasks或r.RHICmdFlushRenderThreadTasksPrePass> 0，我们将刷新。
r.RHICmdFlushRenderThreadTasksShadowPass 等待在每个阴影过程结束时完成并行渲染线程任务。r.RHICmdFlushRenderThreadTasks的更精细的版本。如果r.RHICmdFlushRenderThreadTasks或r.RHICmdFlushRenderThreadTasksShadowPass> 0，我们将刷新。
r.RHICmdFlushRenderThreadTasksTranslucentPass 等待在半透明过程结束时完成并行渲染线程任务。r.RHICmdFlushRenderThreadTasks的更精细的版本。如果r.RHICmdFlushRenderThreadTasks或r.RHICmdFlushRenderThreadTasksTranslucentPass> 0，我们将刷新。
r.RHICmdFlushRenderThreadTasksVelocityPass 等待速度传递结束时完成并行渲染线程任务。r.RHICmdFlushRenderThreadTasks的更精细的版本。如果r.RHICmdFlushRenderThreadTasks或r.RHICmdFlushRenderThreadTasksVelocityPass> 0，我们将刷新。
r.RHICmdFlushUpdateTextureReference 如果为true，那么当我们执行RHIUpdateTextureReference时，我们刷新rhi线程，否则这是延迟的。对于问题诊断。
r.RHICmdForceRHIFlush 为发送到RHI线程的每个任务强制刷新。对于问题诊断。
r.RHICmdMergeSmallDeferredContexts 何时可以确定，合并基于r.RHICmdMinDrawsPerParallelCmdList的小型平行翻译任务。
r.RHICmdMinCmdlistForParallelSubmit 并行翻译命令列表的最小数量提交。如果少于这个数字，他们就运行在RHI线程和直接上下文中。
r.RHICmdMinCmdlistForParallelTranslate 如果平行翻译的数量少于这个数量，它们就运行在RHI线程和直接上下文中。只有在r.RHICmdBalanceTranslatesAfterTasks打开时才有效。
r.RHICmdMinCmdlistSizeForParallelTranslate 千字节 Cmdlists被合并成一个平行的翻译，直到我们至少有这么多的内存来处理。对于给定的通行证，我们不会做比我们有任务线程更多的翻译。只有在r.RHICmdBalanceTranslatesAfterTasks打开时才有效。
r.RHICmdMinDrawsPerParallelCmdList 每个cmdlist的最小绘图数量。如果总抽奖数少于这个数，那么根本就不会有平行的工作。这不能总是被尊重或正确完成。用RHICmdBalanceParallelLists更有效。
r.RHICmdPrePassDeferredContexts 真正使用延迟上下文来并行化预备命令列表执行。
r.RHICmdShadowDeferredContexts 如果使用延迟上下文来平行执行阴影命令列表，则为true。
r.RHICmdSpewParallelListBalance 对于调试，会发出并行命令列表的大小。这个摊位，否则破坏性能。
0：关闭（默认）
1：启用（默认）
r.RHICmdTranslucencyPassDeferredContexts 如果使用延迟上下文来平行执行基本传递命令列表，则为true。
r.RHICmdUseDeferredContexts 如果使用延迟上下文来并行执行命令列表，则为true。仅在某些RHI上可用。
r.RHICmdUseParallelAlgorithms 真正使用并行算法。如果r.RHICmdBypass是1，则忽略。
r.RHICmdUseThread 使用RHI线程。对于问题诊断。
r.RHICmdVelocityPassDeferredContexts 真正使用延迟上下文来并行化速度传递命令列表执行。
r.RHICmdWidth 控制并行渲染器中大量事物的任务粒度。
r.RHISetGPUCaptureOptions 用于在分析或调试GPU渲染时更改多个有用的CVAR的实用程序功能。设置为1或0将保证所有选项处于适当的状态。
r.rhithread.enable，r.rhicmdbypass，r.showmateriaLDRawevents，toggledrawevents
平台RHI可能会实现更多的功能切换。
r.RHIThread.Enable 启用/禁用RHI线程并确定RHI工作是否在专用线程上运行。
r.Roughness.Max 通过将粗糙度重新映射到一个新的值（0…1），允许快速的材料测试，仅用于非内置的运输！
1 :(默认）
r.Roughness.Min 允许通过将粗糙度重新映射到一个新的值（0…1）来进行快速材料测试，仅用于非内置运输！
0 :(默认）
r.SaveEXR.CompressionQuality 定义我们如何以EXR格式保存HDR屏幕截图。
0：不压缩
1：可以慢的默认压缩（默认）
r.SceneColorFormat 定义用于场景颜色的内存布局（RGBA）
（主要通过带宽，质量（特别是半透明）来影响性能）。
0：PF_B8G8R8A8 32Bit（主要用于测试，可能不能用于HDR）
1：PF_A2B10G10R10 32Bit
2：PF_FloatR11G11B10 32Bit
3：PF_FloatRGB 32Bit
4：PF_FloatRGBA 64Bit（默认，可能是矫枉过正，尤其是如果半透明主要使用SeparateTranslucency）
5：PF_A32B32G32R32F 128Bit （不合理但很好的测试）
r.SceneColorFringe.Max 允许限制后处理设置（百分比，场景色差/彩色条纹模拟真实世界镜头中发生的伪影，大部分在图像角落中可见）
-1：不夹紧（默认）
-2：测试极端的边缘
r.SceneColorFringeQuality 0：关闭，但对性能最好
1：3纹理采样（默认）n
r.SceneRenderTargetResizeMethod 控制场景渲染目标调整大小的方法：（
此值仅用于游戏模式和开窗平台）
0：调整大小以匹配请求渲染大小（默认）（最小内存使用，可导致大小改变时停顿，例如ScreenPercentage）
1：固定到屏幕分辨率。
2：扩展到包含最大的请求渲染维度。（大多数内存使用，最不容易分配摊位。）
r.ScreenPercentage 以较低的分辨率和高档渲染以获得更好的性能（结合可混合的后期处理设置）。
70是一个很好的低混叠和性能值，可以通过’show TestImage’
以百分比验证，> 0和<= 100，更大的数字是可能的（超级采样），但是下采样质量是可以改进的<0被视为100。
r.ScreenPercentage.Editor 允许在编辑器中使用ScreenPercentage。
0：关（默认）
1：允许上采样（模糊但更快）和下采样（cripser但更慢）
r.ScreenshotDelegate ScreenshotDelegates阻止处理传入的屏幕截图请求并破坏某些功能。这允许禁用它们。
理想情况下，我们重新编写委托代码，使其不再需要。
0：关
1：代表开启（默认）
r.SelectiveBasePassOutputs 使着色器只能导出到相关的rendertargets。
0：在所有的rendertargets导出。
1：仅导出到相关的rendertarget。
r.SeparateTranslucency 允许禁用单独的半透明特征（
如果材料中没有另外指定，则所有半透明都在单独的RT中呈现并在DOF之后合成）。
0：关闭（半透明度受深度影响）
1：降低GPU性能和内存，但保持半透明性不受景深影响。（默认）
r.SeparateTranslucencyAutoDownsample 是否根据最后一帧的GPU时间自动降低采样半透明度。
仅当r.SeparateTranslucencyScreenPercentage为100时才使用自动缩减采样
r.SeparateTranslucencyDurationDownsampleThreshold 当平滑的full-res半透明GPU持续时间大于此值（ms）时，整个过程将在每个维度上以2倍的比例下采样。
r.SeparateTranslucencyDurationUpsampleThreshold 当平滑半分半透明GPU持续时间小于此值（ms）时，整个通过将恢复到全分辨率。
这应该是r.SeparateTranslucencyDurationDownsampleThreshold的1/4左右，以避免不断切换下采样状态。
r.SeparateTranslucencyMinDownsampleChangeTime 自动降采样状态更改之间的最短时间（以秒为单位），用于防止在半满和全分辨率之间快速交换。
r.SeparateTranslucencyScreenPercentage 以完整分辨率的这个百分比渲染单独的半透明效果。
以百分比表示，> 0且<= 100时，可能有更大的数字（超级采样）。<0被视为100。
r.SeparateTranslucencyUpsampleMode 使用单独半透明的Upsample方法。这些仅在r.SeparateTranslucencyScreenPercentage小于100时使用
。0：双线性1：Nearest-Depth Neighbor（仅当r.SeparateTranslucencyScreenPercentage为50时）
r.SetNearClipPlane 设置近剪裁平面（cm）
r.SetRes 设置当前游戏视图的显示分辨率。在编辑器中没有效果。
例如1280x720w用于窗口
1920x1080f全屏
1920x1080wf用于窗口全屏
r.ShaderDevelopmentMode 0：默认值，1：启用各种着色器开发实用程序，例如在着色器编译失败时重试，以及在编译着色器时执行额外的日志记录。
r.ShaderPipelines 启用使用着色器管线。
r.Shaders.BoundsChecking 是否对着色器中的缓冲区读写执行边界检查和清零/忽略。默认为1（启用）。并非所有的着色语言都可以省略边界检查。
r.Shaders.FastMath 是否在着色器中使用快速数学优化。
r.Shaders.KeepDebugInfo 是否保持着色器反射和从着色器字节码调试数据，默认是剥离。使用Nsight等图形调试器时，在启动时启用此功能可能很有用。
r.Shaders.Optimize 是否优化着色器。使用Nsight等图形调试器时，在启动时禁用此功能可能很有用。
r.Shaders.ZeroInitialise 是否在着色器中强制原始类型的局部变量初始化为零。默认为1（启用）。并非所有的着色语言都可以省略零初始化。
r.Shadow.CachedShadowsCastFromMovablePrimitives 无论是可移动的原始图像，都应该从缓存的整个场景阴影（可移动的点和光点）投下阴影。
禁用此功能可用于删除缓存的阴影图的副本。
r.Shadow.CachePreshadow preshadows是否可以缓存作为优化
r.Shadow.CacheWholeSceneShadows 当启用时，来自静态图元的可移动点和点光全景阴影深度将被缓存作为优化。
r.Shadow.CacheWPOPrimitives 对于使用“世界位置偏移”的素材，是否应考虑为缓存阴影贴图可移动。
使用这种方法，可以使用WPO的材质提供更正确，但更慢的整个场景阴影。
r.Shadow.ConservativeBounds 是否使用安全和保守的阴影平截体创建，浪费一些阴影贴图空间
r.Shadow.CSM.MaxCascades 用于渲染动态定向光阴影的级联的最大数量。
r.Shadow.CSM.MaxMobileCascades 使用移动渲染器时，用于渲染动态定向光阴影的级联的最大数量。
r.Shadow.CSM.TransitionScale 允许缩放级联的阴影贴图过渡区域。夹在0…2之内。
0：不转换（最快）
1：与光源设置相同（默认）
2：比光源中指定的大2倍
r.Shadow.CSMDepthBias CSM使用恒定的深度偏差
r.Shadow.CSMDepthBoundsTest 是否使用深度边界测试而不是CSM边界的模板测试
r.Shadow.CSMSplitPenumbraScale 应用于级联阴影贴图分割的半影大小的缩放，有助于最小化分割之间的转换
r.Shadow.DistanceScale 可扩展性选项可将阴影距离与定向光源的性能（在合理的范围内限制）进行交易。
<1：较短的距离
1：正常（默认）
1：较大的距离
r.Shadow.DrawPreshadowFrustums 当shadowfrustums显示标志被启用时，可视化预感阴影 作者：Unreal_Explorer https://www.bilibili.com/read/cv12369469 出处：bilibili
</code></pre>
</details>

<details>
<summary>【UE4】控制台文档—下</summary>
<pre><code>
https://www.bilibili.com/read/cv12369508
r.Shadow.EnableModulatedSelfShadow 允许调制阴影影响阴影施法者。（仅限移动）
r.Shadow.FadeExponent 控制阴影淡出的速度
r.Shadow.FadeResolution 在其下面阴影消失的texels中的分辨率
r.Shadow.FilterMethod 选择阴影过滤方法。
0：统一PCF（默认）
1：PCSS（实验）
r.Shadow.ForceSingleSampleShadowingFromStationary 是否强制所有组件执行如同启用了bSingleSampleShadowFromStationaryLights的功能。动态阴影禁用时，可用于可伸缩性。
r.Shadow.FreezeCamera 通过允许从外部观察系统来调试阴影方法。
0：默认
1：冻结当前位置的摄像机
r.Shadow.MaxCSMResolution 允许渲染级联阴影深度的最大平方尺寸（以像素为单位）。范围4到硬件限制。较高=质量较好的阴影，但性能成本较高。
r.Shadow.MaxResolution 允许渲染阴影深度的最大平方尺寸（以像素为单位）。范围4到硬件限制。较高=质量较好的阴影，但性能成本较高。
r.Shadow.MaxSoftKernelSize 软化内核的Mazimum大小（以像素为单位）。
r.Shadow.MinPreShadowResolution 允许渲染预处理深度的最小尺寸（以像素为单位）
r.Shadow.MinResolution 允许渲染阴影对象深度的最小尺寸（以像素为单位）
r.Shadow.PerObject 是否渲染每个物体的阴影（角色铸造世界）
0：关闭
1：开启（默认）
r.Shadow.PerObjectDirectionalDepthBias 定向光源中每个对象阴影所使用的恒定深度偏差
较低的值会提供更好的自我阴影效果，但会增加自我阴影伪影
r.Shadow.PointLightDepthBias 在深度传递中应用的深度偏移从点光源发出阴影。（0.03避免彼得paning，但有一些阴影痤疮）
r.Shadow.PreshadowExpand 渲染缓存预处理时将扩展多少边界（0.15 = 15％）
r.Shadow.PreShadowFadeResolution 分辨率下面的预映像淡出
r.Shadow.PreShadowResolutionFactor 预印分辨率的Mulitplier
r.Shadow.Preshadows 是否允许预言（静态世界铸造角色）
r.Shadow.PreshadowsForceLowestDetailLevel 启用时，静态网格将其最低细节级别呈现为预先着色深度图。默认情况下被禁用，因为它会导致质量差的LOD（树广告牌）的人为因素。
r.Shadow.RadiusThreshold 如果影子脚轮太小，则值为最小屏幕空间范围
（默认为0.03）
r.Shadow.RadiusThresholdRSM RSM中的影子脚轮如果太小，值就是最小的屏幕空间范围
（默认为0.06）
r.Shadow.SpotLightDepthBias 在深度传递中应用的深度偏差，针对每个对象投射来自投射灯的阴影
r.Shadow.SpotLightTransitionScale 聚光灯的过渡比例
r.Shadow.StencilOptimization 在测试过程中，通过调零模板来清除阴影投影之间的模板
r.Shadow.TexelsPerPixel 每个对象阴影的主体像素与阴影纹理元素的比率
r.Shadow.TexelsPerPixelsPotlight 聚光灯的主体像素与阴影纹理元素的比率
r.Shadow.TransitionScale 这将控制施法者和他的影子出现在哪里的“淡入”区域。较大的值会使较小的区域具有更多的自我阴影伪影
r.Shadow.UnbuiltNumWholeSceneDynamicShadowCascades DynamicShadowCascades在使用CSM预览未定向灯光时使用
r.Shadow.UnbuiltWholeSceneDynamicShadowRadius WholeSceneDynamicShadowRadius在使用CSM从方向灯预览未建造的灯光时使用
r.Shadow.UseOctreeForCulling 是否使用原始八叉树进行阴影主题剔除。八叉树一次剔除大量的基元，但引入了缓存未命中的数据结构。
r.Shadow.WholeSceneShadowCacheMb 可以缓存整个场景阴影的内存量。单个帧中的ShadowMap分配可能会导致超出此限制。
r.Shadow.WholeSceneShadowUnbuiltInteractionThreshold 在灯光切换到整个场景阴影之前，可以有多少未建成的光 - 原始交互
r.ShadowQuality 定义允许调整质量或性能的阴影方法。
0：关闭，1：低（未过滤），2：低。5：最大（默认）
r.ShowMaterialDrawEvents 如果平台支持，则在每个材质绘制周围启用绘制事件
r.ShowPrecomputedVisibilityCells 如果不为零，则绘制所有预先计算的可见性单元格。
r.ShowRelevantPrecomputedVisibilityCells 如果不是零，则仅绘制相关的预计算可见性单元格。
r.ShowShaderCompilerWarnings 设置为1时，将显示所有警告。
r.SimpleForwardShading 是否使用简单的向前着色基本通道着色器，其仅支持光照贴图+固定定向光源+固定天窗
所有其他照明功能在真实时都被禁用。这对于支持非常低端的硬件很有用，而且只在PC平台上支持。
0：关，1：开
r.SkeletalMeshLODBias 骨架网格的LOD偏差（不影响动画编辑器视口）。
r.SkeletalMeshLODRadiusScale 用于计算骨架网格的离散LOD的屏幕半径比例因子。（0.25-1）
r.SkinCache.CompileShaders 是否编译GPU计算皮肤缓存着色器。
这将在计算作业上编译着色器，而不是顶点着色器上的蒙皮。
如果这个改变，GPUSkinVertexFactory.usf需要被触及以导致重新编译。
0关闭（默认），1打开
r.SkinCache.Debug 传递给SkinCache着色器的缩放常量，用于调试
r.SkinCache.ForceRecomputeTangents 强制启用/使用skincache并强制所有蒙皮对象重新计算切线
r.SkinCache.Mode 是否使用GPU计算皮肤缓存。
这将在计算作业上执行蒙皮，而不是顶点着色器上的蒙皮。
需要r.SkinCache.CompileShaders = 1
0：关闭
1：开启（默认）2：只使用皮肤高速缓存作为勾选“重新计算切线”复选框的皮肤网格（在发货版本中不可用）
r.SkinCache.NumTangentIntermediateBuffers 在
执行重新计算切线时，有多少中间缓冲区用于中间结果; 更多可能允许GPU重叠计算工作。
r.SkinCache.RecomputeTangents 该选项可以重新计算GPU上的顶点切线。
可以在运行时改变，同时需要r.SkinCache.CompileShaders = 1和r.SkinCache.Mode = 1
0：off
1：on，强制所有外观对象重新计算切线
2：开，只重新计算皮肤对象上的切线重新计算切线复选框（默认）
r.SkinCache.SceneMemoryLimitInMB Megs中每个World / Scene允许分配的最大内存
r.SkySpecularOcclusionStrength 来自DFAO的天光镜面反射遮挡强度（默认值为1.0）
r.SplineMesh.NoRecreateProxy 优化。如果为true，则样条线网格代{过}{滤}理将不会在每次更改时重新创建。他们只是更新。
r.SSR.Cone 定义我们是否使用锥形跟踪屏幕空间反射
0关闭（默认），1打开
r.SSR.MaxRoughness 允许覆盖后期处理设置ScreenSpaceReflectionMaxRoughness。
它定义了什么粗糙度我们淡出屏幕空间的反射，0.8工作好，小可以跑得更快。
（用于测试，无可扩展性或项目设置）
0…1：使用指定的最大粗糙度（
覆盖后处理体积设置）-1：不覆盖（默认）
r.SSR.Quality 是否使用屏幕空间反射和在什么质量设置。
（限制后处理设置中具有不同比例的设置）
（成本性能，增加更多的视觉真实感，但技术有限制）
0：关闭（默认）
1：低（无光泽）
2：中等（无光泽）
3 ：高（光泽/使用粗糙度，少量样品）
4：非常高（实时可能太慢）
r.SSR.Stencil 定义我们是否使用模板为屏幕空间反射
0关闭（默认），1打开
r.SSR.Temporal 定义如果我们使用时间平滑的屏幕空间反射
0关闭（用于调试），1打开（默认）
r.SSS.Checkerboard 启用或禁用针对地下轮廓渲染的棋盘渲染。
如果SceneColor不包含浮点Alpha通道（例如32位格式），则这是必需的
。0：禁用（高质量）
1：启用（低质量）。表面照明的分辨率会降低。
2：自动。如果我们有一个合适的rendertarget格式，将会应用非棋盘照明
r.SSS.Filter 定义Screenspace Subsurface Scattering功能的过滤方法。
0：点过滤器（有用于测试，可以更清洁）
1：双线性过滤器
r.SSS.HalfRes 0：全质量（未优化，作为参考）
1：算法的部分以低分辨率运行，其质量较低但速度较快（默认）
r.SSS.Quality 当使用SubsurfaceScatteringProfile着色模型时，定义重组通道的质量
0：低（更快，默认）
1：高（更细锐但更慢）
-1：自动，1如果TemporalAA被禁用（没有TemporalAA，质量更明显）
r.SSS.SampleSet 定义我们用于Screenspace Subsurface Scattering功能的样本数量。
0：最低质量（6 * 2 + 1）
1：中等质量（9 * 2 + 1）
2：高质量（13 * 2 + 1）（默认）
r.SSS.Scale 影响屏幕空间次表面散射通道（使用shadingmodel SubsurfaceProfile，靠近对象作为默认值）
是仅散射大约1.2cm的人类皮肤）
0：关闭（如果屏幕上没有使用此通道的对象，它应该自动禁用后处理通）
<1：刻度散射半径向下（用于测试）
1：使用给定的半径形成表面散射资产（默认值）
1：刻度散射半径向上（用于测试）
r.StaticMesh.EnableSaveGeneratedLODsInPackage 启用在包中保存生成的LOD。
0 - 不保存（并隐藏此菜单选项）[默认]。
1 - 启用此选项并将LOD保存在包中。
r.StaticMesh.UpdateMeshLODGroupSettingsAtLoad 如果设置，静态网格的LODGroup设置将在加载时应用。
r.StaticMeshLODDistanceScale 用于计算静态网格的离散LOD的距离的比例因子。（默认为1）
（更高的值使得LOD更早地转换，例如，2是快两倍/距离的一半）
r.StencilForLODDither 是否在预备中使用模板测试，在基础阶段是否进行深度平等测试来实现LOD抖动。
如果禁用，则LOD抖动将通过预览和基本传递中的clip（）指令完成，从而禁用EarlyZ。
启用时强制完成预备。
r.Streaming.Boost = 1.0：正常
<1.0：减少想要的MIP水平
1.0：增加想要的MIP水平
r.Streaming.CheckBuildStatus 如果非零，引擎将检查纹理流是否需要重建。
r.Streaming.DefragDynamicBounds 如果非零，则未使用的动态范围将从更新循环中移除
r.Streaming.DropMips 0：掉落没有Mips
1：掉落缓存Mips
2：掉落缓存和隐藏Mips
r.Streaming.FramesForFullUpdate 纹理流是每帧时间分割的。这个值给出了访问所有纹理的帧数。
r.Streaming.FullyLoadUsedTextures 如果非零，则所有使用的纹理将尽可能快地完全流入
r.Streaming.HiddenPrimitiveScale 定义不在范围内时应用的分辨率刻度。
.5：下降一个mip
1：忽略visiblity
r.Streaming.HLODStrategy 定义HLOD流策略。
0：流
1：仅流mip 0
2：禁用流
r.Streaming.LimitPoolSizeToVRAM 如果非零，纹理池大小将受限于GPU mem的可用数量。
r.Streaming.MaxEffectiveScreenSize 0：使用当前的实际垂直屏幕大小
0：钳制想要的mip大小计算为垂直屏幕大小组件的此值。
r.Streaming.MaxTempMemoryAllowed 流入或流出纹理片段时使用的最大临时内存。
该内存包含用于新更新纹理的mips。
该值必须足够高，不能成为限制流速的因素。
r.Streaming.MinMipForSplitRequest 如果非零，加载请求将首先加载可见mip的最小隐藏mip
r.Streaming.MipBias 0…x通过浮点数减少纹理质量。
0：使用完全分辨率（默认）
1：降低一个mip
2：降低两个mips
r.Streaming.NumStaticComponentsPrOcessedPerFrame 如果非零，那么引擎将通过在每帧可见之前处理这些数量的组件来递增插入级别
r.Streaming.PoolSize -1：默认纹理池大小，否则以MB为单位
r.Streaming.ScaleTexturesByGlobalMipBias 如果非零，流式纹理想要的分辨率将被全球mip偏差缩小
r.Streaming.UseAllMips 如果非零，将使用所有可用的mips
r.Streaming.UseFixedPoolSize 如果非零，请不要在运行时更改池大小。
r.Streaming.UseMaterialData 如果非零，将使用材质纹理和坐标
r.Streaming.UseNewMetrics 如果非零，将使用改进的一组度量和启发式。
r.Streaming.UsePerTextureBias 如果非零，每个纹理将被分配一个0到MipBias之间的Mip偏移量，以适应预算。
r.SubsurfaceScattering 0：禁用
1：启用（默认）
r.SupportAllShaderPermutations 本地用户配置覆盖强制所有着色器置换功能。
r.SupportAtmosphericFog 启用AtmosphericFog着色器排列。
r.SupportLowQualityLightmaps 支持低质量的光照贴图着色器排列
r.SupportPointLightWholeSceneShadows 启用阴影投影点光源。
r.SupportSimpleForwardShading 是否编译着色器以支持r.SimpleForwardShading被启用（仅限PC）。
r.SupportStationarySkylight 启用固定和动态天光着色器排列。
r.SurfelDensity
r.SurfelLODDensityFraction
r.SurfelMaxPerObject
r.TargetPrecompileFrameTime 预编译时总帧时间的上限（毫秒），允许着色器高速缓存调整预编译每帧的着色器数量。默认为-1，将立即预编译所有着色器。
r.TemporalAACatmullRom 是否使用Catmull-Rom过滤器内核。应该比高斯清晰一点。
r.TemporalAACurrentFrameWeight 当前帧对历史贡献的权重。低值导致模糊和重影，高值不能隐藏抖动。
r.TemporalAAFilterSize 过滤内核的大小。（1.0 =更平滑，0.0 =更锐利但别名）。
r.TemporalAAPauseCorrect 正确的时间AA暂停。这延长了渲染目标的时间，防止重用并消耗更多的内存。
r.TemporalAASamples 时态AA的抖动位置的数量（4,8 =默认值，16,32,64）。
r.TessellationAdaptivePixelsPerTriangle 全局镶嵌因子乘数
r.TexelDebugging T +鼠标在编辑器中点击是否选择用于调试Lightmass的光照贴图。必须重新编译Lightmass，并启用ALLOW_LIGHTMAP_SAMPLE_DEBUGGING才能正常工作。
r.TextureStreaming 允许定义纹理流是否启用，可以在运行时更改。
0：关
1：开（默认）
r.TiledDeferredShading 是否使用平铺延迟着色。0关闭，1打开（默认）
r.TiledDeferredShading.MinimumCount 切换到平铺延迟之前必须在屏幕上显示的适用灯的数量。
0意味着所有符合条件的灯（例如，没有阴影，…）呈现平铺延迟。默认：80
r.TogglePreCulledIndexBuffers 切换使用命令“PreCullIndexBuffers”中的预分配索引缓冲区
r.TonemApper.ConfigIndexOverride 直接configindex覆盖。忽略所有其他色调映射器配置文件
r.TonemApper.GrainQuantization 0：低（小性能好处）
1：高（默认，用高频像素模式打8位色彩量化）
r.TonemApper.MergeWithUpscale.Mode ScreenPercentage高档集成到色调映射器通过（如果某些条件适用，例如，没有FXAA），
如果启用这两个功能都是一次完成（更快，包括材料后处理后的色调映射器，包括锐化后影响后处理，例如锐化）
0：关闭，在单独的通行证（默认）
1：始终启用，尝试合并通行证，除非有什么不可能
2：当区域的比例高于r.TonemApper.MergeWithUpscale.Threshold合并，否则可能
r.TonemApper.MergeWithUpscale.Threshold 如果r.TonemApper.MergeWithUpscale.Mode为2，则
在决定是否合并通道时，将放大/缩小之前的区域与之后的区域的比率与该阈值进行比较。原因是如果比率
太低，在较高数量的像素上运行色调映射器的成本要高于两次通过的
成本（例如，如果rScreenPercentage是70或更高，则尝试合并）
r.TonemApper.Quality 在0…5范围内定义色调映射器质量
取决于使用的设置，我们可以选择更快的着色器置换
0：仅基本色调映射器，最低质量
1：+ FilmContrast
2：+晕影
3：+ FilmShadowTintAmount
4：+谷物
5：+ GrainJitter =完整质量（默认）
r.TonemApper.Sharpen 锐化在tonemApper（而不是ES2），实际执行工作正在进行中，夹在10
0：关（默认）
0.5：半强度
1：完整的强度
r.TonemApperFilm 使用新的电影色调映射器
r.TonemApperGamma 0：默认行为
＃：使用固定的gamma＃代替sRGB或Rec709转换
r.TransientResourceAliasing.Buffers 如果为true，则为缓冲区启用暂存资源别名
r.TransientResourceAliasing.RenderTargets 0：禁用
1：为fastVRam渲染器
启用瞬态资源别名2：为所有渲染目标启用瞬态资源别名（实验！）
r.TransitionChecksEnableDX11 在DX11 RHI中启用转换检查。
r.TranslucencyLightingVolumeDim 用于半透明照明的体积纹理的尺寸。较大的纹理会导致较高的分辨率但性能较差。
r.TranslucencyLightingVolumeInnerDistance 第一个音量级联应该结束的距离摄像机的距离
r.TranslucencyLightingVolumeOuterDistance 与第二个音量级联应该结束的相机距离
r.TranslucencyVolumeBlur 是否模糊半透明的照明量。
0：关闭，否则默认为1
r.TranslucentLightingVolume 是否允许更新半透明照明体积。
0：关闭，否则默认为1
r.TranslucentSortPolicy 0：根据摄像机中心点到边界球中心点的距离进行排序。（默认，最适合3D游戏）
1：根据投影到相机的距离进行排序。2：根据固定轴上的投影进行排序。（最适合2D游戏）
r.TranslucentVolumeFOVSnapFactor 在计算音量范围之前，FOV将被捕捉到这个因子。
r.TranslucentVolumeMinFOV 半透明照明体积的最小FOV。防止在放大时弹出照明。
r.TriangleOrderOptimization 控制在优化转换后缓存的三角形顺序时使用的算法。
0：使用NVTriStrip（较慢）
1：使用Forsyth算法（最快）（默认）2：没有三角形顺序优化。（效率最低，仅用于调试目的）
r.UnbindResourcesBetweenDrawsInDX11 在DX11中的材料更改之间解除资源绑定。
r.UniformBufferPooling 如果我们使用RHICreateUniformBuffer中的对象池来创建缓冲区的实际API调用较少
0：off（用于调试）
1：on（优化）
r.Upscale.Panini.D 允许并配置将panini变形应用于渲染的图像。0和1之间的值允许淡化效果（lerp）。
实现从研究论文“Pannini：渲染广角透视图像的新投影”
0：关闭（默认）
0：启用（如果没有使用上采样，需要额外的后处理通道 - 请参阅r.ScreenPercentage）
1：Panini圆柱立体投影
r.Upscale.Panini.S 帕尼尼投影的硬垂直压缩系数。
0：没有垂直压缩因子（默认）
1：硬垂直压缩
r.Upscale.Panini.ScreenFit 帕尼尼投影屏适合的影响因子（lerp）。
0：垂直安装
1：水平安装（默认）
r.Upscale.Quality 定义ScreenPercentage和WindowedFullscreen缩放3d渲染的质量。
0：最近的过滤
1：简单的双线性
2：具有非锐化模板上取样的定向模糊。
3：5抽头Catmull-Rom bicubic，近似Lanczos 2.（默认）
4：13抽头Lanczos 3. 5：36
抽头高斯滤波的非锐化掩模（非常昂贵，但适用于极端上采样）。
r.Upscale.Softness 高斯锐化滤波器的锐化量（r.UpscaleQuality = 5）。如果振铃可见，则减小
1：正常锐化（默认）
0：不锐化（纯高斯）。
r.UseAsyncShaderPrecompilation 如果为true，则尝试在后台线程上异步执行初始化着色器预编译。默认为false。
r.UseFastDebugObjectDiscovery 启用新的优化的调试对象发现
r.UseMobileBloom HACK：设置为1使用手机绽放。
r.UseParallelGetDynamicMeshElementsTasks 如果> 0，并且如果FApp :: ShouldUseThreadingForPerformance（），则GetDynamicMeshElements的部分将并行完成。
r.UseProgramBinaryCache 如果为true，则启用二进制程序缓存
r.UseShaderBinaryCache 如果true为更早的提交生成＆使用单独的二手着色器二进制文件缓存 - 可能是平台甚至设备特定的。默认为false。
r.UseShaderCaching 如果为true，则记录所有着色器和着色器状态，以便它们可以在RHI上反序列化，而不是等待第一次使用。
r.UseShaderDrawLog 如果为true，则记录每个着色器管道使用的所有绘制状态，以便可以批量预先绘制（请参阅：r.UseShaderPredraw）。这可能很昂贵，只能在生成着色器缓存时使用。
r.UseShaderPredraw 在使用现有的绘图日志来批量预渲染着色器之前，要减少因驱动程序内重新编译引起的故障。
r.UseUserShaderCache 如果为true，则着色器缓存将使用（并存储）来自用户目录的绘制日志，否则仅存储在游戏内容目录中的绘制日志
r.VelocityTest 允许为速度渲染启用一些低级测试代码（影响对象运动模糊和TemporalAA）。0：关闭（默认）1：将随机数据添加到我们存储骨骼网格骨骼数据的缓冲区中，以测试代码（在PAUSED中也可以测试）。
r.VertexFoggingForOpaque 导致不透明材料使用每个顶点起雾，其成本更低，并与MSAA正确集成。仅支持前向着色。
r.ViewDistanceScale 控制视图距离比例。基元的MaxDrawDistance由此值缩放。
较高的值将增加观看距离，但是在性能成本方面。
默认值= 1.值应该在[0.0f，1.0f]的范围内。
r.ViewportTest 允许在使用Matinee / Editor时测试不同的视口矩形配置（仅在游戏中）。
0：关（默认）
1…7：各种配置
r.VirtualTexture 如果设置为1，纹理将使用虚拟内存，以便它们可以部分驻留。
r.VirtualTextureReducedMemory 如果设置为1，则通过使用更多打包的布局来减少虚拟纹理的成本。
r.VisualizeOccludedPrimitives 绘制所有被遮挡的图元的框
r.VisualizeTexturePool 允许显示纹理池（目前仅在控制台上）。
0：关闭（默认）
1：开启
r.VolumetricFog 是否允许体积雾功能。
r.VolumetricFog.DepthDistributionScale 缩放切片深度分布。
r.VolumetricFog.GridPixelSize XY体素网格中单元格的大小（以像素为单位）。
r.VolumetricFog.GridSizeZ 在z中使用多少容积雾单元。
r.VolumetricFog.HistoryMissSupersampleCount 为历史值不可用的体素计算的照明样本的数量。
这样可以减少平移或照相机切割时的噪点，但是对体雾计算引入了可变成本。有效范围[1,16]。
r.VolumetricFog.HistoryWeight 每一帧的历史价值应该加权多少。这是可见的抖动和响应之间的折中。
r.VolumetricFog.InjectShadowedLightsSeparately 是否允许体积雾功能。
r.VolumetricFog.InverseSquaredLightDistanceBiasScale 缩放添加到反平方衰减分母的数量。这有效地消除了引起极端混叠的反平方衰减的尖峰。
r.VolumetricFog.Jitter 是否将抖动应用到每帧的体雾计算，实现时间超采样。
r.VolumetricFog.LightFunctionSupersampleScale 缩放切片深度分布。
r.VolumetricFog.TemporalReprojection 是否在体积雾上使用时间重投影。
r.VolumetricFog.VoxelizationShowOnlyPassIndex 当> = 0时，表示单个体素化过程以进行调试。
r.VolumetricFog.VoxelizationSlicesPerGSPass 在单个体素化过程中渲染多少个深度切片（最大几何着色器扩展）。必须重新编译体素化着色器来传播更改。
r.VPLDirectionalLightTraceDistance
r.VPLGridDimension
r.VPLMeshGlobalIllumination
r.VPLPlacementCameraRadius
r.VPLSelfOcclusionReplacement
r.VPlsPreadUpdateOver
r.VPLSurfelRepresentation
r.VPLViewCulling
r.VSync 0：禁用VSync（默认）
1：启用VSync。
r.VSyncEditor 0：在编辑器中禁用VSync（默认）
1：在编辑器中启用VSync。
r.VT.MaskedPageTableUpdates 掩盖页面表更新四边形以减少像素填充成本
r.VT.MaxUploadsPerFrame 每帧最大页面上传数量
r.VT.NumMipsToExpandRequests 除原始请求之外，请求的mip级别数量
r.VT.RefreshEntirePageTable 每帧刷新整个页面表格纹理
r.Vulkan.DelayAcquireBackBuffer 延迟获取后台缓冲区，直到预设
r.Vulkan.EnableValidation 0禁用验证层（默认）
1启用错误
2启用错误和警告
3启用错误，警告和性能警告
4启用错误，警告，性能和信息消息
5启用所有消息
r.Vulkan.IgnoreCPUReads 调试GPU-> CPU读取实用程序。
0将从GPU读取（默认）。
1将从GPU读取，但填充缓冲区而不是从纹理复制。
2不会从GPU读取并填充零。
r.Vulkan.PipelineCacheLoad 0禁用加载管道缓存1以启用使用管道缓存
r.Vulkan.RHIThread 1使用RHI Thread
r.Vulkan.StripGlsl 1删除glsl源代码（默认）
0将glsl源代码保存在每个着色器中进行调试
r.Vulkan.SubmitOnCopyToResolve 在每个RHICopyToResolveTarget调用中将队列提交给GPU。
0：不提交（默认）
1：提交
r.Vulkan.SubmitOnDispatch 0在调度（默认）
1时不做任何特殊的事情，每次调度后提交cmd缓冲区
r.Vulkan.UseGLSL 2使用ES GLSL
1使用GLSL
0使用SPIRV
r.Vulkan.UseRealUBs 如果为true，则在Vulkan ES2模式下启用仿真统一缓冲区。
r.Vulkan.UseSingleQueue 使用相同的队列来强制上传和图形。
0：使用多个队列（默认）
1：始终使用gfx队列进行提交
r.Vulkan.WaitForIdleOnSubmit 等待GPU在每次提交时闲置。用于跟踪GPU挂起。
0：不要等待（默认）
1：等待
r.WarnOfBadDrivers 在引擎启动时，我们可以检查当前的GPU驱动程序，并警告用户有关问题，并建议一个特定的版本
测试是快速的，所以这不应该花费任何性能。
0：关
1：启动时可能会出现一条消息（默认）
2：模拟系统有一个黑名单的NVIDIA驱动程序（UI应该出现）
3：模拟系统有一个黑名单的AMD驱动程序（UI应该出现）
4：模拟系统一个没有列入黑名单的AMD驱动程序（不应该出现UI）
5：模拟系统有一个Intel驱动程序（不应该出现UI）
r.WideCustomResolve 当MSAA被使能时，使用广泛的自定义解析过滤器0：禁用[硬件盒过滤] 1：宽（r = 1.25,12个采样）2：更宽（r = 1.4,16个采样）3：最宽（r = 1.5,20个采样）
r.WireframeCullThreshold 阈值低于在线框视图中的对象将被剔除。
r.XGEShaderCompile 启用或禁用XGE来构建着色器。
0：仅本地构建。
1：使用XGE分配构建（默认）。
r.XGEShaderCompile.BatchGroupSize 指定要用着色器填充的批次数。
着色器遍布这批次，直到所有的批次都满了。
这样在编译少量着色器时，XGE编译就可以变得更宽。
默认= 128
r.XGEShaderCompile.BatchSize 指定要一起批量加入单个XGE任务的着色器数量。
默认= 16
r.XGEShaderCompile.JobTimeout 在开始构建之前等待额外着色器作业提交的秒数。
默认= 0.5 作者：Unreal_Explorer https://www.bilibili.com/read/cv12369508 出处：bilibili
</code></pre>
</details>