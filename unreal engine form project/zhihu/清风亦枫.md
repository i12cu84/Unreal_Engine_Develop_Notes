<details>
<summary>【随机数】生成随机数的算法原理</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/574188247
今天我们来和大家聊聊随机数。

大家如果学过编程对于随机数应该都不陌生，应该或多或少都用到过。再不济我们每周的抽奖都是用随机数抽出来的，我们用随机数的时候，往往都会加一个前缀，说它是伪随机数，那么这个伪随机数的伪字该怎么解释，什么又是真随机数呢？

真伪随机数

目前学界划分真伪随机数的方式非常简单，一句话就能说明白，凡是用一定的算法使用程序生成的都是伪随机数，通过物理现象产生的随机数才是真随机数。也就是说计算学家们已经证明了仅仅依靠算法是无法生成真随机数的，也可以认为这是一个NP问题。

算法生成的都是伪随机数的证明太过复杂我们可以不去深究，但是什么又叫做物理现象产生的随机数呢？其实也很简单，举个很简单的例子就是抛硬币和掷骰子。当然物理现象不止这些，比如还有电子元件的噪音、元素的衰变等等。

真假随机数之间的最大差别在哪里？其实就在是否可以预测上。计算机算法得出的各种随机数之所以是伪随机数是因为它们的结果都是可以预测的，只要我们知道算法和起始状态以及各种参数，就可以预测下一次随机出来的结果。而真随机数则无法预测，就是纯粹随机的。

但问题来了，抛硬币和掷骰子这些物理现象又是真的随机吗？如果我们知道了硬币的起始状态以及抛掷的角度和力度，是不是可以预测硬币抛掷的结果呢？进一步我们是否可以假设，如果我们能知道所有例子的所有状态，是否所有所谓的随机数都是可以预测的呢？但根据量子力学的测不准原理，我们知道我们无法同时知道粒子的位置和动量，不仅说明了我们无法预测，也说明了我们无法假设预测。

所以某种程度上来说物理现象是不是就是真随机，这就成了一个哲学问题。但至少在计算机领域当中，这个问题是明确的，算法得出的都是伪随机数，只有通过物理现象得出的才是真随机数。

在计算机系统当中，伪随机数都是有周期的，只要我们持续的次数足够多，就可以看到这种周期。而真随机数则不存在这种周期，有一位前辈做过一个随机数可视化实验，也就是把随机数得到的结果做成图片。我们可以直观地对比一下，这是真随机数可视化之后的图片：


看起来像不像是以前的电视收不到信号的时候显示的内容？我们再来看看通过算法生成的伪随机数可视化之后的结果：


对比一下还是挺明显的，明显可以看出来伪随机数是有规律的，这个规律体现出来就是图像当中的纹理。如果大家想要获取真随机数，可以访问http://random.org这个网站，它是免费的，我们可以人为设置上下限来获取指定范围内的随机数。

对比过真伪随机数之后，我们再来看看现在计算机系统当中常用的伪随机数生成算法的原理。

平方取中法

我们首先介绍的是平方取中法，这个方法非常简单粗暴，是用来产生四位随机数的。

具体的逻辑是怎样的呢？首先我们需要一个随机种子，比如2333，我们把这个随机种子进行平方，得到5442889。这个数一共有6位，我们给它左边填充一个0变成05442889，最后取出它的中间四位是4428，这就是我们随机得到的结果。当我们下次再计算随机数的时候，随机数的种子就成了4428。

这个算法的作者是大名鼎鼎的计算机之父冯诺依曼，自从他确定了计算机体系结构之后一直沿用至今。他当时推崇这一算法的原因很简单，计算方便，速度快，也容易排查错误。它认为如果真的设计一个复杂的算法来生成看起来比较好的随机数，可能隐藏的bug比解决的问题还要多。

seed = 2333
def random():
    global seed
    seed = seed ** 2
    return int(str(seed)[1:5])
我写了代码实际运行了一下，结果看起来其实没有那么不靠谱。


LCG算法

冯诺依曼的随机数算法虽然看起来简单，但是非常草率，在很多场合下是显然不能使用的。所以人们又想出了新的算法，这个算法也很简单，看起来英文缩写高大上，其实翻译过来是线性同余法。也就是利用


来生成随机数。

最后返回的结果是上述式子计算之后的结果，abc三个数都是我们选定的参数。当下一次随机的时候，就将上次的结果作为新的种子进行计算。我们写出它的递推公式就是：


这个算法一眼就看明白了，它的核心完全在于abc这三个参数的选择。如果选的不好就不能实现随机数的效果，这里我给大家分享一个业内常用的选择，a=25214903917，b=11，c=2^48?tex = 2^48。这些数不是拍脑袋随便选的，而是计算学家们算出来的。实际上Java JDK当中Random的类采用的就是这样的算法。

seed = 2
def lcg():
    global seed
    seed = (25214903917 * seed) & ((1 << 48) - 1)
    return seed
这种算法实现方式也非常简单，并且得到的效果也不错。如果要增加随机性，我们还可以在输出结果上做一些优化，比如进行位移或者是调换二进制位的顺序等等。但是这种算法也有缺点，就是它的计算方式是固定的，只是随机种子未知。只要愿意，我们是可以通过得到的随机结果去反推这些参数的。

这并不是一个复杂的算法，因此LCG算法得到的随机数不能应用在一些高安全级别的应用上，否则可能会有安全隐患。

梅森旋转算法

LCG算法实现的伪随机数效果还不错，但是周期不够长，很容易被黑客推算出随机种子。后来两个日本学者又研究提出了新的伪随机数算法，在这个算法当中用到了梅森素数，所以称为梅森旋转算法。

简单介绍一下梅森素数，梅森素数的意思是形如


的素数。利用梅森素数的性质可以设计出周期长度为梅森素数长度的随机数周期。比如目前Python、C++11等语言当中用的随机数计算包都是用的这种算法。目前常用的版本周期是


，这是一个巨大的天文数字。

梅森旋转算法的实现原理非常复杂，网上的资料也不多，我看过一些都不是非常好懂。这里就不介绍了，大家感兴趣可以去了解看看。但我个人觉得意义不大，因为实在是用不到，面试也完全不会考。

虽然梅森旋转算法的周期非常非常长，但是仍不是安全的随机数算法，仍然有可能会被黑客破解。只不过和LCG算法相比，被破解的概率以及难度增加了许多。

大家可能很好奇，什么样的算法才是安全的呢？其实业内的安全算法其实挺取巧的，一般的常用方法就是利用一个数学界的难题来设计一个算法。比如RSA加密算法，利用的就是大整数因式分解的问题。这样的问题业内除了暴力计算没有好方法，而暴力计算的复杂度非常非常高，根本不可能在有限时间内有解，自然这个就是一个安全的算法了。如果某位黑客有能力设计出破解的算法来，他根本也不用破解啥，只要把解法发表成论文，自然可以名利双收。

你看随机数这么一个常见的功能下面居然隐藏了这么深的科学原理，而且更加震惊的是以我们人类如此厉害的文明，居然连随机一个数都做不到。不知道大家看到这里又有何种感受呢？

下一篇将为大家介绍一下基于Unity的随机数与随机种子~
</code></pre>
</details>

<details>
<summary>【物理系统】AABB碰撞检测</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/583879987
当试图判断两个物体之间是否有碰撞发生时，我们通常不使用物体本身的数据，因为这些物体常常会很复杂，这将导致碰撞检测变得很复杂。正因这一点，使用重叠在物体上的更简单的外形（通常有较简单明确的数学定义）来进行碰撞检测成为常用的方法。我们基于这些简单的外形来检测碰撞，这样代码会变得更简单且节省了很多性能。这些碰撞外形例如圆、球体、长方形和立方体等，与拥有上百个三角形的网格相比简单了很多。

虽然它们确实提供了更简单更高效的碰撞检测算法，但这些简单的碰撞外形拥有一个共同的缺点，这些外形通常无法完全包裹物体。产生的影响就是当检测到碰撞时，实际的物体并没有真正的碰撞。必须记住的是这些外形仅仅是真实外形的近似。

AABB - AABB 碰撞
AABB代表的是轴对齐碰撞箱(Axis-aligned Bounding Box)，碰撞箱是指与场景基础坐标轴（2D中的是x和y轴）对齐的长方形的碰撞外形。与坐标轴对齐意味着这个长方形没有经过旋转并且它的边线和场景中基础坐标轴平行（例如，左右边线和y轴平行）。这些碰撞箱总是和场景的坐标轴平行，这使得所有的计算都变得更简单。下边是我们用一个AABB包裹一个球对象（物体）：


Breakout中几乎所有的物体都是基于长方形的物体，因此很理所应当地使用轴对齐碰撞箱来进行碰撞检测。这就是我们接下来要做的。

有多种方式来定义与坐标轴对齐的碰撞箱。其中一种定义AABB的方式是获取左上角点和右下角点的位置。我们定义的GameObject类已经包含了一个左上角点位置（它的Position vector）并且我们可以通过把左上角点的矢量加上它的尺寸（Position + Size）很容易地计算出右下角点。每个GameObject都包含一个AABB我们可以高效地使用它们碰撞。

那么我们如何判断碰撞呢？当两个碰撞外形进入对方的区域时就会发生碰撞，例如定义了第一个物体的碰撞外形以某种形式进入了第二个物体的碰撞外形。对于AABB来说很容易判断，因为它们是与坐标轴对齐的：对于每个轴我们要检测两个物体的边界在此轴向是否有重叠。因此我们只是简单地检查两个物体的水平边界是否重合以及垂直边界是否重合。如果水平边界和垂直边界都有重叠那么我们就检测到一次碰撞。


将这一概念转化为代码也是很直白的。我们对两个轴都检测是否重叠，如果都重叠就返回碰撞：

GLboolean CheckCollision(GameObject &one, GameObject &two) // AABB - AABB collision
{
    // x轴方向碰撞？
    bool collisionX = one.Position.x + one.Size.x >= two.Position.x &&
        two.Position.x + two.Size.x >= one.Position.x;
    // y轴方向碰撞？
    bool collisionY = one.Position.y + one.Size.y >= two.Position.y &&
        two.Position.y + two.Size.y >= one.Position.y;
    // 只有两个轴向都有碰撞时才碰撞
    return collisionX && collisionY;
}  
我们检查第一个物体的最右侧是否大于第二个物体的最左侧并且第二个物体的最右侧是否大于第一个物体的最左侧；垂直的轴向与此相似。如果您无法顺利地将这一过程可视化，可以尝试在纸上画边界线/长方形来自行判断。

为更好地组织碰撞的代码，我们在Game类中加入一个额外的函数：

class Game
{
    public:
        [...]
        void DoCollisions();
};
我们可以使用DoCollisions来检查球与关卡中的砖块是否发生碰撞。如果检测到碰撞，就将砖块的Destroyed属性设为true，此举会停止关卡中对此砖块的渲染。

void Game::DoCollisions()
{
    for (GameObject &box : this->Levels[this->Level].Bricks)
    {
        if (!box.Destroyed)
        {
            if (CheckCollision(*Ball, box))
            {
                if (!box.IsSolid)
                    box.Destroyed = GL_TRUE;
            }
        }
    }
}  
接下来我们需要更新Game的Update函数：

void Game::Update(GLfloat dt)
{
    // 更新对象
    Ball->Move(dt, this->Width);
    // 检测碰撞
    this->DoCollisions();
}  
此时如果我们运行代码，球会与每个砖块进行碰撞检测，如果砖块不是实心的，则表示砖块被销毁。如果运行游戏以下是你会看到的：

虽然碰撞检测确实生效，但并不是非常准确，因为球会在不直接接触到大多数砖块时与它们发生碰撞。我们来实现另一种碰撞检测技术。

AABB - 圆碰撞检测
由于球是一个圆形的物体，AABB或许不是球的最佳碰撞外形。碰撞的代码中将球视为长方形框，因此常常会出现球碰撞了砖块但此时球精灵还没有接触到砖块。


使用圆形碰撞外形而不是AABB来代表球会更合乎常理。因此我们在球对象中包含了Radius变量，为了定义圆形碰撞外形，我们需要的是一个位置矢量和一个半径。


这意味着我们不得不修改检测算法，因为当前的算法只适用于两个AABB的碰撞。检测圆和AABB碰撞的算法会稍稍复杂，关键点如下：我们会找到AABB上距离圆最近的一个点，如果圆到这一点的距离小于它的半径，那么就产生了碰撞。

难点在于获取AABB上的最近点P¯。下图展示了对于任意的AABB和圆我们如何计算该点：


首先我们要获取球心C¯与AABB中心B¯的矢量差D¯。接下来用AABB的半边长(half-extents)w和h¯来限制(clamp)矢量D¯。长方形的半边长是指长方形的中心到它的边的距离；简单的说就是它的尺寸除以2。这一过程返回的是一个总是位于AABB的边上的位置矢量（除非圆心在AABB内部）。

//限制运算把一个值限制在给定范围内，并返回限制后的值。通常可以表示为：
float clamp(float value, float min, float max) {
    return std::max(min, std::min(max, value));
}
//例如，值42.0f被限制到6.0f和3.0f之间会得到6.0f；而4.20f会被限制为4.20f。
//限制一个2D的矢量表示将其x和y分量都限制在给定的范围内。
这个限制后矢量P¯就是AABB上距离圆最近的点。接下来我们需要做的就是计算一个新的差矢量D′¯，它是圆心C¯和P¯的差矢量。


既然我们已经有了矢量D′¯，我们就可以比较它的长度和圆的半径以判断是否发生了碰撞。

这一过程通过下边的代码来表示：

GLboolean CheckCollision(BallObject &one, GameObject &two) // AABB - Circle collision
{
    // 获取圆的中心 
    glm::vec2 center(one.Position + one.Radius);
    // 计算AABB的信息（中心、半边长）
    glm::vec2 aabb_half_extents(two.Size.x / 2, two.Size.y / 2);
    glm::vec2 aabb_center(
        two.Position.x + aabb_half_extents.x, 
        two.Position.y + aabb_half_extents.y
    );
    // 获取两个中心的差矢量
    glm::vec2 difference = center - aabb_center;
    glm::vec2 clamped = glm::clamp(difference, -aabb_half_extents, aabb_half_extents);
    // AABB_center加上clamped这样就得到了碰撞箱上距离圆最近的点closest
    glm::vec2 closest = aabb_center + clamped;
    // 获得圆心center和最近点closest的矢量并判断是否 length <= radius
    difference = closest - center;
    return glm::length(difference) < one.Radius;
}    
我们创建了CheckCollision的一个重载函数用于专门处理一个BallObject和一个GameObject的情况。因为我们并没有在对象中保存碰撞外形的信息，因此我们必须为其计算：首先计算球心，然后是AABB的半边长及中心。

使用这些碰撞外形的参数，我们计算出differenceD¯然后得到限制后的值clamped，并与AABB中心相加得到closestP¯。然后计算出center和closest的矢量差D′¯并返回两个外形是否碰撞。

之前我们调用CheckCollision时将球对象作为其第一个参数，因此现在CheckCollision的重载变量会自动生效，我们无需修改任何代码。现在的结果会比之前的碰撞检测算法更准确。
</code></pre>
</details>

<details>
<summary>【物理系统】常用物理碰撞检测方案</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/583887297
最近在写帧同步算法的时候，发现Unity中的碰撞算法执行顺序不可控，会导致不同步的现象，所以就只好自己研究写碰撞检测算法了。

我们是一个3D卡牌RPG类游戏，大概的碰撞可以分为几类：

圆柱体（角色、怪物）
球体
立方体
需要检测的碰撞类型有:

圆柱体和圆形的碰撞
立方体和圆柱体的碰撞
实现思路：

1.矩形与矩形碰撞

一般规则的物体碰撞都可以处理成矩形碰撞，实现的原理就是检测两个矩形是否重叠。

矩形1的参数是：左上角的坐标是(x1,y1)，宽度是w1，高度是h1;

矩形2的参数是：左上角的坐标是(x2,y2)，宽度是w2，高度是h2。

在检测时，数学上可以处理成比较中心点的坐标在x和y方向上的距离和宽度的关系。

即两个矩形中心点在x方向的距离的绝对值小于等于矩形宽度和的二分之一，同时y方向的距离的绝对值小于等于矩形高度和的二分之一。

x方向：| (x1 + w1 / 2) – (x2 +w2/2) | < |(w1 + w2) / 2| 
y方向：| (y1 + h1 / 2 ) – (y2 + h2/2) | < |(h1 + h2) / 2 |
在程序中，只需要将上面的条件转换成代码就可以实现了

2.圆形与圆形碰撞

计算两个圆心之间的距离是否小于两个圆的半径和。

假设

圆形1的左上角坐标是(x1,y1)，半径是r1，

圆形2的左上角的坐标是(x2,y2)，半径是r2。

下面是数学表达式：

(x1 – x2)2 + (y1 – y2)2 < (r1 + r2)2 
3.球型与圆柱体碰撞检测

 1     /// <summary>
 2     /// 检测球体跟圆柱体碰撞
 3     /// </summary>
 4     /// <param name="x1">球体X</param>
 5     /// <param name="y1">球体Y</param>
 6     /// <param name="z1">球体Z</param>
 7     /// <param name="r1">球体半径</param>
 8     /// <param name="x2">圆柱体X</param>
 9     /// <param name="y2">圆柱体Y</param>
10     /// <param name="z2">圆柱体Z</param>
11     /// <param name="r2">圆柱半径</param>
12     /// <param name="h2">圆柱体高度</param>
13     public static bool CheckCircleAndCylinderCollider(float x1, float y1, float z1, float r1,
14     float x2, float y2, float z2, float r2, float h2)
15     {
16         float dx = x2 - x1;
17         float dy = y2 - y1;
18         float dz = z2 - z1;
19         float disSqua = (dx * dx) + (dz * dz);
20         float rSqua = (r1 + r2) * (r1 + r2);
21         bool heightCheck = Math.Abs(y1 - y2) < r1 + h2 / 2;
22         return heightCheck && disSqua < rSqua;
23     }
1.检测两个圆有没有相交

2.检测Y轴的距离是否小于球半径+圆柱体高度的一半

这里是把球体也当成了圆柱体进行检测，好处就是：效率高。 缺点是：不精确，没有考虑X,Z轴的旋转

但由于我们游戏中圆柱体不会有X,Z轴的旋转，所以这样的做法是最高效的

精确性问题：把圆柱体变成胶囊体，两端用两个球体来计算检测，这样会更精确，同时性能也会降低

4.立方体与球型的碰撞

这里先把问题简化成矩形跟圆形的碰撞检测


计算方法是先找到矩形上离圆形最短距离u，然后再比较u是否小于圆形的半径r

1. 首先利用绝对值把 p - c 转移到第一象限，下图显示不同象限的圆心也能映射至第一象限，这不影响相交测试的结果：


2. 然后，把 v 减去 h，负数的分量设置为0，就得到圆心与矩形最短距离的矢量 u。下图展示了4种情况，红色的u是结果。


最后要比较u和r的长度,若距离少于r,则两者相交。可以只求u的长度平方是否小于r的平方。

代码：

bool BoxCircleIntersect(Vector2 c,Vector2 h,Vector2 p,float r)
{
     Vector2 v = abs(p -c);    //第1步:转换至第1象限
     Vector2 u = max(v - h,0); //第2步:求圆心至矩形的最短距离矢量
     return dot(u,u) <= r * r; //第3步:长度平方与半径平方比较
}
这个方法应该是最优的，而且可扩展至任何维度。如矩形不是轴对齐矩形（AABB）而是定向矩形（OBB）,可以把圆心旋转至矩形的座标系。如下：

我这里是实现了一个OBB的包围盒类，记录了坐标,角度，碰撞检测的时候先把圆的角度旋转到OBB的坐标系里

利用旋转公式：

x2 = x * Mathf.Cos(rad) - z * Mathf.Sin(rad);
z2= x * Mathf.Sin(rad) + z * Mathf.Cos(rad);
然后再用上面说的方式计算矩形跟圆是否相交。

最后再通过两者 Y轴的距离 < (圆柱体高度+立方体的高度)/2 ，如果小于则相交。

这种方法的优势：效率高，而且精确。

缺点是这个3D的OBB只能沿Y轴旋转，不过也够用了 。

如果像王者荣耀类型的游戏，感觉不需要扩展到3D，2D检测应该就够用了。
</code></pre>
</details>