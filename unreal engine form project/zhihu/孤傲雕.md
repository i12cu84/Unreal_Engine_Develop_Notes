
<details>
<summary>UE4 物体位置同步相关源码分析浅</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/68343945
前言
多图, 不想在源代码写注释, 不想贴代码块, 看的不清楚
版本4.21混4.22, 区别不大
文章属于旧有文章搬运, 之前在csdn上面
2019.10.27修改一版
物体位置信息同步, 或者说物体的移动同步, 是一个很大的坑, 从个人目前魔改UE4位置同步后, 感觉至少要考虑以下几点
位置信息的数据结构
要减少单次网络同步时的传输数据大小, 但也要包含所需要的完整的位置信息.
同时在降低精度的情况下减少一些数据的大小, 例如降低Location和Rotation的精度, 用更少的位数传播
位置信息的同步触发时间, 生成时间
指控制什么时候位置进行网络同步, 什么时候不需要同步. 以及什么时候生成需要同步的位置信息
位置信息的权威端
以哪一端或者哪里的物体位置, 当做最新位置同步, 作为权威端
如果权威端只在服务器, 那很简单.
如果权威端只在单一客户端, 服务器做验证处理, 此时逻辑也比较简单, 客户端发送位置到服务器, 服务器直接应用(不考虑防作弊, 防作弊的话此时权威端还是服务器, 实现会很复杂和麻烦)
如果权威端在多个客户端和服务器之间切换, 嗯, 坑很深....
接受到位置信息之后的处理, 减少网络传输的延迟频率丢失的一些位置信息带来的影响, 使得整个物体移动平滑, 例如游戏中的角色运动同步
这里面学问很深, 自行百度谷歌(找不到当初看学习的文章了)
判断位置同步信息是否有意义, 丢弃掉无用的位置信息
对旧的信息不做处理, 主要是解决网络的丢包, 延迟等带来的问题
对不是权威端的信息不做处理, 解决一些事件调用先后顺序有别, 状态同步不及时等等的时序问题
UE4 的位置同步是一个比较常用的功能, 实现也比较简单, 只是服务器当方向向客户端同步物体的位置信息.
下文将深扒一下位置同步的代码实现, 以及对一些有坑的地方进行描述.
关键函数和结构体信息
/** Returns the properties used for network replication */
virtual void AActor::GetLifetimeReplicatedProps( TArray< FLifetimeProperty > & OutLifetimeProps ) const
// 在属性同步前调用的一个函数, 这里生成需要同步的位置信息, 并重写是否需要位置同步
/**
 * Called on the actor right before replication occurs. 
 * Only called on Server, and for autonomous proxies if recording a Client Replay.
 */
virtual void AActor::PreReplication( IRepChangedPropertyTracker & ChangedPropertyTracker )
// 生成物体同步信息的函数
/** Fills ReplicatedMovement property */
virtual void GatherCurrentMovement();
// 位置同步的结构体信息
/** Used for replication of our RootComponent's position and velocity */
UPROPERTY(EditDefaultsOnly, ReplicatedUsing=OnRep_ReplicatedMovement, Category=Replication, AdvancedDisplay)
struct FRepMovement ReplicatedMovement;
// Attach相关的结构体信息
/**
 * Used for replicating attachment of this actor's RootComponent to another actor.
 * This is filled in via GatherCurrentMovement() when the RootComponent has an AttachParent.
 */
UPROPERTY(Transient, ReplicatedUsing=OnRep_AttachmentReplication)
struct FRepAttachment AttachmentReplication;
同步属性相关
从最开始的地方说起, UE4中物体位置同步是靠Actor本身属性同步实现的, 如下:
bReplicateMovement 控制是否进行同步
AttachmentReplication 同步Attach相关, 是一个FRepAttachment, 即Relative Position(相对位置)
可以看到这个结构体里面是一个相对位置的同步信息
ReplicatedMovement 同步位置信息, 绝对位置
同步基础的位置信息, 会同步物理状态
LocationQuantizationLevel, VelocityQuantizationLevel, RotationQuantizationLevel三个值是精度, 可以控制Vector和Rotator用多少位传输
控制属性同步及生成位置信息
在属性同步前, 需要生成位置同步信息, 并修改同步条件
ReplicatedMovement同步条件 bReplicateMovement为True
AttachmentReplication同步条件 根组件存在并且根组件不同步
然后我们看一下GatherCurrentMovement函数
该函数在每次属性同步前都会被调用, 以生成相应的位置信息.
bReplicateMovement 生成 ReplicatedMovement
RootComponent->GetAttachParent() 生成 AttachmentReplication
判断是否开启物理, 物理的同步和没有物理的同步方式不一样
开启物理时
会同步位置旋转速度和是否休眠
同时注意在Welded时, 不会进行物理同步(没有接触过)
没有开启物理的情况下
如果有父组件, 相对位置, 生成AttachementReplication
如果无, 绝对位置, 生成ReplicatedMovement
/**
 * 因为工作项目对物体同步相关进行过魔改
 * 有时候会碰到服务器和客户端物体缩放不同步,  不确定是魔改后的问题还是UE4的问题
 * 这个问题未深入研究, 是否存在? 发生条件等都不明确
 * 可能什么时候深扒Actor的生成和初始化同步会明白些 
 */
同步后的处理
这个时候的处理就比较简单了, 在这两个函数中将这些信息设置到本地就行了
OnRep_ReplicatedMovement
有兴趣的自己扒吧
OnRep_AttachmentReplication
判断AttachParent是否存在是Attach还是Detach
Detach就很简单了, 直接调用DetachFromActor
然后判断是否同步位置, 如果同步, 则调用用OnRep_ReplicatedMovement, 应用绝对位置
有坑见下文
一个的问题
注意一下这段长长的注释, 绝对是4.21版本修复的.
Attach相关的相对同步, 会造成上面说的那个问题
这个问题会导致什么呢?
Detach相关的函数同步处理时, 会调用OnRep_ReplicateMovement函数
但由于没有开启bReplicateMovement, ReplicatedMovement属性为空, 是无效值
但由于数据不存在, 会让Actor位置, 旋转归零.
所以, 如果版本较低的请注意了
4.19前绝对有这个bug, 那时候魔改物体同步时, 踩过这个坑
4.20 应该也没有, 工作用的20, 最近再次碰到过这个坑
但自己电脑上只装了15和21(其他的都卸载了), 没有办法(懒)验证了
4.21版本才修复
4.21版本才修复
4.21版本才修复
结语
能用UE4最新的版本就有最新的版本, 虽然会踩很多新坑, 但比踩那些已知bug待修复的坑好的多
2019.10.27, 有时候踩坑踩着, 最后查到官方, 一句已知bug, 某某版本修复.... 很无语...
UE4同步相关的处理做好, 这里位置同步的是实现感觉很简单了
骗赞了, 骗评论了, 不要再一次单机啊.
2019.10.27, 看到这个单机.... 嗯, 没有单机了....
</code></pre>
</details>

<details>
<summary>UE4 物体位置同步相关源码分析浅谈</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/68343945
前言
多图, 不想在源代码写注释, 不想贴代码块, 看的不清楚
版本4.21混4.22, 区别不大
文章属于旧有文章搬运, 之前在csdn上面
2019.10.27修改一版
物体位置信息同步, 或者说物体的移动同步, 是一个很大的坑, 从个人目前魔改UE4位置同步后, 感觉至少要考虑以下几点

位置信息的数据结构
要减少单次网络同步时的传输数据大小, 但也要包含所需要的完整的位置信息.
同时在降低精度的情况下减少一些数据的大小, 例如降低Location和Rotation的精度, 用更少的位数传播
位置信息的同步触发时间, 生成时间
指控制什么时候位置进行网络同步, 什么时候不需要同步. 以及什么时候生成需要同步的位置信息
位置信息的权威端
以哪一端或者哪里的物体位置, 当做最新位置同步, 作为权威端
如果权威端只在服务器, 那很简单.
如果权威端只在单一客户端, 服务器做验证处理, 此时逻辑也比较简单, 客户端发送位置到服务器, 服务器直接应用(不考虑防作弊, 防作弊的话此时权威端还是服务器, 实现会很复杂和麻烦)
如果权威端在多个客户端和服务器之间切换, 嗯, 坑很深....
接受到位置信息之后的处理, 减少网络传输的延迟频率丢失的一些位置信息带来的影响, 使得整个物体移动平滑, 例如游戏中的角色运动同步
这里面学问很深, 自行百度谷歌(找不到当初看学习的文章了)
判断位置同步信息是否有意义, 丢弃掉无用的位置信息
对旧的信息不做处理, 主要是解决网络的丢包, 延迟等带来的问题
对不是权威端的信息不做处理, 解决一些事件调用先后顺序有别, 状态同步不及时等等的时序问题
UE4 的位置同步是一个比较常用的功能, 实现也比较简单, 只是服务器当方向向客户端同步物体的位置信息.

下文将深扒一下位置同步的代码实现, 以及对一些有坑的地方进行描述.

关键函数和结构体信息
/** Returns the properties used for network replication */
virtual void AActor::GetLifetimeReplicatedProps( TArray< FLifetimeProperty > & OutLifetimeProps ) const

// 在属性同步前调用的一个函数, 这里生成需要同步的位置信息, 并重写是否需要位置同步
/**
 * Called on the actor right before replication occurs. 
 * Only called on Server, and for autonomous proxies if recording a Client Replay.
 */
virtual void AActor::PreReplication( IRepChangedPropertyTracker & ChangedPropertyTracker )


// 生成物体同步信息的函数
/** Fills ReplicatedMovement property */
virtual void GatherCurrentMovement();

// 位置同步的结构体信息
/** Used for replication of our RootComponent's position and velocity */
UPROPERTY(EditDefaultsOnly, ReplicatedUsing=OnRep_ReplicatedMovement, Category=Replication, AdvancedDisplay)
struct FRepMovement ReplicatedMovement;

// Attach相关的结构体信息
/**
 * Used for replicating attachment of this actor's RootComponent to another actor.
 * This is filled in via GatherCurrentMovement() when the RootComponent has an AttachParent.
 */
UPROPERTY(Transient, ReplicatedUsing=OnRep_AttachmentReplication)
struct FRepAttachment AttachmentReplication;
同步属性相关
从最开始的地方说起, UE4中物体位置同步是靠Actor本身属性同步实现的, 如下:


bReplicateMovement 控制是否进行同步
AttachmentReplication 同步Attach相关, 是一个FRepAttachment, 即Relative Position(相对位置)


可以看到这个结构体里面是一个相对位置的同步信息

ReplicatedMovement 同步位置信息, 绝对位置


同步基础的位置信息, 会同步物理状态

LocationQuantizationLevel, VelocityQuantizationLevel, RotationQuantizationLevel三个值是精度, 可以控制Vector和Rotator用多少位传输


控制属性同步及生成位置信息


在属性同步前, 需要生成位置同步信息, 并修改同步条件

ReplicatedMovement同步条件 bReplicateMovement为True
AttachmentReplication同步条件 根组件存在并且根组件不同步

然后我们看一下GatherCurrentMovement函数

该函数在每次属性同步前都会被调用, 以生成相应的位置信息.
bReplicateMovement 生成 ReplicatedMovement
RootComponent->GetAttachParent() 生成 AttachmentReplication
判断是否开启物理, 物理的同步和没有物理的同步方式不一样

开启物理时
会同步位置旋转速度和是否休眠
同时注意在Welded时, 不会进行物理同步(没有接触过)

没有开启物理的情况下

如果有父组件, 相对位置, 生成AttachementReplication
如果无, 绝对位置, 生成ReplicatedMovement
/**
 * 因为工作项目对物体同步相关进行过魔改
 * 有时候会碰到服务器和客户端物体缩放不同步,  不确定是魔改后的问题还是UE4的问题
 * 这个问题未深入研究, 是否存在? 发生条件等都不明确
 * 可能什么时候深扒Actor的生成和初始化同步会明白些 
 */


同步后的处理
这个时候的处理就比较简单了, 在这两个函数中将这些信息设置到本地就行了

OnRep_ReplicatedMovement


有兴趣的自己扒吧

OnRep_AttachmentReplication


判断AttachParent是否存在是Attach还是Detach

Detach就很简单了, 直接调用DetachFromActor
然后判断是否同步位置, 如果同步, 则调用用OnRep_ReplicatedMovement, 应用绝对位置

有坑见下文

一个的问题


注意一下这段长长的注释, 绝对是4.21版本修复的.

Attach相关的相对同步, 会造成上面说的那个问题

这个问题会导致什么呢?

Detach相关的函数同步处理时, 会调用OnRep_ReplicateMovement函数

但由于没有开启bReplicateMovement, ReplicatedMovement属性为空, 是无效值

但由于数据不存在, 会让Actor位置, 旋转归零.

所以, 如果版本较低的请注意了
4.19前绝对有这个bug, 那时候魔改物体同步时, 踩过这个坑
4.20 应该也没有, 工作用的20, 最近再次碰到过这个坑
但自己电脑上只装了15和21(其他的都卸载了), 没有办法(懒)验证了

4.21版本才修复
4.21版本才修复
4.21版本才修复

结语
能用UE4最新的版本就有最新的版本, 虽然会踩很多新坑, 但比踩那些已知bug待修复的坑好的多
2019.10.27, 有时候踩坑踩着, 最后查到官方, 一句已知bug, 某某版本修复.... 很无语...
UE4同步相关的处理做好, 这里位置同步的是实现感觉很简单了
骗赞了, 骗评论了, 不要再一次单机啊.
2019.10.27, 看到这个单机.... 嗯, 没有单机了...
</code></pre>
</details>

<details>
<summary>UE4资源路径相关整理分析</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/68344592
资源路径相关整理分析
前言
这篇文章的用处也不是很大, 只是涉及到一些, 本着好像没有类似资料的态度分享的
文章属于旧有文章搬运, 之前在csdn上面
核心概念
资源 是用于 虚幻引擎 项目的内容项，可将其看作序列化到文件中的 UObject。
用户可在导入或创建资源时对资源进行命名。
资源路径将依据用户创建或导入资源时指定的文件夹自动设置，它与资源在磁盘上的位置直接关联。
例如:
路径Content/Characters/MyCharacter将至
/UE4/MyProject/Content/Characters/MyCharacter.MyCharacter.uasset。
连接:
官方文档
API相关
资源路径会有以下几种 :




参考 : \Engine\Plugins\Editor\EditorScriptingUtilities\Source\EditorScriptingUtilities\Public\EditorAssetLibrary.h
通常会用到一个结构体


ObjectPath : /Game/NewBlueprint.NewBlueprint
PackageName : /Game/NewBlueprint
PackagePath : /Game
AssetName : NewBlueprint
AssetClass : Blueprint 两者配合, 基本包括了UE4内部代码中各处使用资源路径的形式.

函数库
下面是两个函数库, 包括但不限于资源创建, 重命名, 删除,修复重定向, 导入导出等的帮助函数

UEditorAssetLibrary, 一个蓝图函数库, 里面有一些资源管理的函数
路径 : Plugins\Editor\EditorScriptingUtilities\Source\EditorScriptingUtilities\Public\EditorAssetLibrary.h

IAssetTools, 也是一个资源管理的操作类
路径 : Source\Developer\AssetTools\Public\IAssetTools.h

结语
这篇文章比较水.
/**
 * 原计划写一下相关的东西 :
 * 例如 :
 * 那里用到了那个资源路径类型啊, 怎么获取资源路径类型啊     
 *
 * 资源的一些操作函数啊, 重命名, 创建, 删除, 修复重定向,  
 * 
 * 但好像关联性不强, 且感觉用处不大, 不做资源管理用不到     
 * 但资源管理这个东西坑就多了去了, 现在还在踩坑. 所以就这样吧.
 * 
 * 补充 : 资源管理现在的状态是写了不好用也没有用, 所以, 嗯, 还这样吧
 */
如果对这相关的需要深入了解, 上面有两个函数库, 大致有个目标, 往下深扒代码.
或者从ContentBrower中右键菜单那几个命令往下深扒.
嗯, 代码更有用也更准确一些
如果对这相关的不需要啥更深的了解, 嗯, 就当知识积累吧...
</code></pre>
</details>

<details>
<summary>UE4 Timer(定时器)相关源码分析</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/68346320
前言
文章属于旧有文章搬运, 之前在csdn上面
2019.11.6修改
Timer是定时器, 用途:
延时执行事件
周期性执行事件
参考官方文档
Using Timers
Timer可以...

Timer能...

Timer...

...


编不下去了, 自己百度谷歌吧(手动狗头)

TimerManager

Timer的管理类是FTimerManager, 是一个全局的Timer管理类.


通常通过UWorld::GetTimerManager()获得
可以看到实际实现是先判断GameInstance是否存在, 存在返回UGameInstance的TimerManger, 否则返回UWorld自己的TimerManger





接着, 如上图, TimerManger在UWorld和UGameInstance的构造函数中创建, 调用构造函数, 不试图赋值UGameInstance



在TimerManger的构造函数中, 主要还是给InternalTime设0, 该值是TimerManger内部的一个独立时钟, 在TimerManger的每次Tick调用时计时.


在UWorld::Tick中调用FTimerManager的Tick函数实际执行Timer里面的操作





TimerManger的销毁是在UWorld::FinishDestroy和UGameInstance::FinishDestroy中

delete然后置nullptr, 简单粗暴.

Timer的执行



从堆栈中也可以FTimerManger::Tick被UWorld::Tick调用


如图, 这个函数体主要做了如下内容 :

先调用FTimerManager::HasBeenTickedThisFrame, 并维护LastTickedFrame避免一帧内被多次执行.


然后InternalTime计时, 增加DeltaTime偏移量
接着对ActiveTimerHeap和PendingTimerSet进行一定逻辑处理

ActiveTimerHeap是一个当前活跃的, 待处理的FTimerHandle数组


看while循环体主体逻辑:

不断取堆顶的FTimerHandle, 并得到对应的FTimerData.

如果该FTimerData的状态是可被移除, 那么移除, 继续

不断执行, 直到InternalTimer(内部的独立时钟)大于FTimerData的ExpireTime, 即定时器到时间了, 那么执行一定逻辑, 否则, 没有过时间, 就直接break跳出循环

因为ActiveTimerHeap是按照过期时间排序的




接着看, 如果定时器到时间了, 会将ActiveTimerHeap的堆顶元素移动置CurrentlyExecutingTimer(当前正在执行的Timer), 并更新FTimerData的Status为ETimerStatus::Executing

注意, 这里的CurrentlyExecutingTimer和上文中的TopHandler是同一个值, 所以改Top(FTImerData)修改的是同一Timer的信息

然后, 重点来了

划重点了!

划重点了!

划重点了!


上图圈起来的代码, CallCount(执行次数), 为了避免在两帧之间时间过长而导致丢掉一些定时器的间隔执行, 计算, 两帧之间实际需要执行多少次.

设一个Timer, 每0.1秒执行一次, Tick总共过了5秒, 有

定时器必定执行50次, 执行次数恒定
如果比较卡顿, 每0.5秒执行1帧, 即定时器可能也可以在同一帧执行多次
定时器是假定时, 即期望0.1s, 0.2s, 0.3s, 0.4s, 0.5s执行, 实际可能是0.5s, 0.5s, 0.5s, 0.5s, 0.5s执行5次


而Timer的执行, 实际上也就是绑定的代理执行. 此处略

// 可以参考代理相关的文章自己啃, 难度不大

在执行后有个更新指针的操作, 为了防止执行后无效, 这是为什么呢?

考验你C++功底的时候到了, 自行理解, 此处忽略(手动狗头)


在Timer执行完毕之后, 做清理.

如果Timer不循环, 执行一次, 那么完成使命了, 清理掉吧!

如果Timer代理无效了, 那么无法完成使命, 也清理掉吧!

否则, 嗯, 设置下次时间, 打回去, 接着干活(手动狗头)

// 所以循环Timer啊, Timer对应的代理实际对象啊, 多数是不需要人工维护移除的
// 即多数Timer绑定好, 不清除, 也没啥影响, 他会自动移除无效的Timer



最后再看PendingTimerSet的处理, 这是在当前Tick帧添加的定时器集合, 将里面的定时器添加到ActiveTimerHeap里面

即很明显, Timer最少也会延迟一帧调用

Timer的使用

参照上面若干函数, 最后都通过FTimerManger::InternalSetTimer函数SetTimerForNextTick相关基本同, 略


FTimerManger::InternalSetTimer中在设置Timer时, 会查找一下TimerHandle是否有效, 有效会清除.



接着就是创建一个FTimerData信息, 并维护, 具体略了





最后贴一张使用图, 一些基础知识就懒得提了.

// 基础知识 : TimerHandler清除, 获得剩余时间, 暂停和取消暂停, 是否存在等函数
// 看看头文件, 配合使用即可. 
以及提一下这两个Timer的代理:

DECLARE_DELEGATE(FTimerDelegate)
DECLARE_DYNAMIC_DELEGATE(FTimerDynamicDelegate)
自行参考代理相关文章, 配合使用, 能玩出花(笑)
</code></pre>
</details>

<details>
<summary>UE4 Delegate(委托)相关源码分析(一)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/68373614
前言
文章属于旧有文章搬运, 之前在csdn上面
经过深入了解代理及工作上的深度应用之后, 以及相关知识的学习沉淀, 对本系列做出一版修改与完善
2019.11.20微调
2019.12.1 微调
源码版本4.22


https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates/index.html
UE4委托, 或者说C++委托, 是一个很强的的设计.

当工程项目较大的时候, 会有很大的用处.

无论是模块解耦, 还是扩展接口, 实现替换自定义实现等等, 有很大的价值.

可以说一句负责任的话 :

不使用委托的程序员, 无论单一功能写的有多优秀, 设计的有多合理, 当功能繁杂, 互相关联的时候, 必定会乱成一锅粥.



同时, 由于编程语言的语言特性等等, 实现委托的方式多种多样, 甚至差异很大.

C++由于有函数指针的存在, 代理实现本质上就是存储函数指针并调用

然而由于成员函数指针这个很扯的东西, C++代理的实现方式很黑科技...

C++中实现委托（Delegate） - WisKeyのLullaby - C++博客
Member Function Pointers and the Fastest Possible C++ Delegates - CodeProject
简单实现可以参考下文或自行百度

成员函数指针与高效C++委托 (delegate) - 陈孝勇 - 博客园
delegate委托的C++实现--C++11/14(原创) - 蜀山 - 博客园
C++中实现委托(Delegate)_百度搜索
UE4内部实现了一个强大, 好用的一套代理机制, 可以很灵活方便的使用, 本系列就是深入分析代理相关的源码, 并给出一些应用案例.

// 由于懒, 代理的使用偏新手向的内容自行百度
UE4委托



先打开代理宏定义的文件Engine\Source\Runtime\Core\Public\Delegates\DelegateCombinations.h

近80行的宏定义, 但主体类型只有几种, 其他的是有更多的传入参数, 可以参考下面主要代理

DECLARE_DELEGATE( DelegateName )
定义一个无参普通单播委托
DECLARE_MULTICAST_DELEGATE( DelegateName )
定义一个无参普通多播委托
DECLARE_EVENT( OwningType, EventName )
定义一个无参事件(特殊的多播委托)
DECLARE_DYNAMIC_DELEGATE( DelegateName)
定义一个无参动态单播委托
DECLARE_DYNAMIC_MULTICAST_DELEGATE( DelegateName )
定义一个无参动态多播委托
DECLARE_DELEGATE_RetVal( ReturnValueType, DelegateName )
定义一个无参普通单播委托, 带返回参数
DECLARE_DYNAMIC_DELEGATE_RetVal
定义一个无参动态单播委托, 带返回参数
概况一下就是

UE4委托分普通委托, 动态委托两种, 动态委托是一种特殊的委托
UE4委托都有单播和多播之分
UE4委托中只有单播委托可以带返回参数且只有一个
UE4委托用宏定义时, 参数最多可以传递9个(宏拉倒底部可以看到), 但并不意味着UE4委托最多只能有9个参数
事件是一种特殊的多播, 虽然几乎用不到(下文会特殊声明)
事件 DECLARE_EVENT( OwningType, EventName )
这个东西比较特殊吧, 反正没有用过,虽然看着定义用处不小的样子(笑).

看一下官方定义

事件与组播委托十分相似。
虽然任意类均可绑定事件，但只有声明事件的类可以调用事件 的 Broadcast、IsBound 和 Clear 函数.
这意味着事件对象可在公共接口中公开，而无需让外部类访问这些敏感度函数。
事件使用情况有：在纯抽象类中包含回调、限制外部类调用 Broadcast、IsBound 和 Clear 函数。

http://api.unrealengine.com/CHN/Programming/UnrealArchitecture/Delegates/Events/index.html
按照字面意思, 应该只有定义事件的类可以调用Broadcast这些函数, 可以在框架设计上合理使用, 有些用处

但是!

!!!

经过严谨的实际测试, 并不存在上述功能, 外部仍然可以调用Broadcast, IsBound, Clear等等.




看源码, 事件实际是定义了子类, public继承TBaseMulticastDelegate

将OwningType变成了多播代理的友元类, 嗯, 一切正常

但再往下面看, Broadcast是个public函数

所以友元此处没卵用(笑), 好像不是说的那回事.

不确定是否是版本更新导致的, 或者使用方法不对

官方文档中的版本为4.9, 而网上并没有找到任何与官方文档不同的教程或使用文档

附测试代码, 版本是在4.21测试的, 代码简单, 就不做解释了.

UCLASS()
class GUAO_CPLUSPLUSCODE_API AGUAO_CPlusPlusCodeGameModeBase : public AGameModeBase
{
    GENERATED_BODY()

public:
    virtual void BeginPlay() override;

    DECLARE_EVENT(AGUAO_CPlusPlusCodeGameModeBase, FTestDelegate);
    FTestDelegate TestDelegate;

    FTestDelegate& GetTestDelegate() { return TestDelegate; }

    void CallDelegate();
};

void AGUAO_CPlusPlusCodeGameModeBase::BeginPlay()
{
    Super::BeginPlay();

    TestDelegate.AddLambda([this]() {

        UE_LOG(LogTemp, Warning, TEXT("Delegate broad cast"));
    });
}

void AGUAO_CPlusPlusCodeGameModeBase::CallDelegate()
{
    UE_LOG(LogTemp, Warning, TEXT("This is Game mode"));
    TestDelegate.Broadcast();
}

void AMyActor::BeginPlay()
{
    Super::BeginPlay();

    FTimerHandle TimerHandle;

    GetWorld()->GetTimerManager().SetTimer(TimerHandle, [this]() {

        if (AGUAO_CPlusPlusCodeGameModeBase* CPlusPlusCodeGameMode = Cast<AGUAO_CPlusPlusCodeGameModeBase>(GetWorld()->GetAuthGameMode()))
        {
            UE_LOG(LogTemp, Warning, TEXT("This is actor"));
            CPlusPlusCodeGameMode->TestDelegate.Broadcast();

            UE_LOG(LogTemp, Warning, TEXT("This is actor 2"));
            AGUAO_CPlusPlusCodeGameModeBase::FTestDelegate& Delegate = CPlusPlusCodeGameMode->GetTestDelegate();
            Delegate.Broadcast();

            CPlusPlusCodeGameMode->CallDelegate();
        }
    }, 5.f, false);

}
执行结果

LogTemp: Warning: This is actor
LogTemp: Warning: Delegate broad cast
LogTemp: Warning: This is actor 2
LogTemp: Warning: Delegate broad cast
LogTemp: Warning: This is Game mode
LogTemp: Warning: Delegate broad cast


结论:

事件在类内定义, 但外部只要可以获得, 就可以直接调用对应的Broadcast函数



同时, 也专门下了一个4.9版本, 看是不是版本更新所致

由于旧版本需要vs2013, 而电脑上只有2015和2017, 所以无法编译执行, 无法确定这个是否是历史包袱

但好像, 也是相似的, 定义了一个友元类并public继承, 其他地方还是可以调用public函数...




如果有兴趣可以自己去扒一扒, 看一下怎么回事, 但好像不用他就可以了(手动狗头)

普通单播代理






普通单播代理, 将定义一个TBaseDelegate模版类, 模板类继承自FDelegateBase
并通过DelegateAllocator存储一个IDelegateInstance对象.
IDelegateInstance对象中有代理的实际实现

普通多播代理





普通多播代理, 定义一个TMulticastDelegate模版类, 模板类继承自TBaseMulticastDelegate(FMulticastDelegateBase)


该类核心是TInvocationList这个数组, 存储多个代理处理对象(Delegate Handle), 即上面的单播代理对象FDelegateBase

配合添加和删除函数对该数组进行维护, 来实现多播的逻辑



// Delegate Handle, 之后就叫代理处理对象(Delegate Handle), Handle用的很习惯, 但就是不会翻译





在广播的时候, 遍历数组并依次调用各个代理处理对象

每次都将判断代理处理对象是否有效

有效, 直接执行
无效, 就标志NeedsCompaction为true, 并在最后整理时移除
因此, 使用多播时, 一般只需要考虑绑定代理, 不需要去考虑去解绑代理.

当代理无效的时候, 会被自动移除.

动态单播代理
Dynamic delegates can be serialized, their functions can be found by name, and they are slower than regular delegates.
动态代理可以序列化，它们的函数可以按名称找到，而且它们比常规代理慢。
动态代理官方文档


动态代理定义一个类, 该类时TBaseDynamicDelegate模版子类, 模板类继承自TScriptDelegate

联系前文, 可以得出 :

动态单播代理和普通单播代理的继承树是完全不一致的

因此, 动态单播代理可以被看作是一种特殊的单播代理, 参考下文


动态单播代理只存储了两个变量, TWeakPtr(UObject指针)和FName(函数名称)

并根据ProccessDelegate代理的执行函数, 通过反射系统找到对应的UFunction, 并执行.

动态代理的实现严重依赖于UE4 强大的反射系统, 因此绑定的函数要加上UFUNCTION()宏

也因为依赖于反射, 所以可以被序列化, 即在C++构造函数中绑定, 被保存到硬盘或存储起来

/**
 * 题外话, 个人经验 : 
 * 读码的很多时候, 可以从类的变量上面入手, 所有的方法都是在这些变量的基础上, 执行相应功能, 当变量固定的时候, 功能一般也就对应了.  
 * 或者换一种说法, 程序 = 算法 + 数据结构
 * 数据结构与算法的管理性是很较强的, 数据结构背后可以表达出很多设计思路, 实现思路.
 */




参考上文, AddDynamic等宏, 会将传入的函数指针, 转换成相应的函数名称
当然, 也可以直接传递函数名称, 调用BindFunction即可

动态多播代理




和多播普通代理类型, 不做深入分析.

只补充一点, 如图, 动态多播可以通过添加BlueprintAssignable标记, 暴露给蓝图使用, 在蓝图中进行绑定
结语
DECLARE_EVENT这个是写的时候不在计划的东西, 然后找资料文档, 然后写的, 如果有错, 欢迎指出.
/*
 * DECLARE_EVENT没有用过, 从文档上看过, 一直以为是特殊的多播.
 * 然后就试着深扒了一下, 发现好像没什么用...
 * 但感觉上UE4 应该不会专门写一个没用的东西, 并花篇幅介绍. 
 * 所以测试了一下, 结果, 好像就是没什么用....
 */
</code></pre>
</details>

<details>
<summary>UE4 Delegate(代理)相关源码分析(二)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/68374911
前言
文章属于旧有文章搬运, 之前在csdn上面
经过深入了解代理及工作上的深度应用之后, 以及相关知识的学习沉淀, 对本系列做出一版修改与完善
2019.11.20微调
源码版本4.22
本文是对前文的补充说明, 代理最后通过多种代理处理对象(Delegate Handle)来实现的

先会简单描述一下普通代理的绑定使用, 然后再说.

UE4有多种代理处理对象类型, 对应多种情况

TBaseStaticDelegateInstance
TBaseFunctorDelegateInstance
TWeakBaseFunctorDelegateInstance
TBaseRawMethodDelegateInstance
TBaseSPMethodDelegateInstance
TBaseUFunctionDelegateInstance
TBaseUObjectMethodDelegateInstance
本文会草草的带着浏览一下这些类, 之后对一些做深入分析

TBaseDelegate 代理基类

TestDelegate = FTestDelegate::CreateUObject(this, &AGUAO_CPlusPlusCodeGameModeBase::TestFunc);
TestDelegate = FTestDelegate::CreateUFunction(this, "TestFunc");

// 补充一个多播的例子
TestMultiDelegate.Add(FTestMultiDelegate::FDelegate::CreateUObject(this, &AGUAO_CPlusPlusCodeGameModeBase::TestFunc));
创建是Create**, 是一个静态函数, 返回一个TBaseDelegate类型的代理
用法和上述Bind***区别不大, 只是使用的地方有一定区别

// 例
GetWorld()->GetTimerManager().SetTimerForNextTick(FTimerDelegate::CreateUObject(this, &AGUAO_CPlusPlusCodeGameModeBase::TestFunc));
BindWeakLambda

BindWeakLambda这个是4.21新加功能, 因为一些原因, 单独拆出来说吧.

/**
 * 嗯, 这个功能很有用
 * 写代码的时候常常为了省事, 省略一个函数定义, 定时器绑代理的时候绑Lambda表达式
 * 但当代理执行的时候, this可能是野指针, 崩溃(TAT)
 * 今天查并写WeakLambda这个新功能的时候, 发现编译不过.
 * 然后翻到了一个github, 然后发现他的写法. 骚!
 * 就是用一个弱指针来检测一遍指针是否有效
 * 从而导致BindWeakLambda用处也没有那么大了(笑)
 * https://github.com/UnrealPhx/STGContainer/commit/07128dbdf96da3cbc64bd558399d83d6231f5cff
 */
TestDelegate.BindLambda([this, ref = FWeakObjectPtr(this)]() {
    if (!ref.IsValid()) return;

    UE_LOG(LogTemp, Log, TEXT("test"))
});
这个BindWeakLambda是4.21新添加的功能呢, 但是4.21编译不过.

1>d:\program files\Epic Games\UE_4.21\Engine\Source\Runtime\Core\Public\Delegates/DelegateInstancesImpl.h(976): error C2976: 'TWeakBaseFunctorDelegateInstance':
 too few template arguments
1>  d:\program files\Epic Games\UE_4.21\Engine\Source\Runtime\Core\Public\Delegates/DelegateInstancesImpl.h(964): note: see declaration of 'TWeakBaseFunctorDelegateInstance'
1>  d:\program files\Epic Games\UE_4.21\Engine\Source\Runtime\Core\Public\Delegates/DelegateInstancesImpl.h(1074): note: see reference to class template 
instantiation 'TWeakBaseFunctorDelegateInstance<UserClass,TTypeWrapper<void> (void),FunctorType>' being compiled
1>          with
1>          [
1>              UserClass=AGUAO_CPlusPlusCodeGameModeBase,
1>              FunctorType=AGUAO_CPlusPlusCodeGameModeBase::BeginPlay::<lambda_a491337fa493fb663253027637c75487>
1>          ]
1>  d:\program files\Epic Games\UE_4.21\Engine\Source\Runtime\Core\Public\Delegates/DelegateSignatureImpl.inl(146): note: see reference to class templ
ate instantiation 'TWeakBaseFunctorDelegateInstance<UserClass,void (void),AGUAO_CPlusPlusCodeGameModeBase::BeginPlay::<lambda_a491337fa493fb663253027637c75487>>' being compiled
1>          with
1>          [
1>              UserClass=AGUAO_CPlusPlusCodeGameModeBase
1>          ]
1>  d:\program files\Epic Games\UE_4.21\Engine\Source\Runtime\Core\Public\Delegates/DelegateSignatureImpl.inl(430): note: see reference to function template 
instantiation 'TBaseDelegate<void> TBaseDelegate<TTypeWrapper<void>>::CreateWeakLambda<UserClass,T,>(UserClass *,FunctorType &&)' being compiled
1>          with
1>          [
1>              UserClass=AGUAO_CPlusPlusCodeGameModeBase,
1>              T=AGUAO_CPlusPlusCodeGameModeBase::BeginPlay::<lambda_a491337fa493fb663253027637c75487>,
1>              FunctorType=AGUAO_CPlusPlusCodeGameModeBase::BeginPlay::<lambda_a491337fa493fb663253027637c75487>
1>          ]
1>  d:\program files\Epic Games\UE_4.21\Engine\Source\Runtime\Core\Public\Delegates/DelegateSignatureImpl.inl(430): note: see reference to function 
template instantiation 'TBaseDelegate<void> TBaseDelegate<TTypeWrapper<void>>::CreateWeakLambda<UserClass,T,>(UserClass *,FunctorType &&)' being compiled
1>          with
1>          [
1>              UserClass=AGUAO_CPlusPlusCodeGameModeBase,
1>              T=AGUAO_CPlusPlusCodeGameModeBase::BeginPlay::<lambda_a491337fa493fb663253027637c75487>,
1>              FunctorType=AGUAO_CPlusPlusCodeGameModeBase::BeginPlay::<lambda_a491337fa493fb663253027637c75487>
1>          ]
1>  d:\Unreal Projects\GUAO_CPlusPlusCode\Source\GUAO_CPlusPlusCode\GUAO_CPlusPlusCodeGameModeBase.cpp(17): note: see reference to function 
template instantiation 'void TBaseDelegate<TTypeWrapper<void>>::BindWeakLambda<AGUAO_CPlusPlusCodeGameModeBase,AGUAO_CPlusPlusCodeGameModeBase::BeginPlay::
<lambda_a491337fa493fb663253027637c75487>,>(UserClass *,FunctorType &&)' being compiled
1>          with
1>          [
1>              UserClass=AGUAO_CPlusPlusCodeGameModeBase,
1>              FunctorType=AGUAO_CPlusPlusCodeGameModeBase::BeginPlay::<lambda_a491337fa493fb663253027637c75487>
1>          ]
1>  d:\Unreal Projects\GUAO_CPlusPlusCode\Source\GUAO_CPlusPlusCode\GUAO_CPlusPlusCodeGameModeBase.cpp(15): note: see reference
 to function template instantiation 'void TBaseDelegate<TTypeWrapper<void>>::BindWeakLambda<AGUAO_CPlusPlusCodeGameModeBase,AGUAO_CPlusPlusCodeGameModeBase::
BeginPlay::<lambda_a491337fa493fb663253027637c75487>,>(UserClass *,FunctorType &&)' being compiled
1>          with
1>          [
1>              UserClass=AGUAO_CPlusPlusCodeGameModeBase,
1>              FunctorType=AGUAO_CPlusPlusCodeGameModeBase::BeginPlay::<lambda_a491337fa493fb663253027637c75487>
1>          ]
1>d:\program files\Epic Games\UE_4.21\Engine\Source\Runtime\Core\Public\Delegates/DelegateInstancesImpl.h(1075): error C2976: 'TWeakBaseFunctorDelegateInstance': 
too few template arguments
1>  d:\program files\Epic Games\UE_4.21\Engine\Source\Runtime\Core\Public\Delegates/DelegateInstancesImpl.h(964): note: see declaration of 'TWeakBaseFunctorDelegateInstance'
经评论区许多提醒, 并验证, 使用4.22.2版本编译过了...

所以这个新的功能使用要注意版本, 旧版本可以参考上文中github那位大神的操作, 新版本直接使用即可.

普通单播代理执行

上文有讲到, 普通单播代理, 通过过DelegateAllocator存储一个IDelegateInstance对象

通过IDelegateInstance这个对象来实现代理的绑定执行的.

这篇文章, 是对这里的补充, 即描述IDelegateInstance对象相关内容.


接着, 来看一下FDelegateBase的变量, 有DelegateAllocator(代理的一块内存)和DelegateSize(代理内存的尺寸).


嗯, 再结合上面的GetDelegateInstanceProtected强转函数...

嗯, IDelegateInstance代理实例可以很大可以很小, 内存空间是不固定的.

因此, 也就有了下文即之后很大的变数....



我们先来看基础的C++相关系列代理, 然后再看UE4独有的系列代理


TBaseStaticDelegateInstance (Static)

TTuple, 同C++的元组, 用来存储一些预绑定的参数
人宅：UE4 TTuple 使用技巧
FDelegateHandle用来标识不同的代理处理对象, 是一个uint64的ID

FFuncPtr, 看写法, 这是一个函数指针, 用于绑定普通的C++函数

TBaseStaticDelegateInstance是一个简单的, 可以绑定一个C++函数指针的代理

TBaseRawMethodDelegateInstance(Raw)


FMethodPtr, 看写法, 这是一个成员函数指针, 用于绑定成员函数或者结构体函数
TBaseRawMethodDelegateInstance是一个简单的, 可以绑定一个C++成员函数指针或结构体函数的代理

TBaseSPMethodDelegateInstance (ThreadSafeSP & SP)

与TBaseRawMethodDelegateInstance相比, UserClass变成了TWeakPtr, 可以看做是升级版, 绑定的是一个弱指针, 合理使用, 可以避免野空指针等问题.

TBaseSPMethodDelegateInstance是可以绑定一个C++成员函数指针或结构体函数的代理, 但对象指针或者结构体指针是一个弱指针

TBaseFunctorDelegateInstance(Lambda)

这是Lambda的, 看不懂

TBaseFunctorDelegateInstance是一个可以绑定C++ Lambda函数的代理

即可以绑定匿名函数的代理

TWeakBaseFunctorDelegateInstance (Lambda)




相比TBaseFunctorDelegateInstance, TWeakBaseFunctorDelegateInstance 多存储了一个TWeakObjectPtr<>, 可以通过检测该对象(UObject)弱指针是否为空, 来判断代理是否有效.

TWeakBaseFunctorDelegateInstance是一个可以绑定C++ Lambda函数的代理

即可以绑定匿名函数的代理, 额外需要一个TWeakObjectPtr(UObject对象弱指针), 该指针用作判断代理是否有效

UFunction & UObject系列
TBaseUObjectMethodDelegateInstance

TBaseUObjectMethodDelegateInstance存储一个TWeakObjectPtr的UObject弱指针和一个FMethodPtr函数指针

TBaseUObjectMethodDelegateInstance是一个可以绑定UObject函数的代理

TBaseUFunctionDelegateInstance

TBaseUFunctionDelegateInstance存储一个TWeakObjectPtr的UObject弱指针和FunctionName函数名称.

通过函数名称, 依靠反射系统, 得到相应的UFunction并调用执行

TBaseUFunctionDelegateInstance是一个可以绑定UObject反射函数的代理

代理处理对象预绑定多个参数
这个功能在不同语言, 或者不同的地方有各种称谓, 如果遇到类似的写法, 应该能明白是怎么回事.

如果不明白, 就简单的说一点, 给要执行的函数提前绑定一个参数.

这个功能仅能用C++写, 此处, C++比蓝图方便友好很多.


这个功能用处很大的, 嗯, 一时找不到好例子, 就简单的贴张图, 类似的两个代理, 能满足工作中所有相关需求

一个暴露给蓝图, 做一些简单扩展, 另一个给C++, 做各种复杂处理


下面是上面功能的一个demo, 仅供参考

// .h

DECLARE_DELEGATE(FTestDelegate)
DECLARE_DELEGATE_OneParam(FTestWithIntDelegate, int32)
DECLARE_MULTICAST_DELEGATE(FTestMultiDelegate)

/**
 * 
 */
UCLASS()
class GUAO_CPLUSPLUSCODE_API AGUAO_CPlusPlusCodeGameModeBase : public AGameModeBase
{
	GENERATED_BODY()
	
public:
	virtual void BeginPlay() override;

	FTestDelegate TestDelegate;
	FTestMultiDelegate TestMultiDelegate;

	void TestFunc();
	void TestFuncWithInt(int32 Int);
	void TestFuncWithString(FString String);

	FTestWithIntDelegate TestWithIntDelegate;
	void TestFuncWithInt2(int32 Int, int32 Int2);
};

// .cpp

void AGUAO_CPlusPlusCodeGameModeBase::BeginPlay()
{
	Super::BeginPlay();

	TestDelegate.BindUObject(this, &AGUAO_CPlusPlusCodeGameModeBase::TestFunc);
	TestDelegate.ExecuteIfBound();

	TestDelegate.BindUObject(this, &AGUAO_CPlusPlusCodeGameModeBase::TestFuncWithInt, 2);
	TestDelegate.ExecuteIfBound();

	TestDelegate.BindUObject(this, &AGUAO_CPlusPlusCodeGameModeBase::TestFuncWithString, FString(TEXT("A")));
	TestDelegate.ExecuteIfBound();

	TestWithIntDelegate.BindUObject(this, &AGUAO_CPlusPlusCodeGameModeBase::TestFuncWithInt);
	TestWithIntDelegate.ExecuteIfBound(2);

	TestWithIntDelegate.BindUObject(this, &AGUAO_CPlusPlusCodeGameModeBase::TestFuncWithInt2, 3);
	TestWithIntDelegate.ExecuteIfBound(2);
}

void AGUAO_CPlusPlusCodeGameModeBase::TestFunc()
{
	UE_LOG(LogTemp, Log, TEXT("AGUAO_CPlusPlusCodeGameModeBase::TestFunc"));
}

void AGUAO_CPlusPlusCodeGameModeBase::TestFuncWithInt(int32 Int)
{
	UE_LOG(LogTemp, Log, TEXT("AGUAO_CPlusPlusCodeGameModeBase::TestFuncWithInt %d"), Int);
}

void AGUAO_CPlusPlusCodeGameModeBase::TestFuncWithString(FString String)
{
	UE_LOG(LogTemp, Log, TEXT("AGUAO_CPlusPlusCodeGameModeBase::TestFuncWithString %s"), *String);
}

void AGUAO_CPlusPlusCodeGameModeBase::TestFuncWithInt2(int32 Int, int32 Int2)
{
	UE_LOG(LogTemp, Log, TEXT("AGUAO_CPlusPlusCodeGameModeBase::TestFuncWithInt2 %d-%d"), Int, Int2);
}


/*
输出结果 
LogTemp: AGUAO_CPlusPlusCodeGameModeBase::TestFunc
LogTemp: AGUAO_CPlusPlusCodeGameModeBase::TestFuncWithInt 2
LogTemp: AGUAO_CPlusPlusCodeGameModeBase::TestFuncWithString A
LogTemp: AGUAO_CPlusPlusCodeGameModeBase::TestFuncWithInt 2
LogTemp: AGUAO_CPlusPlusCodeGameModeBase::TestFuncWithInt2 2-3
*/


那么, 这个功能如何实现的呢?

// TTuple<VarTypes...> Payload;
还记得上面所有代理处理对象都有一个TTuple元组吗?

所有预绑定的参数, 都会存储到这个数组中.


然后在最后代理处理对象执行的时候, 先传入调用代理时候的参数, 然后再传入这些预绑定的参数.

具体可以参考下一篇代理文章.

总结
普通代理(C++)有很多的绑定方式
普通代理可以预绑定一些参数，这个机制用处很大
普通代理预绑定的参数, 会在函数调用的时候先传入, 然后传入调用代理时候的参数
</code></pre>
</details>

<details>
<summary>UE4 TWeakObjectPtr 相关分析杂谈</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/68376750
前言
文章吐槽不少, 这个bug(无奈的笑)...
这篇文章是最后一篇csdn旧文章搬运, 之后有做一定的修改
文章于2020.4.9再次修改, 使得内容表述更简单具体.
版本4.24, 非源码版
TWeakObjectPtr

可以看到, 这个TWeakObjectPtr这是一个模版类, 通常我们直接使用的是TWeakObjectPtrBase=FWeakObjectPtr这种版本


嗯, 估计也只有这个版本(手动狗头)

参考FWeakObjectPtr图中注释红框直译 :

FWeakObjectPtr是UObject的弱指针
FWeakObjectPtr在UObject被GC后返回nullptr
FWeakObjectPtr不会影响UObject是否被GC
FWeakObjectPtr不能直接联网使用
当需要使用一个UObject指针, 又不想该类阻止GC的时候, 使用FWeakObjectPtr
使用及bug

填一张图, 12347不解释, 基础知识, 解释下56

Test5的模版参数是const AMyGameMode


当Test5->TestInt 访问的时候, 运算符重载实际操作值是const AMyGameMode*类型, 无法修改const指针对象的成员属性

因此编译报错, 代码注释掉才可以编译通过

Test6的模版参数是AMyGameMode, 但初始化是赋值const AMyGameMode*, 这里的实现实际上去掉了这个const修饰...


此时模版函数参数U是const AMyGameMode



调用TWeakObjectPtrBase构造函数实际调用的是FWeakObjectPtr的operator=函数

而此时传入的UObject参数都直接当做const UObject*处理, 这个和FWeakObjectPtr的实现机制有关, 后文分析.

所以, 单纯TWeakObjectPtrBase实现上, 你传入一个const UObject*和UObject*并没有什么区别.


但是从此之外UE4这里还有三个断言

一个断言检测的写法在4.19被废弃, 根据注释内容, 他应该修改掉其他断言和调用TWeakObjectPtrBase构造函数写法, 然而并没有.

其他两处断言, 由于他自己加了const修饰符, 导致无法检测上述情况, 只能检测

传入参数类型可以转换成模版参数的类型
传入参数类型可以转换成UObject
以此处实际类型为例子, 传入参数类型AMyGameMode可以转换成模版版参数AMyGameMode也能转换成UObject

吃瓜.

综上所述, TWeakObjectPtrBase<>的模版类型是const UObject和非UObject有区别

会影响获得的对象指针带不动const修饰

但创建TWeakObjectPtrBase时, 传入一个const UObject*和UObject*暂无什么区别.

FWeakObjectPtr实现
FWeakObjectPtr只有两个int32属性



// Global UObject array instance
FUObjectArray GUObjectArray;
GUObjectArray参考注释, 这是一个全局管理UObject的类

从其中获得ObjectIndex和ObejctSerialNumber两个值, 用来标识一个UObject



第一个属性ObjectIndex是该UObject自身属性InternalIndex

InternalIndex这个值在UObjectBase创建的时候分配, 又在UObjectBase被释放的时候, 回收, 然后该InternalIndex会重新利用,分配给一个新的UObjectBase, 不断循环

它只保证, 在同一时间内, 不同UObjectBase有各自不同的InternalIndex

但在不同时间, 多个UObjectBase可能拥有一样的InternalIndex

// 重新分配原因很简单, UObjectBase在运行时会不断的被创建和销毁
// 如果该索引只是不断的自增, 而不去重复使用的话, 这个值用int32存储是远远不够的.
// 也会大幅度的限制程序的长时间运行.
// 而重复合理使用, 只说此处, 这个索引至少变成了同时最多存在int32大小的UObjectBase
所以如果只通过InternalIndex去拿UObjectBase, 如果获得到UObjectBase, 不一定是FWeakObjectPtr初始创建的UObjectBase, 可能是其他的UObjectBase(生成的时候使用了这个被回收过得InternalIndex)

那InternalIndex还不够怎么办?

再加一个呗(手动狗头)

所以又有了第二个属性ObjectSerialNumber

嗯, InternalIndex能拿到唯一的UObjectBase对象, 但不确定是哪一个.


那根据创建时的UObjectBase, 创建一个对应的值SerialNumber, 并保证不同对象的SerialNumber不一致.

至此, 通过两个int32值就可以对应唯一的UObjectBase

这也是为什么FWeakObjectPtr创建的时候只需要const UObjectBase*, 他只需要去查找获得这两个int32值, 并不需要修改UObjectBase属性



数据结构确定了, 两个int32值, 并没有什么引用关系, 当然不会阻止GC喽.

GC后, 发现不是同一个UObjectBase, 自然这个对象指针获得的时候就被置空了呗.

再贴一下FWeakObjectPtr的核心函数

FWeakObjectPtr获取UObject指针


FWeakObjectPtr当前指针是否有效

判断是否能获得呗(手动狗头)

下文开始, 则是描述一个bug了!!!


测试代码

// .h
    virtual void BeginPlay() override;

    UPROPERTY(BlueprintReadOnly)
    class AActor* Test;

    TWeakObjectPtr<AActor> Test2;

    UPROPERTY(BlueprintReadOnly)
    class AActor* Test3;

    class AActor* Test4;

// .cpp
    void AGUAO_CPlusPlusCodeGameModeBase::BeginPlay()
    {
        Super::BeginPlay();

        AActor* TempActor = GetWorld()->SpawnActor<AMyActor>();
        Test = TempActor;
        AActor* TempActor2 = GetWorld()->SpawnActor<AMyActor>();
        Test2 = TempActor2;
        AActor* TempActor3 = GetWorld()->SpawnActor<AMyActor>();
        Test3 = TempActor3;

        FTimerHandle TimerHandle;
        GetWorld()->GetTimerManager().SetTimer(TimerHandle, [this]() {
            // 测试一二指针置空, 测试三不置空
            Test->Destroy();
            Test2->Destroy();
            Test3->Destroy();
            Test3 = nullptr;
        }, 5.f, false);

        FTimerHandle TimerHandle2;
        GetWorld()->GetTimerManager().SetTimer(TimerHandle2, [this]() {

            if (Test)
            {
                UE_LOG(LogTemp, Log, TEXT("Test Actor 指针存在"));

                if (Test->IsPendingKillPending() || Test->IsUnreachable())
                {
                    UE_LOG(LogTemp, Log, TEXT("Test Actor 指针存在但已被销毁或无法访问"));
                }
            }
            else
            {
                UE_LOG(LogTemp, Log, TEXT("Test Actor 指针不存在"));
            }

            if (Test2.IsValid())
            {
                UE_LOG(LogTemp, Log, TEXT("Test2 Actor 指针存在"));

                if (Test2->IsPendingKillPending() || Test2->IsUnreachable())
                {
                    UE_LOG(LogTemp, Log, TEXT("Test2 Actor 指针存在但已被销毁或无法访问"));
                }
            }
            else
            {
                UE_LOG(LogTemp, Log, TEXT("Test2 Actor 指针不存在"));
            }

            if (Test3)
            {
                UE_LOG(LogTemp, Log, TEXT("Test3 Actor 指针存在"));

                if (Test3->IsPendingKillPending() || Test3->IsUnreachable())
                {
                    UE_LOG(LogTemp, Log, TEXT("Test3 Actor 指针存在但已被销毁或无法访问"));
                }
            }
            else
            {
                UE_LOG(LogTemp, Log, TEXT("Test3 Actor 指针不存在"));
            }
        }, 2.f, true, 10.f);
    }
在头文件中依次定义

测试一 : UPROPERTY宏
测试二 : TWeakObjectPtr
测试三 : UPROPERTY宏
测试四 : 不带UPROPERTY宏, 不是弱指针
在BeginPlay中依次创建三个Actor, 然后销毁Actor

// 没有测试四代码, 测试四和测试一相同逻辑时, 在销毁后访问会野指针崩溃, 没有日志打印
由于没有其他地方有对这些Actor的引用, 所以在一段时间后打印Actor指针对应的信息, 他们都应该可以被合理GC掉

// 实际情况中会复杂很多
// 单一Actor生命周期来说, 创建销毁会在不同类里面, 甚至不同端(网络同步)
// 从存储Actor指针位置来说, 在多个Actor或UObject都有可能存储, 甚至于F自定义类, 乱起八糟的
// 此时人工追踪他们是否被其他类标记UPROPERTY宏引用什么的是一件很困难的事
在上述代码运行后的输出日志结果如下, 重点是测试1测试2对比和测试1测试3区别

LogTemp: Test Actor 指针存在
LogTemp: Test Actor 指针存在但已被销毁或无法访问
LogTemp: Test2 Actor 指针不存在
LogTemp: Test3 Actor 指针不存在
分析与结论

虚幻4垃圾回收剖析 - 风恋残雪 - 博客园
虚幻GC参考上文及其他地方的分析, 再加上前面对FWeakObjectPtr的分析, 不难得出 :

UPROPERTY会会阻止GC
测试一和测试三对比
测试三销毁后指针置空, 释放, 正常GC, 再次访问时为nullptr
测试一销毁后指针没有置空, 仍然被"引用", 没有释放, 不会被GC, 再次访问时变为nullptr, 但此时Actor已销毁
TWeakObjectPtr不阻止GC, 并可以确认指针是否有效
测试一和测试二对比, Actor直接销毁, 不置空对应指针
测试二正常释放, 正常GC, 再次访问时为nullptr
AActor::Destory 会销毁Actor, 但此时Actor如果有被引用, 不一定会被GC
AActor::Destroy 会销毁AActor, 然后AActor生命周期结束, 进入UObject生命周期
如果UObject被引用, 则不会GC流程, 即AActor::Destroy并不会强制销毁UObject
测试一就是例子
补充(吐槽)

然后上面这些结论会有什么用呢?

举一个可能会复杂点的例子

UPROPERTY()
class AHandTool* HandTool;

// 手拾取工具, 如果工具存在, 调用工具的使用方法, 如果不存在, 调用拾取方法
if (HandTool)
{
    HandTool->Use();
}
else
{
    TryPickUpHandTool();
}
如上图代码, 正常逻辑下一切正常, 指针存在走使用, 不存在走其他

但突然出现特殊情况, HandTool在其他地方被直接销毁了, 他作为一个AActor的生命周期结束了

AActor生命周期结束, 渲染物理网络同步等等逻辑就全部不可靠了

这个时候, 逻辑处理一般是需要把它当做不存在, 即走下面逻辑

但是, 这个时候指针还是

存在的!!!
存在的!!

存在的!

再次执行仍然会继续调用HandTool的Use方法, 而不是走下面捡起其他的HandTool的逻辑

此时逻辑混乱, bug了!

然后查代码, 这里检测了指针是否存在了.

看代码的时候多多少少都会选择忽略掉

代码越复杂, 越容易直接忽略掉.

因为这里实际情况不是空指针, 不是野指针, 是当前指针指向一个无效的Actor

查不到啊? 小白无能为力了, 找老手去了

老手会试着打断点, 大概率会发现这个时候指针还存在 ? ? ?

问题定位到, 解决方案呢?

一头懵, 为啥指针还存在, 不被置空呢???

这Actor不还是存在吗? 为啥又看不到了???

???

谷歌百度各种找解决方法了

...

...

...

/**
 * 杂 (吐槽) : 
 * 单机的时候是很好查的, 很容易直接定位到
 * 但如果是联网呢, 你能直接确定是指针没有被置空
 * 而不是没有被销毁, 不是其他逻辑出了问题, 不是网络同步的先后顺序等等
 * 程序代码逻辑越复杂, 查到这种看起来没问题, 埋得很深的bug越难
 * 查来查去, 等什么时候才会定位到这里呢...
 * 同时, 联网的断点不好打, 打日志也不好查的. 
 * 到最后不是试着避免绕过去或者就放着不管了
 * 
 * 别问为什么这么了解
 * 工作中碰到这个问题, 挂了半年多, 最后某次修改其他地方的时候随手指针检测的时候加写了一个IsPendingKillPending()函数
 * 引擎某些地方看到过, 然后正常了. (论常读源码的重要性)
 * 然后细致的想了想, 嗯, 想通了, 然而并没有什么卵用
 * 
 * 嗯,  大概就是这样了
 */
同时, 这个问题知道了会怎样呢?

治本的, 靠谱的方案 : 将UPROPERTY()代替为TWeakObjectPtr<>, 减少强依赖

将各种Actor生命周期不可控, 但需要临时存储的, 一律强制使用TWeakObjectPtr

但现实吗?

不现实!

那有么有其他方法呢?

有

治标的方案 : 在容易出问题的地方, 指针检测多加一个IsPendingKillPending()

// FUObjectArray这里的IsValid()处理还判断了一个IsUnreachable(), 都使用更可靠

但, 每个地方都这么写吗?

能记住吗?

不浪费性能吗?


有没有好的解决办法呢, 没想到.

嗯, 那蓝图中会有这个问题吗?




蓝图所有指针都会这样检测...

自然是没有了.

同时, 这也说明了, 官方给这个问题, 留下一个多么大的坑...
</code></pre>
</details>

<details>
<summary>UE4 蓝图的一些小技巧(整理)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/68428707
前言
蓝图为主, 但可能有部分和C++相关的.
UE4版本4.22.2, 部分功能旧版本可能没有
下列多数是之前看新手教程或从其他文章中学到的, 这里只是一个整理分享.

由于懒的原因, 图大多都是别人的(笑).

部分出处找不到了, 部分可能不确定出处在哪里就随便指了.

毕竟, 这种技巧分享来分享去, 所有的大前提, 都是UE4官方做了(笑)

同时, 为了尽可能多的包含各种技巧, 写之前又专门搜索了一些.

这些内容会贴出相应连接, 虽然多数是照着官方文档查漏补缺罢了.

下面显示一些常见的小技巧
如果不清楚的话, 感觉你可以多看看蓝图教程了(笑).
基础操作
Blueprint Editor Cheat Sheet
蓝图快捷键



这里只强调红圈标注的, 其余的快捷键部分下文会说道, 部分属于不常用的忽略

红色部分除单独C键外, 其余都是按键盘对应键+鼠标左键, 出现对应的节点.




Get & Set

按Ctrl（get）或Alt（set)将变量直接拖出来



Alt断开引脚

如图, Alt键直接断开引脚



变量公开


不解释

Macros


蓝图宏, 详情见文档

蓝图注释


给单个蓝图节点或多个蓝图节点添加注释, 详情参考官方文档.



打开相应窗口

按住箭头的方向, 一一对应, 防止误操作关掉之后无法找到.


也可以点Reset Layout重置, 简单粗暴



变量展示过滤


第一个是展示父类变量, 默认是不勾选(推荐始终勾选, 不然容易出现找不到变量)
第三个是只展示同步变量. 字面意思.

编译报错

本着写些废话也没啥的态度, 就写了

忽略掉函数, 事件, 接口, 事件调度器, 组件蓝图, 蓝图函数库, 蓝图宏库, 蓝图结构体及其他蓝图的等一些东西.
若不清楚, 自行谷歌.
下面这些内容估计就会有些生僻了, 查漏补缺吧.
快速创建某种类型的变量

同时移动多个引脚

按住Ctrl键, 拖到引脚到另一个地方即可, 如果类型转换不成功, 引脚会自动断开

结构体拆开和合并


数学表达式

如图, 简单方便

但需要注意数学表达是中的变量名称不能和类的变量名称重复

跳出到蓝图节点C++相关代码

可能因为VS关联性问题导致打不开

整理蓝图

啥, 蓝图节点太乱, 不好看?

啥, 没有美术天赋, 连不好?

啥,....

借口, 都是借口, 上面自带的对齐工具, 满足你的所有需求.

实话实说, 蓝图节点不好看, 为什么? 懒.

各种分组功能

图表东西太多, 很乱, 建一张呗.


变量函数太多, 很乱, 建分组呗.


函数过程太长, 很乱, 收缩注释呗.

动图封面
动图封面
连接线交叉重叠, 很乱, 看动图

[Unreal Engine 4] 10 Tips and tricks to use Blueprints - Red Girafe Games 图片来源
综上所述, 蓝图看起来很乱, 只有一个原因, 懒.

那你写一个好看的蓝图, 不, 个人很懒, 更习惯C++(笑)

变量私有化



没用过, 字面理解是的



生成的时候设置变量


如图, 勾选两个选项, SpawnActor选成对应类, 编译后蓝图节点会有变化


蓝图书签


书签功能, 详情见官方文档(没用过)

蓝图调试
详情参考官方文档
Blueprint Debugging Example
Blueprint Debugging
当调试对应对象过多的时候, 只选择某个对象

断点调试


Resume : Resume play-in-editor session
暂停
Frame Skip : Advances a single frame
下一帧
Stop : Stop simulation(Escape)
停止, 快捷键Esc
FindNode : Show current node
当前节点, 来回跳转查代码, 查乱时候的一个定位功能
Step into : Step into the next node to be executed(F11)
逐步, 会进入函数内部执行(如果函数是C++的, 无法进入则忽略往后执行), 快捷键F11
Step over : Step into the next node to be executed in current graph(F10)
逐过程, 跳过函数内部执行, 到下一个节点, 快件键F10

观察变量值


调试工具



里面有堆栈信息啊, 蓝图执行流程啊, 之类比较有用的功能.



结语
原计划是一篇水字数的文章, 然后水着水着, 我艹, 两个小时过去了...

东西写的也有点多和乱了.
这篇是转战知乎的第一篇文章

从后台已有的数据上看, 知乎上旧有文章搬运一天, 各数据远大于过去半年csdn上的

找到组织了(手动装哭)
</code></pre>
</details>

<details>
<summary>UE4 C++和蓝图相关, 功能编写角度的取舍分析与看法</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/68486431
前言
ue4 项目开发经验有限, 且工作开发方向非游戏方向, 有很大的局限性.
下文中的C++为UE C++的简写, 原因, 嗯, 应该都可以理解吧, UE4 C++魔改很多.
同时表达观点
UE C++ & 蓝图 远大于> UE C++ 或 纯蓝图
不接受反驳.
2019.10.27修改一版
嗯, 网上其实有很多类似的文章了, 列出几个

电竞张家辉：In Defense of Blueprint为蓝图辩护

unreal engine4 中c++与blueprint如何取舍，两者是什么样的关系？

https://www.unrealengine.com/en-US/tech-blog/balancing-blueprint-and-c

Blueprints vs C++ for experienced C++ dev

Is it worth beginning C++ or stick to Blueprints?

水一下，问问UE4蓝图和c++的实用性_udk吧_百度贴吧

...
所以, 本文的方向不在于C++和蓝图那个好, 以及分析为什么.

属于偷懒性质的, 写出一些事实性及短期内无法改变的地方

以此为基础, 阐述一些个人看法.


事实 : 蓝图在多人协作上并不友好, 或者说门槛远大于C++, 无论现在还是将来

原因 :

蓝图合并, 新旧版本对比等和代码相比, 差了很多, 毕竟一个二进制文件, 一个文本文件.

也看到官方在不断的优化改进, 但和代码合并相比...

想一想, 多人开发同一张蓝图时, 合并, 加锁, 冲突. 嗯, 画面挺美好的

C++完胜.

事实 : 相同逻辑, 短期内蓝图的绝对会比C++开销更大, 长期来看, 蓝图极限值也只是等同于C++开销

原因 :

陶仁贤：为啥大家都认为 BP 效率低？

嗯!..

C++完胜.


事实 : 蓝图的试错成本远低于C++

原因:

假设人物移动有一个速度值, 请问, 是在C++里面写死, 还是暴露给蓝图?

假设一个特效要控制生成位置偏移量, 时间偏移量等, 是在C++里面写死, 还是暴露给蓝图?

假设有ABCDEFG几件事, 每件事都要发生, 但谁先谁后, 发生一件事后暂停多少再发生另一件事, 要测试了事情发生的效果后, 再做确认.
是在C++里面写, 然后编译, 再修改死循环, 还是暴露给蓝图, 蓝图写改测?

...

在一些细节, 数值微调上面, 及部分逻辑调整上, 蓝图相比C++有绝对优势.

因为蓝图不需要等待C++编译......

// 电脑配置不行, 项目代码又多, 等等.. C++编译正的很慢


这个优势是脚本语言和编译性语言相比, 天然存在的

蓝图完胜.

脚本语言和编译性语言_百度搜索
事实 : 蓝图中(编辑器)对资源引用的友好程度远大于C++(代码中)

原因:

C++中资源路径是资源路径, 是死值, 如果资源被移动, 不会同步修改

而蓝图(编辑器)中则不会, 资源移动后, 偶尔还会留下一个重定向引用, 避免引用丢失.

同时, UE4对资源引用是有维护的, 这个维护不包括也无法直接包括C++里面通过路径直接加载的资源.

蓝图完胜.

/*
做个简单的解释.
C++代码中加载某个粒子, 在动态运行时, 通过字符串拼接, 获得资源路径并加载.
由于这个路径是动态生成的, 在运行前, 是无法得出这个资源路径的.
所以, 有时候会导致打包后, 丢失某些C++里面强行加载的资源.

解决方法, 可以设置到UPROPERTY()变量里面暴露给蓝图或者单独建一个资源DataTable维护
*/
事实 : 蓝图中代码编写没有空指针崩溃, 好像也不会有野指针崩溃

原因:

蓝图运行虚拟机, 会检测有效无效后再执行???

总之, 结果是, 正常情况下, 蓝图写的再马虎, 不会崩溃

而C++一个不注意就崩溃了, 这点蓝图比C++友好很多.

而崩溃对于程序来说, 是种灾难

甚至工作中, 嗯, 你C++基础不是很扎实, 会劝, 用蓝图写吧, 至少不会崩溃(手动狗头)

蓝图完胜



事实 : 蓝图的功能实现是C++的阉割版

原因 :

简单描述, UE4有几种常用类, Actor, UActorComponent, UObject, F开头类C++原生类, S开头Slate类, 以及外部的dll等等

蓝图能写Actor, UActorComponent 和使用部分其他功能, 如果想用F或S类的东西, 需要通过蓝图函数或者其他方式暴露, 才可以.

C++能写全部, 并只多不少.

C++完胜.

事实 : 短期来看C++的可读性, 可维护性远大于蓝图, 长期不好说

原因 :

个人觉得更多的是这一个点, 蓝图没有规范, 没有任何公认的规范, 节点怎么摆放, 怎么连接, 导致每个蓝图都成为了独一无二的"艺术品"

而C++(代码)经过长年发展, 编程规范什么都已经很成熟, 即使小的细节上有差异, 但大的方向上是相同的.

甚至还有官方这一篇长长的规范. Coding Standard


同时, 蓝图会有类似规范吗? 不好说.

有了, 能执行下去吗? 不好说.

执行下去有用吗? 不好说.

笑.

C++完胜



事实 : 蓝图的可调式性远差于C++

原因 :

不考虑蓝图调试好不好用, 只说那些地方可以用蓝图调试

非编辑器模式下命令行运行等等, 不能调试

致命.
部分bug ,蓝图无法调试, 例如C++崩溃(笑).

致命.
项目发行, 好像, 大概, 嗯, 是不可能调试蓝图代码的.

致命.
C++完胜

事实 : 蓝图功能可以单方向依赖C++功能, 而C++功能不能依赖蓝图功能

原因 :

可能事实处语句表达意思有问题, 但应该不差多少, 语文不是很好(笑)

假设 A功能用蓝图开发, B功能和A功能有很多地方有强关联, 需要直接调用A功能的方法

这个时候B功能用蓝图开发, 什么问题都没有.

如果B功能用C++开发, 就会拿不到A功能的类和方法, 这个致命了.

如果B功能必须用C++开发, 那就只好魔改A功能了, 将A功能继承C++空类, 并暴露一些函数给C++.

而如果有一个新的功能C呢? D呢?

每当C++需要添加一个新的功能, 和A功能有关联, 为了访问A功能, 而去不断的修改A功能, 将其暴露给C++.

// 虽然这个问题可以通过反射解决, 但反射会引出新的问题
// 维护C++调用的反射函数和蓝图中函数名称一致, 参数一致的问题

图啥? 有这功夫, 功能都用C++重写了

而反之, A功能用C++开发, B功能蓝图开发, 要用A功能

嗯, 很容易的. 例如现在所有蓝图功能.


上面是几个事实, 个人认为, 全部存在, 且多数是短期甚至长期不可解决的

而, 能解决的问题:

只是现在的问题, 解决后就不是问题了, 这种问题讨论来讨论去, 就很没意思了.

能解决的问题, 官方在试着解决.

不能解决的问题, 官方在试着优化.

毕竟, 蓝图也正的很好用.

下面是个人有上述事实得出的一些结论, 或者一些问题的答案.

结论 :
一个完整的商业项目, 如果功能很多, 并且功能之间会互相关联(近似于废话), 有下列选项:

全部蓝图
蓝图为主, 部分功能C
全部C++

实质上就是选择蓝图为主或者C++为主. 且必定会这做这个选择, 不存在其他选项.

注 : 这里以功能为单位, 功能整体用C++开发, 其中部分用蓝图, 全部C++不意味着无任何蓝图.
// 啥, 你说C++为主, 蓝图为辅, 参考上问, 你会为了那些为辅的蓝图功能累死.

个人观点 :
小及中等项目, 随人, 人会啥用啥, 都不会, 学了再取舍.
大项目或者立志要做成大项目的, C++为主, 不解释.

// 个人感觉, 如果程序人数超过10, 全部用纯蓝图同时开发, 嗯, 会是种灾难(笑)

结论 : 流程越靠近最后, 越适合用蓝图开发

这个是想到的观点, 也是主要想分享的.

/**
说些废话, 个人是蓝图入的UE4 的坑, 然后转C++.

然后就, 嗯, 觉得蓝图麻烦了, 连来连去的, 若不是用C++写更麻烦, 不想用蓝图的.

然后, 写着写着, 好像有些地方蓝图写刚好, 很适合. 同时是C++写很麻烦的地方.

最后, 一合计, 蓝图写的那些地方好像都是最后一步了.
*/
例如 :
子弹射出飞行爆炸, 逻辑C++, 功能C++, 到最后贴花音效特效这些, 需要细微调整, 暴露参数, 函数给蓝图慢慢调.

并不是之前记的一种说法, C++写功能, 蓝图写逻辑

而是这样一种感觉, 越接近最后流程的地方, 这些流程也变化最频繁

例如 : 数值变化, 时间控制, 先后顺序

而这些地方用蓝图改写会很方便, 易于调整, 蓝图的节点数量可控.

或者举个例子

因为某个功能的连锁反应最后导致要给某Actor换材质(联网)

/// ,cpp main
{
    FuncCall()
    ...
    Actor->ServerChangeMaterial(MaterialName)
    ...
    FunCall2()
}

// .cpp actor
void Actor::ServerChangeMaterial(const FName& InMaterialName)
{
    MaterialName = InMaterialName;
    OnRep_MaterialName();
}

void Actor::OnRep_MaterialName()
{
    ChangeMaterialImpl(MaterialName);
}
/// .h
UFUNCTION(BlueprintImplementableEvent)
void ChangeMaterialImpl(const FName& InMenuName);
如上图, 伪代码, 代码简单

// 如果看不懂, 嗯, 好好学习UE4C++再来做取舍吧.
按照上面代码的逻辑来看
主要逻辑都在C++, 不会出现看了一半逻辑, 然后再去看蓝图的情况.
变量同步也在C++, 多人情况下调试等也方便.
而容易变化的修改材质暴露给了蓝图, 这个时候已经到了流程最后一步.
如果需求修改, 改动蓝图就好了.
而如果功能发生变化啦? 重写呗.


而流程越靠前, 或者说距离最终效果越远的地方, 都是各种抽象, 设计的地方, 参考上文所述, 这些地方适合用同一种方式开发. 蓝图或C++. 嗯, 不解释了.

当然, 实际项目中会复杂很多, 但好像, 暴露给蓝图的就是这些东西吧?
不是功能, 不是逻辑, 而是易于变化的地方, 而是在流程最后面的地方.

嗯, 结论就是这个了, 欢迎辩论.

问题 : 一个完整项目中, 一个地方可以用C++写, 也可以蓝图写, 边界比较模糊的情况下, 用什么?
看法:

认真阅读前文, 不是前文中描述的情况, 若是, 再读一遍.
有些时候看起来, 边界模糊能选择, 其实并不能选择, 考虑到之后的功能开发, 功能关联上, 这个地方能用的其实只有C++.
若一个地方, 两个都可以用的时候, 个人倾向于:
如果没有或明确思路, 蓝图试错尝试, 纯蓝图
但如果写的很熟练很早思路清晰, C++混蓝图
如果这个地方需求易修改或者容易被砍掉, 纯蓝图, 需求敲死后视情况改C++
其他情况? ...好像没其他情况了吧.
真能做选择的, 快速实现才是第一目的, 其他都是扯淡.
问题: 一个原型Demo用什么开发?

你觉得什么最快, 并且够用, 就用什么....(手动滑稽)

问题 : 蓝图就是没有C++好用?

杠精, 打一顿就好了. (手动滑稽)

问题 : 我用蓝图的为什么会被用C++的鄙视 ?

因为用C++的也会蓝图, 而你不会C++(手动滑稽)

问题 : 我用蓝图的为什么会被用C++不会用蓝图的鄙视 ?

这种情况没有遇到过...(手动滑稽)

问题 : 游戏开发中...?

打住, 我还没有做过游戏开发(手动滑稽)

</code></pre>
</details>

<details>
<summary>UE4 经验分享系列专栏 介绍与概况</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/69367495
前言
专栏一次申请就过了, 感谢某乎
本文是一篇介绍和概况专栏的文章, 随时会改动.
介绍
这是一个个人的UE4 经验分享专栏

源码分析为主, 经验分享为辅.
虽然皮, 吐槽, 水字数才是根本.
多数文章偏理论, 所以能直接实际应用的东西很少.
多数文章是对源码的直接分析, 逐行过, 可以当做读代码的引子, 一般会根据自己了解情况, 进行一定的补充和扩展, 但前期来看, 水分很多.
如有可能会有专栏是用于实战项目经验分享的, 虽然处于长期鸽子状态(笑)
/**
项目地址 : https://github.com/GuAoDiao/GUAO_TBS
虽然长期鸽子, 但目前来看, 这个玩具项目还是有些东西的.
鸽子的原因, 懒吧.
*/
目的
整理并学习 UE4 相关的知识, 形成一个较为完整的知识体系, 并视能力分享
/**
 * 具体情况见下文概况, 会逐步填充, 同时随着一步一步的学习
 * 嗯,理想状态, 经过不断的完善, 量变引起质变
 * 形成一个完整的UE4 知识体系.
 * 如有不足之处, 欢迎指出
 */
打发时间, 减少在游戏小说漫画动漫等等上面的投入(笑)
/**
 * 现在计划是周更, 
 * 但个人是接受并欢迎催更什么的.
 * 虽然个人很懒, 可能不会更(手动狗头)
 *
 * 欢迎催更, (笑)
 */
面向人群
不是萌新, 不是小白, 不是刚刚入门的UE4学习人士.
如果是上述人群, 建议去看官方视频或其他的入门视频.
该专栏短期内对你们的用处不大, 不会有任何提升
不是纯粹UE4入的编程/程序员, 并只有少量UE4相关实践经验的人
如果只有少量UE4实践经验, 请跟做项目
你们看起来会感觉各种似曾相似的
当然, 如果有耐心啃, 应该会有所收获的(笑)
如果纯粹UE4入的编程/程序员, 感觉UE4相关使用比较得心应手
隔壁C++ Primer或C++ Primer plus等书籍巩固一下C++先.
不然, 很多地方会啃不动的.
其他人群
查漏补缺?
互相交流?
屈尊指导一下?
/**
 * 为什么会有上述面向人群呢?
 * 很简单, 懒.
 * 所以会省略很多偏新手的东西, 很多地方会一笔带过(手动狗头)
 *
 * 原因是 : 作为一个杂学程序员, 学过的很杂很乱, 不成体系都又不是很乱.
 * 并不是从零开始学UE4的, 也忘记怎么入门编程的
 * 并深有感触, 在编程的不同阶段, 层次不同, 同一个描述, 会有不同的理解.
 * 不能保证写出来的东西能被理解, 所以简单的加个门槛吧(笑)
 *
 * 虽然, 无论是谁, 爱看不看(手动狗头)
 */
Gameplay相关
GameMode流程分析
孤傲雕：UE4 Gameplay之GameMode流程分析(一)
孤傲雕：UE4 Gameplay之GameMode流程分析(二) (PlayerController初始化和结束流程)
孤傲雕：UE4 Gameplay之常用类获取方式及浅谈
AActor
AActor完整的生命周期流程分析
孤傲雕：UE4 Actor之Actor流程分析(一)
孤傲雕：UE4 Actor之Actor流程分析(二)
孤傲雕：UE4 Actor之Actor流程分析(三)
孤傲雕：UE4 Actor之Actor流程分析(四)
孤傲雕：UE4 Actor之Actor流程分析(五)
孤傲雕：UE4物体位置同步源码分析
UActorComponent
孤傲雕：UE4 Actor与ActorComponent之间的关联
孤傲雕：UE4 ActorComponent流程分析
Subsystem孤傲雕：UE4 Subsystems 相关源码分析
底层实现相关
Delegate关机制
孤傲雕：UE4 Delegate(代理)相关源码分析(一)
孤傲雕：UE4 Delegate(代理)相关源码分析(二)
孤傲雕：UE4 Delegate(代理)相关源码分析(三)
孤傲雕：UE4 Delegate(代理)相关源码分析(四)
孤傲雕：UE4 Delegate(代理)相关源码分析(五)
UWorld
加载和卸载关卡逻辑
ULevel相关
流关卡相关
无缝切关相关
GC相关
孤傲雕：UE4 TWeakObjectPtr 相关杂谈
定时延迟相关
孤傲雕：UE4 Timer(定时器)相关源码分析
Tick相关分析
基础数据类型
FString, FName, FText, TChar
TMap, TArray, TSet
Asset
资源整理与资源管理相关
加载资源的多种方式区别与取舍
孤傲雕：UE4资源路径相关整理分析
UMG & Slate
杂
Owner, Outer之类的用途深扒
孤傲雕：UE4 SaveGame存档相关分析
Console相关类
编辑器模式下的工具函数开发
UObject系列
孤傲雕：UE4 UObject系列序

孤傲雕：UE4 UObject反射系列(一) Class相关
孤傲雕：UE4 UObject反射系列(二) Class相关
孤傲雕：UE4 UObject反射系列(三) Class相关
孤傲雕：UE4 UObject反射系列(四) Class相关
孤傲雕：UE4 UObject系列之UClass(一)
孤傲雕：UE4 UObject系列之UClass(二)
孤傲雕：UE4 UObject系列之UClass(三)
孤傲雕：UE4 UObject系列之UProperty(一)
网络相关
孤傲雕：UE4 网络相关系列 序
孤傲雕：UE4 网络相关系列 导言

孤傲雕：UE4 网络相关之 网络模式(ENetMode)相关讲解
孤傲雕：UE4 网络相关之 网络模式(ENetMode)的获取
孤傲雕：UE4 网络相关之网络驱动器(UNetDriver)的顺藤摸瓜
孤傲雕：UE4 网络相关之网络版本获取与比对
孤傲雕：UE4 网络相关之网络连接的建立UPendingNetGame
杂谈
孤傲雕：UE4 蓝图的一些小技巧(整理)
孤傲雕：UE4 C++和蓝图的取舍分析与看法
想到哪里写哪里
</code></pre>
</details>

<details>
<summary>UE4 Delegate(代理)相关源码分析(三)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/69372821
前言
经过深入了解代理及工作上的深度应用之后, 以及相关知识的学习沉淀, 对本系列做出一版修改与完善
2019.11.24修改... 错误好多
源码版本4.22
经过前面两篇文章, 嗯, 相信大家对代理相关有了一个初步的认知.

孤傲雕：UE4 Delegate(代理)相关源码分析(一)
孤傲雕：UE4 Delegate(代理)相关源码分析(二)

这篇文章呢, 就一起来分析一个代理处理各种宏啊, 实现等等

所以, 恭喜你, 你要开始读天书了(手动狗头)


截一张运行时的图, 然后正着一步一步推.


首先, 基础内容是一, 定义了一个普通单播代理 FTestDelegate

1->2->3 : 宏展开, 如上图, 最终得到了TBaseDelegate<void>


如上图, 调试看, 变量类似也是这个值


DECLARE_DELEGATE(FTestDelegate)

= typedef TBaseDelegate<void> FTestDelegate;


然后再接着看


如果返回参数void, 实际, 这里有一个默认模版定义, 继承自 TBaseDelegate<TTypeWrapper<void>, , ParamTypes...>

此时, 展开得到 TBaseDelegate<TTypeWrapper<void>>


在跳一层, 嗯, 好像也没做什么(手动狗头)

参考Engine\Source\Runtime\Core\Public\Templates\TypeWrapper.h上面的注释

嗯, 自己理解去吧, 有些东西...

TestDelegate = FTestDelegate::CreateUObject(this, &AGUAO_CPlusPlusCode22GameModeBase::TestFunc);
接着我们看调用, 创建代理, 这里用的是FTestDelegate::CreateUObject的方式


..., 各种template, typedef

一步一步拆


先来看函数返回值

1->2 : RetValType是上面Typedef的类型, 直接替换

2->3 : 将实际调用的模版类型替换

3->4 : 同上, 略

即, 此处调用CreateUObject, 返回值是TBaseDelegate<void>, 与之前分析是完全一致的


继续

第一个函数参数, UserClass模版类型, 易得, 此处为AGUAO_CPlusPlusCode22GameModeBase

第二个函数参数类型TMemFunPtrType, 字面意思, 成员函数指针的类型


定义如上, 第一个模版类型bool值是该函数指针是否为const函数


注意这里将两个变长模版参数的先后顺序:

前面是调用代理时候的参数, 即代理定义时需要的参数类型, 后面是预绑定的参数类型.

// 啥? 不知道, 看上一篇文章去
嗯, 经过一系列转换, 我们得到了一个成员函数指针, 再次简化如下


最后是一个TBaseUObjectMethodDelegateInstance<false, UserClass, TFuncType, VarTypes...>


再次简化如下




接着, 就再往下跳

分析TBaseUObjectMethodDelegateInstance了


嗯, 又是一堆,,, 一个一个慢慢拆吧, 基本雷同, 懒得写了.(手动狗头)


这个已经不是很复杂了, 最后调用构造函数, 对这些进行赋值.


再看一下这个类的参数.

嗯, 类, 函数指针, 预绑定参数, 唯一标识符.

到这里代理的创建和绑定就算完成了

这是一个简单的void, 无参数的UObject代理一个分析

而上一篇文章的其他几种代理与这个, 差别不大, ,很简单的, 就不做分析了

至于多个参数的代理, 嗯 替换参数部分内容就行, 也很简单的, 也不做分析了

(小声逼逼, 懒得心安理得)

然后, 我们在看一下代理如何使用



从上到下, 总共4组.

第一组 :

可以看到, FTestDelegate是一个int32参数的单播代理, 但这里传入了一个默认值int32

再结合之前分析, 很容易得出 :

代理可以预绑定参数, 并可以绑定多个

第二组 :

代理绑定函数TestFunc2和TestFunc3, TestFunc2可以绑定, TestFunc3不行

而TestFunc2是FString在后, TestFunc3是FString在前

再结合之前分析, 很容易得出 :

调用时代理时传递的参数在先, 代理预绑定的参数在后.

第三组 :

代理绑定的都是TestFunc2, 都是一个字符串, 但写法TEXT("")不通过, FString(TEXT(""))写法通过, 两者区别在, 前者是 const wchar_t*类型, 后者是FString类型

再结合之前分析, 很容易得出 :

传入代理的函数指针中, 函数指针参数类型, 由代理默认参数类型和预绑定参数类型决定.

第四组 :

绑定TestFunc2无引用可以, 绑定TestFunc3或TestFunc4带引用不行

代理BindXXX预绑定参数不可以传递引用或者const 引用

// 预绑定参数不能绑定引用吗???可以的, 详情见代理四.

最后来分析代理的执行, 这一块的东西有很多C++的知识点

接触不多, 如有不足或者错误的地方, 欢迎指出.


首先调用了一个TTuple的ApplyAfter


decltype_百度搜索
decltype是用于推断类型, 这里是用来推断返回类型是什么, 单播代理可以定义带返回值的, 或者为void

std::forward_百度搜索
C++11 std::move和std::forward
[c++11]我理解的右值引用、移动语义和完美转发
可以看到这里有参数传递未定义的引用类型


我们做个假设, 传了一个引用, 左值


到最后Execute的时候, 函数参数类型还是通过模版生成的int32&

TTuple的ApplyAfter这里是ArgTypes&&, 从传入值int32& &&推断出int32&

而如果是传了一个值, 右值


TTuple的ApplyAfter这里是ArgTypes&&, 从传入值int32 &&, 嗯, 右值引用


再接着看, Func()是调用这个成员函数指针, 后面是传递的参数, 又用Forward进行了一次完美转发, 并在后面通过this->template Get<Indices>()...获得元组数据, 即预绑定的参数


然后我们看函数, 建了一个结构体, 重写()函数, 将调用时的参数和预绑定的参数再次通过Forward转发, 然后执行这个成员函数, 并返回返回值.

// 自行百度找 左值右值 std::move std::forward decltype等等知识吧, 讲不清
TTuple怎么获得的, 再次挂着吧

上面讲的有点高深?

上面讲的没有用?

那再补充点实在点的.


如图, FTestDelegate是一个无参普通单播代理, 第一个和第三个的代理绑定有问题, 而二正确.

第一个代理

同上文分析过程, 代理1拆分可得如下, 可以看出, 两个函数指针类型是不一样的

函数指针类型是由传入的参数来决定的, 而不是传入的成员函数指针.


所以, 这里1会将TEXT("") 类型读成 const wchar_t*, 和字符串差异很大.

第一个写法对应的代理类型, 参数应该是const wchar_t*




第三个代理
第三个代理与第二个代理的区别 :

第三个代理对应函数定义是const FString&, 同上面分析, 最后成员函数指针应该是


与第三个代理实际的成员函数指针不同, 故写法错误.

第三个代理的正确写法.


自己人工补全模版不就行了 (笑).

/**
 * 题外话, 你会觉得看了这三篇文章就能懂一些代理吗?
 * 
 * 并不会, 个人读码过程中的一些体会心得, 有些是无形写不出来的.
 * 个人读码前编程的一些积累, 也是你看不到的
 * 
 * 看起来, 嗯, 我水了一篇文章, 但实际上, 我学到的东西还是不少的,
 * 随便再摘取一些, 又是一篇水字数的文章.
 *
 * 例如, FTimerManager::AddTimer()的各个函数系列, 你用的时候是不是很方便, 跳一层定义, 你再看一下
 *
 * 估计又会一脸懵逼.(笑)
 *
 * 甚至草草阅读, 放进收藏, 指望着什么时候再看, 嗯, 看了看自己收藏的N多博客, 不想说话(笑).
 *
 * 2019.11.24补
 * 嗯, 才三篇, 没看到我又把三篇整理整理, 又出了第四篇....
 */ 


结语
代理到这里就算告一段落了, 嗯. 如果以下面三个阶段划分的话.

掌握并深入了解UE4代理相关的实现机制.
熟练使用UE4代理并了解部分实现机制.
会使用UE4代理的基础操作.
</code></pre>
</details>

<details>
<summary>UE4 Gameplay之GameMode流程分析(一)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/70045930
前言
源码版本4.22
19.11.17修改一版
文章主要是写Gamemode相关的一些流程分析.

// 下文所有的GameMode类均是AGameModeBase, 对应AGameMode类不会做任何分析
从代码的角度看, 主要分为两个流程 :

游戏开始运行的初始化流程
玩家的登入登出流程
游戏结束时的销毁流程
Game Mode and Game State
大钊：《InsideUE4》GamePlay架构（七）GameMode和GameState
而GameMode相关介绍可以参考上文或自行百度谷歌

因与文章主旨无关, 就不多加阐述了.

下文进行相应的分析, 与UWorld, ULevel, UGameInstance等类关系较强

而其他几个类没有深扒, 有一定的局限性

如有问题, 欢迎指出.

接上, 这篇文章主要是游戏开始运行的初始化流程和游戏结束时的销毁流程

往下会看到AGameMode和AGameState等类相关的一些流程

嗯, 游戏开始时, 没有APlayerController, APlayerState, APawn/ACharacter等这些类

所以AGameMode和AGameState层级比APlayerController等类高一些

前者倾向于游戏, 而后者只是玩家

没有玩家存在, 游戏也可以存在
没有玩家存在, 游戏也可以存在

没有玩家存在, 游戏也可以存在

嗯, 认识到这点之后, 再处理他们的关系, 及看他们流程会清晰很多...

游戏开始运行的初始化流程

如图, 从堆栈信息容易得出, AGameMode在游流程中已经比较靠后了

之前有UEngine, UGameInstance, UWorld类

/**
 * 上面几个类的情况之后可能会进行一定的分析
 * UGameInstance和UWorld的代码啃过, 有点杂乱, 需要时间整理
 * 游戏运行有PIE(Play in Editor)和Standalone的区分, 流程上有一定差距
 * (目前从个人已知情况, 并不影响GameMode之后的相关逻辑)
 */




首先在UGameInstance::StartPlayInEditorGameInstance函数中, UWorld::SetGameMode函数被调用, 该函数会生成关卡对应的AGameMode




如图, 判断是否是服务器, AGameMode仅在服务器端生成, 然后转交给UGameInstance处理

UGameInstance::CreateGameModeForURL是实际创建AGameMode的函数


该函数是一个虚函数子类可以重写.

该函数通过给定的地图URL创建对应的AGameMode

由于函数体较长, 只贴出个人认为关键的地方


默认采用AWorldSettings中的DefaultGameMode



然后是根据不同的参数情况, 获得实际的AGameMode Class

如果无法获得任何有效值, 将取默认值AGameModeBase::StaticClass()
否则还会调用UGameInstance::OverrideGameModeClass, 这个函数可以重写, 再次自定义控制AGameMode 实际的Class


标记ESpawnActorCollisionHandlingMethod::AlwaysSpawn, 忽略碰撞总是生成

标记RF_Transient, 临时对象, 不会保存到硬盘中, 只在运行中存在

最后, SpawnActor, 完成AGameModeBase的创建




如图, C++构造函数中对默认值的处理


这里提个小知识点, 这里bNetLoadOnClient为false

字面意思, 联网模式下客户端是否加载该对象. 不加载

进一步使得该类只在服务器存在


接下来, 在UWorld::InitializeActorsForPlay中调用AGameModeBase::InitGame函数


这里创建了AGameSession并对其进行一定操作



接着, 会按Actor生成流程, 走到AGameModeBase::PreInitializeComponents函数

从图中代码, 也可以看到, 这个调用在AGameModeBase::InitGame之后

// 流程具体参考另一篇文章Actor的流程分析相关




如上图, 这里的主要是生成了两个类: AGameStateBase和AGameNetworkManager

AGameStateBase, 这里创建后进行了初始化, 赋值GameModeClass和SpectatorClass


如图, 很明显, 会通过属性同步, 在各个客户端/服务器调用

执行APlayerController::ReceivedGameModeClass或APlayerController::ReceivedSpectatorClass函数


代码都是虚函数, 可以根据需求, 自己扩展



最后, UWorld::BeginPlay调用AGameModeBase::StartPlay

并实际调用AGameStateBase::HandleBeginPlay



可以看到, 通过属性同步, 会在各端调用AWorldSettings::NotifyBeginPlay 和 AWorldSettings::NotifyMatchStarted两个函数


然后, 划重点, AActor::BeginPlay

嗯, 很显然, 服务器加载地图的时候, 所有AActor的DispatchBeginPlay会先被调用. 并标记bReplicatedHasBegunPlay

然后客户端在属性同步之后, 才调用所有AActor的DispatchBeginPlay

一个时序问题, 可能有坑

// 据说, 时序问题, 会是个很大的问题(手动狗头)
到这里为止, 游戏的初始化流程就基本算完了, 之后就转交给程序员了.

那么, 游戏的结束流程呢?
嗯, 好像, 大概, 主体不在GameMode里面, GameMode只有Actor相关流程, 还没有任何实现

嗯, 所以, 就

没
有
了

呗

!



最后, 贴一个单用户的PIE模式下几个类的BeginPlay调用顺序

LogBlueprintUserMessages: [NewBlueprint_C_0] Game Mode
LogBlueprintUserMessages: [NewBlueprint1_C_0] GameState
LogBlueprintUserMessages: [NewBlueprint2_C_0] Player Controller
LogBlueprintUserMessages: [NewBlueprint3_C_0] Player State
LogBlueprintUserMessages: [NewBlueprint5_C_0] HUD
LogBlueprintUserMessages: [NewBlueprint4_C_0] Pawn

// 创建对应蓝图类, 在蓝图类BeginPlay中打印对应日志
想知道为什么吗?
想知道吗?
接着看吧(手动狗头)

孤傲雕：UE4 Gameplay之GameMode流程分析(二)



结语
这周第一更, 后台数据看需要四更...
所以, 一篇文章拆两篇这种操作习惯就好(笑)
反正单篇文章也不会特别水.
// 题外话, 数据最多的竟然是收藏...
</code></pre>
</details>

<details>
<summary>UE4 Gameplay之GameMode流程分析(二)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/70391404
前言
源码版本4.22
19.11.17修改一版

大钊：《InsideUE4》GamePlay架构（五）Controller
大钊：《InsideUE4》GamePlay架构（六）PlayerController和AIController
大钊：《InsideUE4》GamePlay架构（八）Player

接前文, 孤傲雕：UE4 Gameplay之GameMode流程分析(一)


这篇文章是玩家的登入登出流程相关

同时, 因为篇幅及重点放在AGameMode相关上面, 所有对于联网相关的处理不会展开.


玩家登入登出流程分析如下:

UGameInstance::StartPlayInEditorGameInstance

如果上一篇文章有认真看, 会记得这个函数, 上面UWorld::InitializeActorsForPlay有初始化AGameMode及调用所有的AActor::DispatchBeginPlay

接着, 如果LocalPlayer存在, 那么创建PlayerController

也可以理解成, 如果是一个客户端, 那么创建PlayerController

即专用服务器没有自己的PlayerController


这里根据当前UE4成新是不是服务器有两种处理方式


先跳一层, 这里的是不是服务器判断如上图, 结论得出应该是这里的服务器判断情况(下文的服务器指此处的判断) :

单机运行, 两个NetDriver不存在, 返回true, 单机情况自己就是服务器
联网情况下, 服务器端返回true, 客户端返回false

如果不是服务器情况试下, 直接创建了一个APlayerController, 类型在ULocalPlayer中定义


根据注释翻译, 大致得出 :

引擎认为每个Player都应该有一个有效的APlayerController存在, 所以先创建一个虚假的APlayerController, 但由于权威端是服务器, 所以之后会同步替换成服务器端的APlayerController, 具体情况参考注释中的函数

// 由于篇幅有限及本文主要方向不会深入涉及联网相关内容, 此处不会展开

那, 如果是服务器呢? 或者换种说法, 是NM_ListenServer, 又是服务器, 又是客户端呢?

调用UWorld::SpawnPlayActor, 实际生成APlayerController


整个函数如图, 依次调用了

AGameModeBase::Login
APlayerController::SetPlayer
AGameModeBase::PostLogin
嗯, 这几个函数之后再深入分析, 先停下来.

如果读过AGameModeBase相关源码的, 应该见到过


这两个函数, AGameModeBase::PreLogin不应该在AGameModeBase::Login之前调用吗?
但这里的流程没有看到啊?


而通过搜索这两个函数所有调用过的地方, 发现在只在这个函数UWorld::NotifyControlMessage中有调用过.
而这个函数的处理都是NetDriver存在, 即多人联网时的情况
也就是说, 这两个函数都是多人联网时下才会调用的函数.



/**
 * 这里也只是写文章的时候, 突然发现的, 打断点没有调用.
 * 然后看了下上下文, 嗯, 从代码上看是这样.
 * 如果有错误, 欢迎指出
 * 相关内容深扒, 之后网络篇再说
 */
AGameModeBase::Login

AGameModeBase::Login函数内做了APlayerController的生成和初始化








先看生成, 可以看到, 第一步 是判断是不是旁观者, 然后生成不同的PlayerController




生成的流程比较简单, 然后跳一下APlayerController的AActor生成流程函数


这里调用了下面下个生成函数

APlayerController::InitPlayerState
APlayerController::SpawnPlayerCameraManager
APlayerController::SpawnDefaultHUD

APlayerController::InitPlayerState 生成APlayerState

同时, 如果AGameMode没有给APlayerState的Class, 会自动设置成默认值APlayerState::StaticClass


这个函数内生成了APlayerCameraManager, 略


然后, 生成了一个AHUD, 但注意, 这个HUD没有取AGameMode里面的HUD Class

或者说, 这只是一个临时的HUD

AGameModeBase::InitNewPlayer

在初始化的时候, 先确认PlayerState是否存在, 然后注册到Session


接下来是一个AGameModeBase::FindPlayerStart

还记得地图中的摆放的APlayerStart(玩家出生点)吗?

这里就是这个玩家出生点的位置, 并给到APlayerController


然后是观战和名字的设置, 没有接触, 略

APlayerController::SetPlayer

由于不是重点, 只圈一下认为的关键函数

有设为本地控制器, 初始化联网Session, 初始化输入相关功能

AGameModeBase::PostLogin

先扫一眼, 只看圈中的地方, 先看中间

Session相关, 调用GameSession->PostLogin

调用蓝图的K2_PostLogin和FGameModeEvents::GameModePostLoginEvent代理


然后再看AGameModeBase::GenericPlayerInitialization


从代码上感觉, 核心代码只有这一句, 初始化HUD.

其他代码感觉上是对应一些特殊需求的代码, 没有涉及过, 就忽略了.




嗯, 调用APlayerController::ClientSetHUD实现, 并将HUD的实际类传入, 并生成.

结合前面的内容

如果AGameModeBase中HUD Class
不存在 : 嗯, 也会有一个默认的HUD存在
存在 : 客户端重写生成一个新的HUD
好, 到此为止, 我们又看到了HUD的生成.



接着是AGameModeBase::HandleStartingNewPlayer



同上, 寻找一个玩家出生点, 并调用AGameModeBase::RestartPlayerAtPlayerStart

重新生成玩家角色(APawn)



如上两图, 可能存在无法生成Pawn的情况, 此时会调用AController::FailedToSpawnPawn函数

如果当前Pawn不错, 则会先获得, 要生成Pawn的Class是否存在, 存在才生成.




而生成Pawn的实际函数如图

修改这里前后及相关的代码, 就可以根据自己逻辑, 生成所需要的APawn


当Pawn生成成功后会调用AGameModeBase::InitStartSpot, 空函数 可以自己扩展


而AGameModeBase::FinishRestartPlayer

设置AController的旋转, 并调用蓝图的函数等处理, 暂时忽略

至此一个玩家的登入流程就算完毕了.

// 单机的, GameModeBase层

LogBlueprintUserMessages: [NewBlueprint_C_0] Game Mode
LogBlueprintUserMessages: [NewBlueprint1_C_0] GameState
LogBlueprintUserMessages: [NewBlueprint2_C_0] Player Controller
LogBlueprintUserMessages: [NewBlueprint3_C_0] Player State
LogBlueprintUserMessages: [NewBlueprint5_C_0] HUD
LogBlueprintUserMessages: [NewBlueprint4_C_0] Pawn

// 创建对应蓝图类, 在蓝图类BeginPlay中打印对应日志
上篇文章中的这些类生成顺序, 现在知道为什么了吧...(手动狗头)

登出流程




玩家登出流程, 从APlayerController销毁开始, 依次

销毁Pawn
销毁HUD
销毁PlayerCameraManager
Super::Destroyed
AGameModeBase::LogOut
销毁PlayerState

而AGameModeBase::LogOut没什么东西了, 就不啰嗦了.
</code></pre>
</details>

<details>
<summary>UE4 Actor之Actor流程分析(一)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/70045435
前言
文章之后会修改.
最近一些文章互相关联性较高, 可能随着某篇文章某些内容的深扒, 而导致一些内容更连贯, 并对所有相关内容进行修改
源码版本4.22
大钊：《InsideUE4》GamePlay架构（一）Actor和Component
大钊：《InsideUE4》GamePlay架构（二）Level和World
UE创世，万物皆UObject，接着有Actor。
这是一篇Actor生成到销毁完成流程的代码分析系列, 总篇幅较长.

因为各种原因, 会拆分成多篇文章, 每篇文章相对会独立, 但互相关联性很大.

由于Actor类的生成销毁在UObject基础上, UObject啃不动, 之后单做分析.



Actor Lifecycle Unreal Engine 4 - Game Flow and Actor Lifecycle Overview - bright developers

嗯, 这个看不懂? 看下面的 (出处AActor头文件):

/**
 * Actor is the base class for an Object that can be placed or spawned in a level.
 * Actors may contain a collection of ActorComponents, which can be used to control how actors move, how they are rendered, etc.
 * The other main function of an Actor is the replication of properties and function calls across the network during play.
 * 
 * Actor initialization has multiple steps, here's the order of important virtual functions that get called:
 * - UObject::PostLoad: For actors statically placed in a level, the normal UObject PostLoad gets called both in the editor and during gameplay.
 *                      This is not called for newly spawned actors.
 * - UActorComponent::OnComponentCreated: When an actor is spawned in the editor or during gameplay, this gets called for any native components.
 *                                        For blueprint-created components, this gets called during construction for that component.
 *                                        This is not called for components loaded from a level.
 * - AActor::PreRegisterAllComponents: For statically placed actors and spawned actors that have native root components, this gets called now.
 *                                     For blueprint actors without a native root component, these registration functions get called later during construction.
 * - UActorComponent::RegisterComponent: All components are registered in editor and at runtime, this creates their physical/visual representation.
 *                                       These calls may be distributed over multiple frames, but are always after PreRegisterAllComponents.
 *                                       This may also get called later on after an UnregisterComponent call removes it from the world.
 * - AActor::PostRegisterAllComponents: Called for all actors both in the editor and in gameplay, this is the last function that is called in all cases.
 * - AActor::PostActorCreated: When an actor is created in the editor or during gameplay, this gets called right before construction.
 *                             This is not called for components loaded from a level.
 * - AActor::UserConstructionScript: Called for blueprints that implement a construction script.
 * - AActor::OnConstruction: Called at the end of ExecuteConstruction, which calls the blueprint construction script.
 *                           This is called after all blueprint-created components are fully created and registered.
 *                           This is only called during gameplay for spawned actors, and may get rerun in the editor when changing blueprints.
 * - AActor::PreInitializeComponents: Called before InitializeComponent is called on the actor's components.
 *                                    This is only called during gameplay and in certain editor preview windows.
 * - UActorComponent::Activate: This will be called only if the component has bAutoActivate set.
 *                              It will also got called later on if a component is manually activated.
 * - UActorComponent::InitializeComponent: This will be called only if the component has bWantsInitializeComponentSet.
 *                                         This only happens once per gameplay session.
 * - AActor::PostInitializeComponents: Called after the actor's components have been initialized, only during gameplay and some editor previews.
 * - AActor::BeginPlay: Called when the level starts ticking, only during actual gameplay.
 *                      This normally happens right after PostInitializeComponents but can be delayed for networked or child actors.
 *
 * @see https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Actors/
 * @see https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Actors/ActorLifecycle
 * @see UActorComponent
 */
啥? 看不懂, 嗯, 我也看不懂 (笑)

这里先是对右方流程的分析, 也是最常用的的流程 :

UWorld::SpawnActor






所有生成Actor最终跳转到这个函数, 参数有三个:

Class类
UserTransformPtr位置
FActorSpawnParameters信息


先看其中这一段代码 :

一个UWorld可以有多个ULevel, 每个ULevel里面有各自的AActor.

这里的操作就是获取AActor最后归属的ULevel.

分析可得, 该值的取值顺序依次是:

SpawnParameters.OverrideLevel
CastChecked<ULevel>(SpawnParameters.Owner->GetOuter())
如果是编辑器模式, 在关卡编辑器中选中的当前关卡CurrentLevel
否则, 是主关卡PersistentLevel
且该值类始终为ULevel


接着看, 这里有一个返回情况

类是否存在, 不存在则日志警告并返回





再往下, 这里有一个AActor时间记录的结构体, 通过作用域方式实现, 并贴上下文中的唯一的一个调用

// 如果看不懂这种写法, 参考下面这个网址
c++作用域_百度搜索


330-367行, 一堆判定Actor是否可以生成的if-else, 详情见注释.

中间条件(bIsRunningConstructionScript && !SpawnParameters.bAllowDuringConstructionScript)不清楚是什么情况.

谷歌没有找到相关信息, 如有了解, 希望能指教一下.


接着往下, 这里分情况, 设置了FName NewActorName和Template两个属性.

这里有个check, 得出Template必定存在, 不存在取Actor的默认对象

而NewActorName在Template存在的时候, 取唯一值.

UObject相关, 忽略掉





往下看, 这里有一道检查, 途中的函数为虚函数, 可以重写, 用于控制AActor能否在各端生成.


接着往下, 这里是对Actor生成位置的赋值

// 可以看到, 这里的目的是取一个生成位置
// 而上文的位置检测是检测位置是否无效, 无效位置
// Returns true if the vector contains a component that is either NAN or +/-infinite.
// 参考Vector, 嗯, 不明觉厉

接着往下, 是对CollisionHandlingOverride的重新赋值, 并检测

由于这个CollisionHandlingOverride值的存在, 此时AActor的位置信息, 位置并不一定是最终生成的位置, 往下看就知道了

/** Method for resolving collisions at the spawn point. Undefined means no override, use the actor's setting. */

用于当Actor生成之后的位置会发生碰撞, 这个时候该如何处理.
这里根据SpawnParameters.bNoFail值进行修改, 并且检测并处理有碰撞不生成的情况


接下来, 到了最核心的代码 : NewObject.

参数由前文得出, 具体细节略过(笑).



忽略


AActor对应的ULevel中添加AActor, 进行关联


AActor::PostSpawnInitialize下篇文章分析


生成失败, 暂时没遇到过, 不清楚, 为什么会有这种情况.


两个多播和最后一个添加网络Actor的函数.



嗯, 流程上到这里就算完成了, 一个Actor就生成了.

孤傲雕：UE4 Actor之Actor流程分析(二)


</code></pre>
</details>

<details>
<summary>UE4 Gameplay之常用类获取方式及浅谈</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/71568631
前言
由于最近扒源码的坑有点深, AGameModeBase流程, AActor流程, 之后还有UObject流程, 并且几个都还是进行中, 为了水文章, 写点轻松的东西, 所有有了这篇文章.
版本4.22
面向对象编程中类之间的关系
面向对象 - 类和类之间的关系 - Rocin - 博客园
面向对象--对继承、关联、聚合、组合、依赖的理解 - 曾经时光 - 博客园
面向对象六大原则 依赖倒置原则 皮皮的雅客 CSDN
下面的说法, 应该是迪米特法则, 这里是自己的一种认识, 一些个人感悟, 就当瞎扯吧.

从设计上来讲, 类和类之间会有认识和不认识两种情况

如果类A认识类B, 即类A有直接调用类B方法或读取类B属性.

但此时可能类B不认识类A, 即类B不直接调用类A方法或类A属性.

// 注意这里的直接一词, 意思是说如果
class B { virtual void Test() {} }
class C : public B {}

// 类A 调用 类B 的 Test, 类C是类B的子类
// 实际执行的是类C的Test函数, 但也是说类A不认识类C


例子 1 :
UE4在AController和APawn之间实现的一套关联机制, 两个类互相认识
ACharacter是APawn的子类, ACharacter认识APawn
APlayerController是AController的子类, APlayerController认识AController

ACharacter认识AController, 但AController不认识ACharacter.
APlayerController认识APawn, 但APawn不认识APlayerController.

而AController和APlayerState也有一套关联机制, 两个类互相认识

此时, APawn可以通过AController拿到APlayerState
但是APawn不应该认识APlayerState

// 此处不要杠精他们认识, 我知道, 只从关联机制上来说, 他们不认识的.

而如果我们有一个类MyGameState, 他认识上述所有类, 所以可以获得各个类的对象并进行逻辑处理.

APawn和APlayerState不认识这个是从功能上划分的.
AController和ACharacter, APawn和APlayerController不认识, 是层次上面的, 在关联机制上, 他们不在同一层级.


例子 2:
AActor的位置属性实际上是靠USceneComponent实现的.
但我们设置AActor位置的时候, 只需要认识AActor即可, 并不需要USceneComponent.
此处AActor将实现的细节对我们隐藏了.


所以有以下粗略总结 :

不认识
在同一个功能内
高层抽象与具体实现的关系, 或者说不在同一层级
两个类之间有层中间层, 例如接口.
不在同一个功能
关联不大, 互不干涉.
认识
类B 是 类A 的子类
类A 是 类B 的管理类
类A 和 类B 之间功能关联
类A 此处是逻辑类, 认识多个类, 并执行相应逻辑
同时根据两个类之间认识不认识, 或者谁认识谁, 谁又不认识谁的情况, 可以反推一些设计的思路与功能的界限.

// 上文写成个人感悟了..
// 如果有错误, 希望能指出或纠正
上文扯了那么多, 想说明什么呢?

本文的题目是 : UE4 Gameplay之常用类获取方式及浅谈

通过获取方式, 可以看出一些类的关联(认识与否), 从而看出一些东西.

// 虽然, 会有很多帮助函数, 会带来误导, 误认为两个类有关联
虽然, 下文不会对其进行分析(手动狗头), 因为东西很少, 分析局限性很大.


主要包括以下类:

UGameInstance
ULoalPlayer
AGameModeBase
AGameStateBase
APlayerController
APawn
AHUD
APlayerState
同时:

下文均忽略迭代器相关的获取方式.

下午均忽略帮助函数的分析.

UGameInstance

如上, 并附上了对应实际获取的实现代码.

实际真正存储UGameInstance指针的地方只有UWorld和UGameViewportClient两个类.

其他的类均多是通过UWorld来获取UGameInstance, 除了ULocalPlayer通过UGameViewportClient.

同时估计是可以得出的, AActor处纯属帮助函数, 忽略掉. 其他的就自己分析了(手动狗头)

ULocalPlayer

这个类, 不常用, 就懒得展开了.

AGameModeBase

嗯, AGameModeBase只能从UWorld中获取

AGameStateBase

AGameStateBase可以从AGameModeBase中和UWorld中获取

APlayerController

嗯, APlayerController做了很多事.

APawn

APlayerState这个好像是新版本才加的, 最近知乎上看到过, 忘了出处了.

APlayerState & AHUD

嗯, 正文就这些, 看到各类的获取关联, 联系之前说的认识和不认识关系

应该会对这几个类之间的关联, 有更深的认识.
</code></pre>
</details>

<details>
<summary>UE4 Actor之Actor流程分析(二)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/71787737
前言
文章之后会修改.
最近一些文章互相关联性较高, 可能随着某篇文章某些内容的深扒, 而导致一些内容更连贯, 并对所有相关内容进行修改
源码版本4.22
孤傲雕：UE4 Actor之Actor流程分析(一)

接上篇文章, 参照上篇文章UWorld::SpawnActor中的流程分析, 我们可以得出 :

AActor的创建主要有两个重点函数
NewObject<AActor>
AActor::PostSpawnInitialize()

嗯, 一般流程如上图注释.


按照顺序分析, 这里有一个bool值, 下文关联处只有这处


好像没什么用的样子.




接着往下, 对AActor::CreationTime进行赋值

The time this actor was created, relative to World->GetTimeSeconds().


并附其使用地方, 获得AActor创建后过去了多久.


设置网络权限, 这里有个断言, AActor的Role默认值是ROLE_Authority, 此处进行检查.

bRemoteOwned取值FActorSpawnParameters::IsRemoteOwned(),

/* Is the actor remotely owned. This should only be set true by the package map when it is creating an actor on a client that was replicated from the server. */
uint16	bRemoteOwned:1;

会调用ExchangeNetRoles进行权限交换, 如果没有交换过并且交换, 那么交换Role和RemoteRole, 联网相关, 此处不扩展分析


接着往下是SetOwner(), 嗯Owner相关, 之后单独文章分析.


伤害相关的...之后可能会单独分析?



然后, 这个函数就有点有趣且有用了.

如果AActor的位置信息实际上是根组件USceneComponent的位置信息.

而AActor的位置是唯一的, 所以根组件也是唯一的.

但, 由于各种问题, 例如说bug和忘记, 会没有给一个AActor设置一个默认的根组件.

这个时候, 同时有多个USceneComponent位置信息, 以谁为主?

所以, 就有了上文的修正函数, 取第一个没有父组件的Native构造组件为根组件.

// 瞎扯的, 有这个原因, 但不只这个原因, 不要当真


// NativeClass, 指C++类, 此处的Native的组件, 就是指C++构造函数中的添加组件.而不是UE4构造函数中添加, 动态添加, 场景中实例添加的组件
会不会觉得这里很友好? (手动狗头)


接着往下, 这里有一个断言

组件和Actor的关联导致, 组件的Owner必定是对应的Actor.


参考上图. 这里的一段处理, 是对USceneComponent的位置进行设置(此处不一定是最终值)

这里碰到一个Archetype原型和a converted (nativized) Blueprint class.

做一个不负责任的猜测, 这里是对一些动态类做的特殊处理

// Dynamic class (can be constructed after initial startup)
参考上面是UDynamicClass的定义, 是对这种动态生成类做一些特殊处理?

注释长长一段是解释为什么这么做?

没有接触过, 忽略掉吧...

// 弱弱问一句, 有大佬可以普及下什么情况吗? 读的时候一脸懵逼...
然后红圈圈中的地方, 里面设置根组件的位置信息.

得出在根组件的默认位置信息基础上, 和给出的位置信息进行计算, 然后得出实际希望Actor生成的位置

// 题外话, 所以有这个操作, 修改蓝图类Actor的默认缩放为1.5f, 生成缩放仍然给1.f, 实际生成的Actor大小为1.5f
// 如果要修改Actor大小, 修改蓝图类即可, 不需要去修改每个生成位置的缩放





接着往下, 可以看到是对所有的组件bHasBeenCreated的状态改变

根据, 这里是且只是对所有的原生类, 即C++类中自带的组件进行处理


接下来会根据条件判断, 如果这个类没有根组件并且是一个蓝图类, 那么会延迟注册所有组件.(参考下篇文章)

反之, 调用AActor::RegisterAllComponents对所有组件进行注册



AActor::RegisterAllComponents实际会调用 :

AActor::PreRegisterAllComponents
AActor::IncrementalRegisterComponents
AActor::PostRegisterAllComponents



接着往下, 如果这个Actor类将要被销毁并且允许失败, 就直接返回了, Actor生成失败, 如果不允许失败, 就接着走了.

这个参数是FActorSpawnParameters::bNoFail, 注释如下

/**
 * Determines whether spawning will not fail if certain conditions are not met.
 * If true, 
 * spawning will not fail because the class being spawned is `bStatic=true` 
 * or 
 * because the class of the template Actor is not the same as the class of the Actor being spawned.
 */
没有接触过, 解释不了.



	/**
	 * Called when an actor is done spawning into the world (from UWorld::SpawnActor), both in the editor and during gameplay
	 * For actors with a root component, the location and rotation will have already been set.
	 * This is called before calling construction scripts, but after native components have been created
	 */
参考注释, 这个只在UWorld::SpawnActor流程中进行调用

然后, 生成成功了!

然而并没有(手动狗头)


AActor是否延迟构造函数的调用, 延迟C++的构造函数和蓝图的构造函数

在这些构造函数调用完成之后, AAcotr才算彻底调用完毕.

至于构造函数相关, 孤傲雕：UE4 Actor之Actor流程分析(三)

AActor::IncreamentalRegisterComponents

传入值为0, 要注册所有AActor的组件, 并检测UWorld是否存在.


是否允许在BeginPlay前进行Tick函数, 如果允许, 对Tick相关功能进行注册(相关功能Tick相关的时候分析)


如果根组件存在并且没有注册, 且根组件允许自动注册, 对根组件进行注册(组件注册相关之后组件系列再说)


遍历所有组件并对没有组件过且自动注册的组件进行注册.


如果某组件有父组件没有注册过, 那么先注册该组件的父组件, 然后在下次循环的时候, 重新遍历该组件.

上诉操作, 会将AActor所有的组件进行注册.


如果所有组件注册成功, 才会接着调用PostRegisterAllComponents函数

结语
补更一篇(水完), 仍欠一篇
下一篇会是对AActor::FinishSpawning, Actor生成最后的收尾, AActor生成相关估计不会再拆了.
/**
 * 同上一篇文章, 不成体系, 所以很多地方等了解之后会再做修改整理
 * AActor系列, Gameplay系列, UObject系列等等长篇都会是这个样子.
 * 养肥了, 慢慢看了, 预计AActor流程还差3-4篇, 一篇生成? 两篇销毁?
 * 然后SpawnActor流程就完了, 其他ULevel或UWorld加载的呢?
 * 想想就头大.
 *
 * 路漫漫其修远兮，吾将上下而求索 
 *
 */
</code></pre>
</details>

<details>
<summary>UE4 Actor之Actor流程分析(三)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/71944376
前言
文章之后会修改.
最近一些文章互相关联性较高, 可能随着某篇文章某些内容的深扒, 而导致一些内容更连贯, 并对所有相关内容进行修改
源码版本4.22
孤傲雕：UE4 Actor之Actor流程分析(一)
孤傲雕：UE4 Actor之Actor流程分析(二)

接前文, 这是对AActor生成流程最后一步, AActor::FinishSpawning进行的最后分析.

该函数可以手动控制, 使得AActor生成走文章二图中最靠右侧的流程顺序.

下午是对其源码的一定分析.

AActor::FinishSpawning

首先, 我们发现了一个宏.

好像在哪里见过? (UWorld::SpawnActor)


断言检测, 保证该函数仅调用一次.


我们先返回看函数的参数, bIsDefaultTransform这个值 在头文件可以看到默认值是false

void AActor::FinishSpawning(const FTransform& Transform, bool bIsDefaultTransform = false, const FComponentInstanceDataCache* InstanceDataCache = nullptr);

而如果走正常生成AActor的流程, 这个值是true.

也就是说, 这个位置是用于延迟生成时, 使用一个新的位置信息, 代替原有AActor的位置信息.

这里做了几步操作 :

取出存储的位置信息, 并和新的位置信息比较.


并参考图, 存储的值, 是最原始的, 即用户给的那一个位置信息

如果不相同, 将AAcotr的位置信息 乘 旧位置信息的逆矩阵, 然后再与新的位置信息相乘得到结果


最后调用ValidateDeferredTransformCache()函数对数据进行整理.

// 4.22版本3088-3090的缩进有问题, 上午图中也可以看出来(手动狗头)

检测无效位置


然后就是开始执行构造函数, 并在执行完成后调用PostActorConstruction函数.

AActor::ExecuteConstruction

断言检测, 这里是执行UE构造函数, 如果AActor正在销毁, 是有问题的.


接着前面的位置信息, 通过bIsDefaultTransform该值, 重新设置根组件的位置信息



如注释所说, 这里是获得所有的蓝图父类.


再获得所有的动态父类？？



根据所有动态的父类创建TimerLine??

略过...


然后是两种情况, 有无蓝图基类.

无则相对简单一些, 根据情况调用ProcessUserConstructionScript函数, 以及BindDynamicDelegates. (用处见下文)

然后, 我们再一步步看有蓝图基类的操作.


根据有误报错信息, 走不同的逻辑.


先看错误的, 创建一个UBillboardComponent表示并注册根组件. 并保证所有组件全部注册(与上篇文章呼应).

再看正确流程 :


获得执行SCS(USimpleConstructionScript)之前所有现在已有的组件


再获得一组Native(C++原生)的USceneComponent组件, 并再次修复根组件.


这里会执行USimpleConstructScript相关的一些函数

然后执行并调用UBlueprintGeneratedClass::CreateComponentsForActor来调用, 创建Timeline相关.

这个USimpleConstructScript之后可能单独分析吧.

这里做一个简单的解释, 他做了什么?

在蓝图编辑器中, 所有Actor都会有一个根组件, 但蓝图的父类是AActor, AActor没有默认根组件的.

这个根组件就是在这里进行创建的.


又是这个写法, 这是最后一个出现的地方, 所以说一下.

这个函数最先在AActor::PostSpawnInitialize进行调用, 如果没有调用, 那么在此处AActor::ExecuteConstruction进行调用.

他是注册组件的函数, 希望在根组件存在后进行调用, 如果不存在, 那也没办法

在前面没有注册原因是根组件不存在, 同时发现他父类是蓝图类, 可能在之后创建根组件, 所有延迟调用

如果延迟, 到后面调用时,都是在根组件创建, 无论是正常情况蓝图创建默认的, 错误情况蓝图创建标识. 此时都应该有一个根组件了.

这个函数暂不分析, 之后可能AActor和UActorComponent关联的时候再说.


接着往下, 在执行SSC过程中, 我们又创建了一些组件, 将这些组件再次注册.


细节就一笔带过了, 代码并不复杂


再往下, 不知道， 忽略.


接着往下, 是调用用户构造函数(蓝图的构造函数)




然后修正所有USceneComponent组件的移动性.

同时, 这里获取了Kismet.bTurnOffEditorConstructionScript

即配置文件中可以关闭编辑器下蓝图构造函数的运行.

// 可以试着恶作剧一下某个项目, 兴许会逼疯一个人(手动狗头)

/** Initializes the list of properties that are modified by the UserConstructionScript */
不懂, 忽略.


绑定?? 见注释,


不懂, 忽略


这个是对前面SCS进行回收??, 忽略

到这里, 如果有蓝图父类的AActor生成顺序就完成了, 很多看不懂(笑).



看注释了, 不懂.


调用一个扩展用函数, 这里的位置还是希望生成的AActor位置(见下文).


最后返回一个布尔值, 是上午是否有蓝图编译错误的值, 在SpawnActor流程中无用.



补充 :
联系前文, 我们发现, 很多地方都会进行根组件的创建, 但最后AActor是否一定有根组件呢?

不是.

一个C++的AActor类, 直接生成的时候, 可以没有任何组件
一个继承自C++的任意蓝图类, 都会自动生成根组件.
AActor::PostActorConstruction

需要在UWorld::AreActorsInitialized之后运行, 否则会在下午调用


标记Actor被删除并清理

这里调用PreInitializeComponents


在此处会绑定输入事件


如果是网络动态生成的AActor, 做特殊处理, 延迟一些调用, 暂时忽略.



视情况调用所有组件的Activete和InitializeComponent函数


还记得UWorld中的ESpawnActorCollisionHandlingMethod吗? 在处理后设置给AActor, 到这个地方进行应用

此处, 是对AActor生成位置的最后调整, 这里之后, AActor的位置便是实际生成位置了.



接着往下, 注册到寻路网格, 并更新维护需要网络同步的组件列表.

视情况看是否要调用BeginPlay函数.



几种情况不会调用 :

前面说的, 联网延迟调用
重复调用, 根据BeginPlayCallDepth得出
如果有父Actor, 判断父Actor是否调用过BeginPlay或正在BeginPlay
编辑器预览模式


最后, 调用UpdateOverlaps函数, 参数默认值为true, 会触发重叠事件.

最后 :

}

结束了!!

AActor::BeginPlay()
最后, 我们再来看一下AActor::BeginPaly做了些什么


一个断言进行状态检测

设置AActor的生命周期, 并定时销毁


实现如上, 通过一个Timer实现

// 不知道出于什么考虑, 添加的该功能. 这个功能好像没有那么通用, 还占用了AActor几个字节.

注册Tick函数(此处Tick函数可能已经注册过)


修改ActorHasBegunPlay的状态, 然后遍历所有组件, 注册所有组件的Tick函数并调用组件的BeginPlay方法



调用蓝图的BeginPlay函数, 并再次修改ActorHasBegunPlay的状态. 到此AActor::BeginPlay调用完成

补更一篇(水完), 不欠了
// AActor代码完整的看下来, 感觉, 这不是我认识的那个AActor了!!!
</code></pre>
</details>

<details>
<summary>UE4 Actor之Actor流程分析(四)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/72468964
前言
文章之后会修改.
最近一些文章互相关联性较高, 可能随着某篇文章某些内容的深扒, 而导致一些内容更连贯, 并对所有相关内容进行修改
源码版本4.22
孤傲雕：UE4 Actor之Actor流程分析(一)
孤傲雕：UE4 Actor之Actor流程分析(二)
孤傲雕：UE4 Actor之Actor流程分析(三)

接前文, 前面几篇文章分析了UWorld::SpawnActor的完整流程, 接下来会对其他AActor生成流程做一定的分析.

下文中多数函数在前文中已经做过分析, 很多就直接一笔带过了

新加载一张地图, 编辑器视口中AActor的生成流程

首先是加载ULevel的资源时, 这里在加载UPackage的时候, 根据UObject相关的生成流程, 调用了UObject::PostLoad. (UObject之后分析).


然后在ULevel::IncrementalUpdateComponents中对AActor进行了初始化操作.


这里对ULevel相关的内容忽略掉, 此处只关心AActor相关.

这里遍历的所有AActor, 对AActor的组件相关进行注册.

参考前文, 这里实际调用了

AActor::PreRegisterAllComponents
AActor::IncrementalRegisterComponents
AActor::PostRegisterAllComponents
注册组件的流程就闭环了.


在下面又遍历所有的AActor, 并调用AActor::RerunConstructionScripts函数, 调用AActor的构造函数


如图, 在下列几种情况的时候, 无法重新调用AActor::RerunConstructionScripts方法

bActorSeamlessTraveled(AActor进行了无缝切关后)
AActor将要被销毁
父类BP正在被编译

如果该AActor是ChildActor, 则会调用父Actor的RerunConstructionScripts方法

该方法放弃分析了, 如果有可能, 再专门针对AActor的构造函数相关进行分析吧.

在编辑器运行的时候, AActor生成流程

先调用AActor::PostDuplicate, 然后再调用AActor::PostLoad

这两个都是UObject相关的, 暂不做深入分析.

接下来会调用上文中的ULevel::IncrementalUpdateComponents方法.


最后会调用ULevel::RouteActorInitialize方法




并遍历所有AActor调用组件的初始化函数, 并调用AActor的BeginPlay函数

动态加载流关卡时AActor的逻辑

AActor::PostDuplicate和AActor::PostLoad
ULevel::IncrementalUpdateComponents
ULevel::RouteActorInitialize
可以看到流程基本和在编辑器中运行一张新地图一致的

(不一致的地方在UWorld中, 逻辑处理顺序不一致, 那个是ULevel加载相关的, 此处忽略)

最后算作总结, 对所有AActor生成流程进行一个小结 :

地图中AActor生成流程
PlayInEditor编辑器(关卡运行)
PlayInEditor编辑器(流关卡动态添加)
复制所有UObject, 调用UObject::PostDupicate
LoadMap(加载地图)
AddToWorld(流关卡动态添加)
从硬盘中加载所有UObject
然后上面的流程后续一样 :

UObject::PostLoad
ULevel::IncrementalUpdateComponents
AActor::PreRegisterAllComponents
AActor::IncrementalRegisterComponents
AActor::PostRegisterAllComponents
AActor::RerunConstructionScripts(在不执行的时候才会调用)
AActor::OnConstruction
ULevel::RouteActorInitialize(运行地图才会调用)
AActor::PreInitializeComponents
AActor::InitializeComponents
AActor::PostInitializeComponents
AActor::DispatchBeginPlay
UWorld::SpawnActor流程
NewObject
AActor::PostSpawnInitialize
AActor::DispatchOnComponentsCreated
AActor::RegisterAllComponents
AActor::PreRegisterAllComponents
AActor::IncrementalRegisterComponents
AActor::PostRegisterAllComponents
AActor::PostActorCreated
AActor::FinishSpawning
AActor::ExecuteConstruction
AActor::OnConstruction
AActor::PostActorConstruction
AActor::PreInitializeComponents
AActor::InitializeComponents
AActor::PostInitializeComponents
AActor::DispatchBeginPlay
broadcast UWorld::OnActorSpawned
这周只需要更新一篇(手动狗头), 并将AActor这四篇流程文章整理了一下
下一篇估计是AActor销毁流程相关的了, 然后估计之后会系统的整理一下, 目前感觉, 这四篇生成相关的流程有点乱了.
同时一些东西会单独的拿出来, 进行分析, 例如BeginPlay的调用相关
// AActor生成流程下来看, 完整的知识体系还差UObject系列, UPackage和UAsset资源加载相关, UWorld和ULevel相关, 网络相关, AActor和组件相关等等
// 还是没有考虑网络相关的....
</code></pre>
</details>

<details>
<summary>UE4 Actor之Actor流程分析(五)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/72615004
前言
文章之后会修改.
最近一些文章互相关联性较高, 可能随着某篇文章某些内容的深扒, 而导致一些内容更连贯, 并对所有相关内容进行修改
源码版本4.22
孤傲雕：UE4 Actor之Actor流程分析(一)
孤傲雕：UE4 Actor之Actor流程分析(二)
孤傲雕：UE4 Actor之Actor流程分析(三)
孤傲雕：UE4 Actor之Actor流程分析(四)

接前文, 前面几篇文章分析了关于AActor生成的几种情况, 接下来就是AActor销毁流程了








可以看到AActor的销毁, 是由UWorld::DestroyActor实现的.



接着往下, 这里判断是否是游戏世界, 否则调用UObject(AActor)::Modify函数

忽略, 我们重点看IsGameWorld()情况下的代码

/** Returns true if this world is any kind of game world (including PIE worlds) */


参考注释和前文, 如果是独立模式运行, Actor的权限将是默认值ROLE_Authority

此处该AActor被当作一个网络AActor处理(因为有最高权限的网络端可以正常消耗AActor)


如果是一个联网AActor

判断权限
bNetForce AActor::Destroy()的第一个参数, 默认值是false, 当传入true, 可以在客户端强制销毁该AActor
此时, 服务器端的AActor不再和客户端的进行对应, 不再同步, 同时有错误日志
LogNet: Warning: 
UActorChannel::ProcessBunch: 
ReadContentBlockPayload failed to find/create ACTOR. 
RepObj: NewBlueprint2_Child_C /Game/UEDPIE_2_Untitled.Untitled:PersistentLevel.NewBlueprint2_Child_C_0, Channel: 3
AActor::bNetTemporary
/** If true, when the actor is spawned it will be sent to the client but receive no further replication updates from the server afterwards. */
该AActor只同步创建, 之后没有任何同步信息

通过上述三个条件过滤, 任意一个满足就可以销毁AActor





如果不是一个联网AActor, 去拿控制行变量并判断, 能否销毁空权限的AActor, 默认值此处为1, 即true



然后是一个调用AActor::DestroyNetworkActorHandled, 默认直接返回false, 根据注释应该在PlayerController和BeaconClients里面有特殊实现, 阻挡类被销毁, 此处忽略.


如果AActor正在BeginPlay, 通过FSetActorWantsDestroyDuringBeginPlay做特殊处理, 并返回true 处理成功



然后重新销毁

上述是对AActor能否销毁进行的一些检测与处理, 接下来就是对AActor的销毁了.



标记AActor::bActorIsBeingDestroyed正在被销毁

// 上文中已经出现两次这种写法, 在一个结构体里面修改AActor类的属性, 斗胆猜测一些原因, 方便打断点和进行关联(手动滑稽)

从注释看, 通知纹理流管理器, AActor被销毁了


调用AActor::Destroyed()函数

/** Called when this actor is explicitly being destroyed during gameplay or in the editor, not called during level streaming or gameplay ending */
从对应注释可以得出, 该函数仅在被销毁的时候调用, 在关卡或流关卡整个结束的时候不调用.


然后调用了

AActor::RouteEndPlay
AActor::ReceiveDestroyed 蓝图的销毁函数

broadcast AActor::OnDestroyed 广播代理





往下看, 销毁之后, 然后对所有附加到该AActor上的对象进行Detach操作


并且将该AActor从所附加的对象身上移除



然后触发所有的EndOverlap事件, 如果有的话


置空Owner


/** Populate an entry for Actor in the DestroyedReplicatedStaticActors list */
不懂, 忽略.


通知NetDriver该AActor已经被销毁


调用UWorld::RemoveActor


将ULevel中维护列表中当前AActor值置空, 并且移除AActor的网络相关东西.


忽略



销毁所有的组件并调用AActor::PostUnregisterAllComponents方法



标记AActor和所有组件可以回收了


注销AActor和组件的Tick函数


然后就返回true

流程到这里, AActor就被认为可以被回收了.

此时会进入正常的GC流程

这里需要强调, 进入GC流程不一定代表AActor一定会被销毁

例如 :

A对象创建B对象, 并将B对象存在A对象UPROPERTY中, 此时B对象调用Destroy, 但B对象被A引用, 不会被GC

孤傲雕：UE4 TWeakObjectPtr 相关杂谈





再次注销所有组件并且从ULevel维护的AActor数组中移除

并调用UObject::BeginDestroy相关处理开始对AActor进行销毁

然后当UObject::IsReadyForFinishDestroy的时候对AActor进行最终销毁UObject::FinishDestroy

详情之后UObject系列再说吧.

这周更新第一篇
这篇是AActor销毁流程相关的了, 短时间内AActor流程系列就挂着了, 可能会进行一些修补.
这个系列的文章水分很足, 牵扯内容较多, 需要一些时间完善并沉淀沉淀
以及从UObject, 组件相关, 网络相关进行一些内容的补全
之后会开其他系列了, 或者写一些关联不大的单独功能了
// 想开UObject 或 网络相关的, 但想了想, 算了(手动狗头)
</code></pre>
</details>

<details>
<summary>UE4 ActorComponent流程分析</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/74084967
前言
文章之后会修改.
最近一些文章互相关联性较高, 可能随着某篇文章某些内容的深扒, 而导致一些内容更连贯, 并对所有相关内容进行修改
源码版本4.22
每周的水文章又来了.

这周水的内容是ActorComponent组件的流程分析, 在Actor的基础上, 我们找找资料, 很容易的, 一篇文章就水出来了.

直到发现, 没有, 任何, 靠谱, 有效, 相关, 的资料, 能拿过来直接水的.

水不成了(手动狗头)

下文是对组件动态创建和动态销毁的流程. 其他的生成销毁流程基本是雷同的.

Components 官方文档

一个ActorComponent创建并挂载到Actor的流程很简单

创建, 然后注册

UObject相关不分析, 也就是说下文对UActorComponent::RegisterComponent进行分析即可

UActorComponent::RegisterComponent

耗时检测相关


错误状态检测, 将要注册的组件不能是无法访问, 将要销毁和已经注册过的


组件注册依赖UWorld, 这里检测参数UWorld是否存在

并进行检测, WorldPrivate是否已经存在, 该值在组件注册后才会被赋值


检测Owner是否存在, 如果存在则检测是否是AActor拥有的组件


/** Class has been consigned to oblivion as part of a blueprint recompile, and a newer version currently exists. */
CLASS_NewerVersionExists  = 0x80000000u,
字面翻译, 该类是一个蓝图的过期类(旧的编译版本), 有新的蓝图编译版本产生, 此时不进行组件注册, 直接返回.







然后调用UActorComponent::OnComponentCreated


对WorldPrivate进行赋值


执行注册事件, 下文分析


然后我们会看到这样一个分支, 判断是否在游戏世界, 如果不是, 则只注册Tick函数.


然后会判断MyOwner即挂载的AActor是否存在, 并根据流程走相应逻辑

先来看没有MyOwner的情况


初始化组件并注册Tick函数

这里只有当bWantInitializeComponent值为true的时候才会调用这个函数, 这个函数从注释和内容上, 都是给扩展用的.

UActorComponent::InitializeComponent
参考上面的网址, 这些地方用到了这个东西, 但查了几个, 偏向于组件具体的东西了.

所以, 这里是一个在BeginPlay前调用的扩展接口




而如果MyOwner存在, 则根据Actor的状态进行相应逻辑

Actor初始化过, 初始化
Actor已经BeginPlay, 直接BeginPlay


UActorComponent::BeginPlay也很简单, 维护bHasBegunPlay状态和调用蓝图的扩展函数


最后是一个操作, 从注释上看, 是为了防止某种情况下蓝图创建的组件子组件没有被正常注册

某种情况???

UActorComponent::ExecuteRegisterEvents



对一堆状态信息的断言检测, 并调用一个扩展函数

然后试着UActorComponent的Active状态

如果bAutoActivate并满足条件, 自动激活



初始化渲染状态





初始化物理状态



具体都不懂, 忽略

上文是一个UActorComponent的创建注册初始化流程, 参考AActor的生成流程.

可以看到组件中的大多操作在AActor生成流程里面, 都有执行.



然后从上文, 可得UActorComponent的三个流程

NewObject UObject相关略过
Register
在注册组件的过程中，引擎将组件与场景关联起来，使其可用于每帧更新，并运行以下功能
重写OnRegister函数以添加代码。
初始化渲染状态。
初始化物理状态。
Initialize 是一个在BeginPlay前调用的自定以的扩展接口
配合AActor的生成流程, 对相关内容, 应该是会进一步认知的.

然后是UActorComponent的销毁流程了, 基本同AActor的销毁流程


确保只执行一次



状态维护并调用蓝图的EndPlay扩展




同上文, 一个扩展函数



如图, 并在ExecuteUnregisterEvents函数里面



对渲染状态和物理状态进行销毁, 并调用OnUnregister函数


然后从AActor的组件中移除, 如果是根组件, 还会把AActor的根组件置空



调用OnComponentDestroyed扩展函数


标记UActorComponent可以被清理了.


最后调用BeginDestroy完成最终的销毁, 逻辑基本同DestroyComponent

上文是一个UActorComponent的一个销毁流程, 参考AActor的销毁流程.

可以看到组件中的大多操作在AActor销毁流程里面, 也有执行(笑).

注 : 实际上UActorComponent的生成流程和销毁流程和上文会有一定的区别, 在不同地方创建的组件, 走的流程是不一样的, 上文是一个组件动态创建和动态销毁的流程.


最后贴上一份UActorComponent的流程

UActorComponent::OnComponentCreated
UActorComponent::OnRegister
UActorComponent::InitializeComponent
UActorComponent::BeginPlay
UActorComponent::TickComponent
UActorComponent::EndPlay
UActorComponent::UninitializeComponent
UActorComponent::OnUnregister
UActorComponent::OnComponentDestroyed
这周更新第一篇
这篇是UActorComponent流程相关的, 估计下几篇就是Actor和ActorComponent之间关联了
骗赞了, 骗评论了
</code></pre>
</details>

<details>
<summary>UE4 Actor与ActorComponent之间的关联</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/74908124
前言
文章之后会修改.
最近一些文章互相关联性较高, 可能随着某篇文章某些内容的深扒, 而导致一些内容更连贯, 并对所有相关内容进行修改
源码版本4.22
想练练文笔, 也试着提一些高度, 做些理念层的东西, 所以可能会皮一些(笑)
F(C++)类万物之始!

U(UObject)类开天辟地!!

A(AActor)类演化万物!!!

UC(UActorComponent)类, 额.

UC类, 嗯UC类负责打工.

《Inside UE4》-2-GamePlay架构（一）Actor和Component
Components
Components文档
c_when_to_use_actor_when_to_use_component/
组合优于继承_百度搜索
如果阅读过前文Actor和ActorComponent(下文简称Component)的流程分析, 不难发现.

Actor做的很多处理, 是处理Actor所拥有的Component

而Component的初始化, 也会依赖于它的Owner(Actor)

两者关系十分密切, 互不可少

才怪!!!
才怪!!

才怪!



LogBlueprintUserMessages: [Untitled_C_6] Not valid

一个没有组件的Actor(GameMode)路过

// 参考前文, 一个纯C++的AActor类, 可以没有根组件

LogTemp: OnComponentCreated
LogTemp: OnRegister
LogTemp: InitializeComponent
LogTemp: TickComponent
LogTemp: UninitializeComponent
LogTemp: OnUnregister
LogTemp: OnComponentDestroyed
一个直接注册到世界的Component

// 从日志上是没有BeginPlay和EndPlay的, 又有的水了(手动狗头)


说好的相爱相杀呢?(手动狗头)



然后就是日常的水文章环境



对Actor和Component之间关联的一些代码分析



RootComponent

一个Actor有一个根组件, 用一个指针进行维护


OwnedComponents

那所有的Component呢? 一个TSet<UActorComponent*>

Actor和Component关联常见操作, 说白了, 就是 :

增
删
改(假装有删除线)
查
增 AddOwnedComponent


啥? 你看到了还维护了这三个数组

TArray<UActorComponent*> ReplicatedComponents;
TArray<UActorComponent*> BlueprintCreatedComponents;
TArray<UActorComponent*> InstanceComponents;
嗯, 这些都可以通过OwnedComponents遍历来生成.

空间换时间, 时间换空间.

这里就属于拿空间换时间, 存储一个状态信息

省得用的时候再重新获取生成的步骤.

忽略

删 RemoveOwnedComponent


查 OwnsComponent




感觉很简单了是不是?

那Compoent与Actor的呢?




是不是感觉很简单粗暴

然而 Actor和Component的代码上的关联就这么弱.

那复杂的地方在哪里呢? 功能和逻辑上呗.

位置信息相关
联网同步相关的处理
初始化和销毁相关
Tick相关
设计相关
....
会讲吗? 这里不会(笑)

问题 : 一个功能, 放在Actor还是放在Component里然后挂在Actor上面?
看法 :

如果体量小(代码少, 层次不复杂), 都写Actor
// 新建一个Component类干什么
如果适中, 部分独立功能剥离拆分到Component中
举例 :

以一个假的FPS游戏

FPSCharacter身上挂载Backpack(背包), Weapon(武器)等等多个组件.

他们都是角色身上的功能, 但互相相对独立一些, 所以可以单独拆成组件

目的是减少FPSCharacter本身的代码量, 和职责单一等等

大白话就是换个文件放代码.(笑)

如果体量庞大, 除核心逻辑外, 剥离到Component中
// 考虑考虑你本身的层次设计, 这个类的职责是不是太多了?(手动狗头)
问题 : 一个Component必须是一个通用的组件吗? 挂载到某个Actor都可以使用吗?
看法 :

// 好像听说过有这种说法, 大意是说, 通用功能封装成组件, 用来跨Actor, 跨项目使用
从事实上讲, 无论写什么代码, 没有真正的强制, 不会有强制, 只要编译过, 怎么用都可以

建议, 规范, 警告,等等, 听听就好(手动狗头)



个人觉得, 一个Compoent可以在正确的初始化后, 可以执行一个或多个功能.

前后文环境依赖
挂载到指定Actor子类
...
例 :

UCharacterMovementComponent中的类注释

CharacterMovementComponent handles movement logic for the associated Character owner.

CharacterMovementComponent处理Character的移动

所以, 一个Component针对某个Actor子类做一些功能处理, 而没那么通用, 是一件很正常的事.


个人常用的一个检测代码
问题 : Component可以反过来影响Actor吗?
完全可以

例如URotatingMovementComponent, 影响Actor旋转的一个组件


问题 : 我想挂载一个Component, Component必须在Actor里面存储一个变量吗?
不必, AActor::FindComponentByClass, 通过类找组件, 怎么方便怎么来


问题 : 我想挂载一个Component, 必须在Actor里面创建吗?
不必, 那里方便那里建, 怎么方便怎么来


问题 : 我有一个功能, 既需要挂在Pawn上面走网络同步, 也需要挂在GameState做全局处理, 也可以用Component来做吗?
问题 : 可以由多个Component组成一个功能吗?
可以, 如果设计合理, 核心逻辑不变

整体增删功能就是加减组件的事

估计, 这是UE4最想看到的局面吧?

举例 : 一个FPS游戏

如果地图需要道具产生
GameState挂一个道具管理组件
PlayerController挂一个联网用的道具组件
Pawn/Character挂一个道具使用组件
场景中根据GameState管理组件动态生成组件
如果主体逻辑设计合理,

那么有无道具, 完全可以由GameState是否挂载这个道具管理组件, 然后再动态的加载Controller, Pawn和场景中的道具物体来实现

相同功能类比呢? 如果是一个随机门功能呢? 如果是地图陷阱功能呢?

加个组件, 组件影响其他地方, 整个游戏就可以多一个功能

减个组件, 游戏又少了一个功能

加删组件, 一行代码的事, 但结果和效果呢?

说的很美好, 能实现吗? 部分小功能可以, 在主体逻辑上的一些扩展功能.

实现难度大吗? 大, 试试就知道了.

好用吗? 很好用, 加功能和减功能跟玩一样.

会有什么后果呢?

策划, 过来, 是你丫的又砍功能了(&(!$^(!$

策划, 过来, 是你丫的又加功能了&()$&!

策划, 过来, 这个程序员疯了()%^*()^$

问题 : 还是不知道Actor和Component怎么区分使用?
先怎么顺手怎么来, 然后就慢慢知道了(手动狗头)
</code></pre>
</details>

<details>
<summary>UE4 SaveGame存档相关分析</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/75054016
前言
源码版本4.22

空类(疑问)?
空类!(惊讶)

空类!(感叹)

水完收工!

结语

这周更新第二篇, 水完收工!
骗赞了, 骗评论了.



好吧, 这些是隐藏内容(还是要水些东西的).

Saving Your Game
USaveGame是UE4自带的一个功能, 用于保存游戏数据, 做存档功能等等.

然后, 其实, 嗯,

只是一个UObject的子类, 还是一个空类.

UGameplayStatics下有5个帮助函数, 连一个单独的蓝图函数库都没有

可见这个功能有多简单, UE4有多嫌弃(手动狗头)

UGameplayStatics::CreateSaveGameObject



创建一个UObject类, 略

UGameplayStatics::DoesSaveGameExist

/** Defines the interface to platform's save game system (or a generic file based one) */
ISaveGameSystems是一个平台的接口, 但Windows平台下


嗯, 基本的文件操作, 略

UGameplayStatics::DeleteGameInSlot

略





UGameplayStatics::SaveGameToSlot



// Archive for storing arbitrary data to the specified memory location
FMemoryWriter, 见注释, 序列化相关的, 之后再说


FSaveGameHeader创建的时候获得并存储一些序列化的基础信息


版本格式类型等这些, 并写入这些数据, 然后再把SaveGameObject类数据序列化

接着存储, 完成

除了序列化外, 没什么东西, 而序列化, 略

UGameplayStatics::LoadGameFromSlot

通过SaveSystem读取是否存在数据, 如果存在则对其解析


首先, 先读取版本格式类型这些基础信息,

并从中找到USaveGame对应的UClass, 创建对应的对象

接着将剩下的数据反序列化到对象

然后直接返回.

嗯, 这个类很简单的, 依赖于UE4 的序列化系统, 几乎没做什么, 就实现了...

序列化系统呢?

略!!!
略!!

略!

// 之后能分析再说(手动狗头)
</code></pre>
</details>

<details>
<summary>UE4 UObject系列序</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/75526405
导言
这是一篇关于UE4 UObject整个系列的导言.

在取舍UObject系列还是网络同步系列之后, 嗯, 选择了UObject系列

目前的计划是先补齐UObject和AActor相关的内容, 然后处理UWorld, ULevel, 再所有关联起来, 重新整理一下.

相对而言, 一个最基础的较为完整的UE4 的单机逻辑体系就构建起来了

从UWorld开始, 建立ULevel, 然后转接给Gameplay相关

UObject, AActor, UActorComponent三个类互相之间的关联, 使用, 设计也有一定的分析.

基础的功能框架已经完整了, 剩下的, 就是具体功能模块(AI, 动画, 特效, 材质, 物理)及网络相关等的具体使用了, 网络之后再开系列分析, 具体功能模块之后拿Demo项目分析.

// 又想起那个一直鸽子的回合制项目了(手动狗头)
在这个系列最后完成并完善之后, 个人也觉得可以说自己是一个"真正"的"UE4大佬"了(手动狗头).

杂谈
同时 , 开这个系列, 心里是很虚的! 很虚! 虚!

写这篇序的时候, 已经在疯狂找资料

但UObject系列的资料又真心很少, 很多有者浅浅的一笔带过, 实用性不大

所以, 欢迎各路人士大佬大神妖孽等等, 进行交流探讨啊, 斧正啊, 资料提供, 思路提供啊等等

腾讯帐号 : 1280753384, 备注UE4即可.

同时, 这个系列完结之前, 接受各种催更, 但并不会多更(手动狗头).

预计周更一篇, 且会经常欠更.

一个是内容深度上去了, 文章不好水, 为了文章数量水没有什么意义.

一个水文章水不出来了, 预计一篇文章需要耗时6-8, 还未必可以出来.

// 绝对不是打游戏去了,(手动狗头)
同时, 由于缺少资料, 只啃源码是不太好啃的.

这个UObject系列开的又会特别大, 最后, 嗯, 估计会, 步子迈太大扯到裆.

毕竟, UE4 除去渲染相关, 最核心的设计, 应该就是UObject整个系列了.

个人只能保证, 尽个人60%, 不, 50%的努力, 做到一个较好的结果吧

最后能成什么样子就什么样子吧.

大钊：《InsideUE4》UObject（一）开篇
Objects 官方文档
Objects 官方文档
UObject Instance Creation 官方文档
UObject
baidu UE4 UObject
google UE4 UObject
UObject

Explanations of the basic gameplay elements, Actors and Objects.
UObject相关的就不叙述了, 嗯, 大佬们分析的很好了.

// 目前对UObject类没有什么深入的了解
目录
下面是大概会有的分析内容和预计篇幅吧.

如有缺项, 之后会补充

Reflection (反射)
基础反射信息相关
孤傲雕：UE4 UObject反射系列(一) Class相关
孤傲雕：UE4 UObject反射系列(二) Class相关
孤傲雕：UE4 UObject反射系列(三) Class相关
孤傲雕：UE4 UObject反射系列(四) Class相关
基础的UClass构建
孤傲雕：UE4 UObject系列之UClass(一)
孤傲雕：UE4 UObject系列之UClass(二)
孤傲雕：UE4 UObject系列之UClass(三)
20篇?? 隔壁大钊：《InsideUE4》UObject（十二）类型系统-总结用了13篇, 感觉很多地方还可以细致的再水水文章.
COD(Class Default Object)
4-5篇?? 现在还没有什么认知了解
Garbage collection(内存回收) 和 Reference updating(引用更新)
5篇? ?浅略的讲讲, 应该够吧
Serialization(序列化)
5篇?? 好像这个在反射的基础上没东西了吧.
Life Cycle(生命周期)
8篇??
Package & Asset(包和资源相关)
10篇??
Network replication(网络复制相关)
5篇??
感觉开了一个很大的坑.

粗略算了一下, 好像得4-50篇, 每周一篇, 一年就过去了...
</code></pre>
</details>

<details>
<summary>UE4 UObject反射系列(一) Class相关</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/75533335
前言
文章之后会修改.
最近一些文章互相关联性较高, 可能随着某篇文章某些内容的深扒, 而导致一些内容更连贯, 并对所有相关内容进行修改
源码版本4.22


孤傲雕：UE4 UObject反射系列(一) Class相关
孤傲雕：UE4 UObject反射系列(二) Class相关
孤傲雕：UE4 UObject反射系列(三) Class相关
孤傲雕：UE4 UObject反射系列(四) Class相关
这是UObject系列的第一个知识点, UE4反射信息相关

主题内容是对UBT(Unreal Build Tool)生成的.h文件和.cpp文件内容分析

UObject是一个功能强大的类, 有很多功能, 为什么要从反射开始呢?

大钊：《InsideUE4》UObject（一）开篇
大钊：《InsideUE4》UObject（四）类型系统代码生成
参考大佬文章, 感觉解释的很清楚了, UE4反射功能是一块很强大的的基石, 很多功能都是在此基础上进一步搭建的 :

GC
网络同步
序列化
编辑器界面
...
GuAoDiao/GUAO22
内容较多且繁琐, 偏操作实践, 请根据文章一步一步跟做, 或者直接下载上面git项目进行对比分析

不保证教会, 但保证听懂.

// 那如果听不懂呢? 额, 好像, 也很正常(手动滑稽)
步骤一 建立基础项目和待分析文件
新建一个项目, 项目名称保证短小(此处是GUAO22)
// 如有自信, 可以命名其他名称, 如无, 请相同
// 后文会不断用到这个项目的, 注意保留项目
建立一个新的UObject子类, 名称尽量短小(此处是GAObject01), 并带有序号

重新生成并打开VS项目, 不要编译
引擎设置里面可以关掉添加新C++类自动编译, 然后按下图重新生成VS项目并打开



// 编译了也无所谓, 默认是会自动编译的
步骤二 分析空类


如果没有编译过, 这里会有两个报错提示, 无法找到头文件和这个宏定义.

这些是通过UHT动态生成的, 下文主要就是对这些自动生成内容的分析.


首先, 我们可以看到这是一个空的UObject类, 这是第一个分析的文件, 他没有任何实现, 然后我们生成项目


然后我们就可以打开这个文件了, 并打开文件所在目录, 可以看到对应的.cpp文件



首先是UCLASS()宏


空定义, 忽略

步骤二 第一小节
GENERATED_BODY宏, 重点来了



GENERATED_BODY一步一步展开级可得到, 同理可得

// 推荐和我一样, 新建两个个.h文件, 按照步骤一步一步展开
// 完整的展开GENERATE_BODY和GENERATED_UCLASS_BODY两个宏, 各放一个.h中
// 并可以直接两个对照分析, 编译的时候, 修改后缀为.text等等
// 并做好保留, 之后还会用到

GENERATED_BODY
GUAO22_Source_GUAO22_Public_GAObject01_h_15_GENERATED_BODY
GENERATED_UCLASS_BODY
GUAO22_Source_GUAO22_Public_GAObject01_h_15_GENERATED_BODY_LEGACY
其中有两个会变化的量

__LINE__
当前行数, 此处为15
用于区分同一个文件中的不同类, 使得一个.h文件可以同时创建多个不同的UClass宏, 并一一对应
CURRENT_FILE_ID
GUAO22_Source_GUAO22_Public_GAObject01_h
存在于generated.h, 是固定格式, 根据文件不同来区分.
D:\Unreal Projects\GUAO22\Source\GUAO22\Public\GAObject01.h
根据上面文件路径, 可以发现是一一对应的.
两者配合使用, 就可以时得最后生成的宏在文件或者所在行数不同就不同

从而使得, 每一个GENERATED_BODY或GENERATED_UCLASS_BODY生成的宏都是唯一的, 可以与CLASS一一对应.

步骤二 第二小节(一)
然后, 我们先看GENERATED_BODY系列, 忽略掉GENERATED_UCLASS_BODY系列, 稍后再看

在generated.h搜索得出


该宏是由多个宏组成的, 忽略掉PRAGMA_DISABLE_DEPRECATION_WARNINGS这两个宏, 也就变成了


步骤二 第三小节(一)
我们按照顺序来看这四个宏

GUAO22_Source_GUAO22_Public_GAObject01_h_15_PRIVATE_PROPERTY_OFFSET


字面翻译, 私有属性偏移, 空值忽略

GUAO22_Source_GUAO22_Public_GAObject01_h_15_RPC_WRAPPERS_NO_PURE_DECLS

__BEGIN_DECLS 和__END_DECLS
包装RPC不是纯函数的DECLS??, 此处为空, 忽略

GUAO22_Source_GUAO22_Public_GAObject01_h_15_INCLASS_NO_PURE_DECLS

在类内的不是纯函数的DECLS??

GUAO22_Source_GUAO22_Public_GAObject01_h_15_ENHANCED_CONSTRUCTORS

增强的构造函数及相关的内容



然后, 我们替换得出了(注意替换时public和private的先后位置)


步骤二 第二小节(二)
我们再转过头来看GENERATED_UCLASS_BODY相关


可以得出


步骤二 第三小节(二)
同理, 我们按照顺序来看这四个宏

GUAO22_Source_GUAO22_Public_GAObject01_h_15_PRIVATE_PROPERTY_OFFSET

这个宏和上面那个是同一个宏, 为空, 属于公有部分

GUAO22_Source_GUAO22_Public_GAObject01_h_15_RPC_WRAPPERS

和前文一样, 此处为空

GUAO22_Source_GUAO22_Public_GAObject01_h_15_INCLASS

此处空类的情况下, 两者代码一致

GUAO22_Source_GUAO22_Public_GAObject01_h_15_STANDARD_CONSTRUCTORS

这个宏是标准的构造函数内容

和之前的宏做区分, 可以看到, 此时他们有很多内容是相同的, 只有一个构造函数不同

然后我们可以得出(为了顺序和前面的对应, 有一定微调, 但public和private一致, 无影响)


步骤二 第三小节(三)
我们先停下来消化一些东西, 通过对比两个宏最后的展开, 目前来看, 区别只在构造函数上面


// GENERATED_BODY
NO_API UGAObject01(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get()) : Super(ObjectInitializer) { };
// GENERATED_UCLASS_BODY
NO_API UGAObject01(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
也就是说, 如果使用GENERATED_UCLASS_BODY宏, 需要人工创建并实现UGAObject01(const FObjectInitializer&)对应实现, 而GENERATED_BODY不需要


以及, 都会将拷贝和移动构造函数私有化, 阻止调用, 防止误操作.

以及, 接下来, 我们只需要展开分析GENERATED_BODY即可, 剩余部分, 两者是一致的

// 至少目前是一致的
步骤三

然后是对这些宏的展开, 有五个宏

DECLARE_CLASS


宏替换可得, 如图

DECLARE_SERIALIZER

是对<<的运算符重载, 序列化相关是由FArchive及相关类实现的


DECLARE_VTABLE_PTR_HELPER_CTOR

热重载相关的, 忽略


DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER

热重载相关的, 忽略


DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL

这是一个默认的构造函数


最终替换所有展开



同理也可以得出GENERATED_UCLASS_BODY相关的, 到此为止, 这个头文件的推断就告一段落了.

步骤四
然后我们先停下来, 分析一些其他情况

情况一


建立一个GENERATED_UCLASS_BODY()验证上面的推测, 别不同宏生成的东西差很多


最后对比.generated.h发现两个头文件有区别在这里

当定义GENERATED_UCLASSBODY之后, 如果再定义GENERATED_BODY的时候会在编译的时候报错

情况二


我们自己实现一个无参构造函数, 参考前文这里宏定义, 有两种默认构造器的情况, 前文指向后者



可以看到此时GENERATED_BODY的宏内部生成的宏已经发生变化了, 指向无参的默认构造函数

并且没有重复再声明定义带参数的构造函数, 也没有声明不带参数的构造函数(用户自己实现的)

// 分析的时候看到这两个宏效果不同, 但另一个宏没有用到, 就感觉这里有古怪, 果然
总结一下就是

GENERATED_UCLASS_BODY
永远使用带FObjectInitializer参数的构造函数
GENERATED_BODY
如果没有声明一个无参构造函数, 自动声明定义一个带FObjectInitializer参数的构造函数
如果有声明无参构造函数, 不做任何处理
// 如果没记错, 该功能好像是4.9版本左右添加的, 记得旧版本要强制的写有参构造函数, 贼烦
步骤五
最后我们再从头到尾来看generated.h

先将这两个宏摘出来, 字面翻译是, 允许和禁止废弃相关警告

PRAGMA_DISABLE_DEPRECATION_WARNINGS
PRAGMA_ENABLE_DEPRECATION_WARNINGS

确保包含一次


有调整代码顺序, 这里就是两块代码

GENERATED_BODY
GUAO22_Source_GUAO22_Public_GAObject01_h_15_RPC_WRAPPERS_NO_PURE_DECLS
GUAO22_Source_GUAO22_Public_GAObject01_h_15_INCLASS_NO_PURE_DECLS
GENERATED_UCLASS_BODY
GUAO22_Source_GUAO22_Public_GAObject01_h_15_RPC_WRAPPERS
GUAO22_Source_GUAO22_Public_GAObject01_h_15_INCLASS
宏的名称区别在带不带NO_PURE_DECLS

目前来看, 这两个宏最终没有任何区别

// 还是不知道这个非纯DECLS是什么意思

然后是两个构造函数宏, 分别是标准的和加强版

GENERATED_BODY
GUAO22_Source_GUAO22_Public_GAObject01_h_15_ENHANCED_CONSTRUCTORS
GENERATED_UCLASS_BODY
GUAO22_Source_GUAO22_Public_GAObject01_h_15_STANDARD_CONSTRUCTORS
目前来看, 根据前文所述这两个宏最终的区别在构造函数的处理上


然后定义了两个空宏, 暂时不知道用途

然后是对宏实际内容的定义

GENERATED_BODY
GUAO22_Source_GUAO22_Public_GAObject01_h_15_PRIVATE_PROPERTY_OFFSET
GUAO22_Source_GUAO22_Public_GAObject01_h_15_RPC_WRAPPERS_NO_PURE_DECLS
GUAO22_Source_GUAO22_Public_GAObject01_h_15_INCLASS_NO_PURE_DECLS
GUAO22_Source_GUAO22_Public_GAObject01_h_15_ENHANCED_CONSTRUCTORS
GENERATED_UCLASS_BODY
GUAO22_Source_GUAO22_Public_GAObject01_h_15_PRIVATE_PROPERTY_OFFSET
GUAO22_Source_GUAO22_Public_GAObject01_h_15_RPC_WRAPPERS
GUAO22_Source_GUAO22_Public_GAObject01_h_15_INCLASS
GUAO22_Source_GUAO22_Public_GAObject01_h_15_STANDARD_CONSTRUCTORS

声明一个模版函数


定义一个CURRENT_FILE_ID

然后就没有了
</code></pre>
</details>

<details>
<summary>UE4 UObject反射系列(二) Class相关</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/76793813
前言
文章之后会修改.
最近一些文章互相关联性较高, 可能随着某篇文章某些内容的深扒, 而导致一些内容更连贯, 并对所有相关内容进行修改
源码版本4.22
接前文对UGAObject01头文件的分析, 本文是对其生成的cpp文件分析

大钊：《InsideUE4》UObject（四）类型系统代码生成
FlyingTree：UE4中的反射之一：编译阶段
虚幻4属性系统（反射）翻译 - 风恋残雪 - 博客园
步骤一
打开GAObject01.gen.cpp, 我们快速浏览一下整个文件, 先做第一步操作, 宏展开


发现只有这两个宏需要展开

IMPLEMENT_CLASS(UGAObject01, 3246748092)

替换展开可得


分析略

DEFINE_VTABLE_PTR_HELPER_CTOR(UGAObject01)

展开如下, 忽略


第二步
从上到下依次浏览一下函数体


空函数, 忽略


浏览整个文件会发现, 前两个函数在该类中有实现



后两个只是声明, 忽略.


空函数, 忽略


模版函数, 忽略


联系前文, 该函数是UGAObject01::StaticClass的实际实现


空函数忽略

第三步
从上到下依次浏览一下结构体


一个结构体, 也是头文件定义的友元, 里面存储了UClass相关很多信息, 之后分析.



然后是两个静态结构体, 会在构造函数内进行一定的处理, 进行类的构造注册初始化

第四步
参考上几步, 整理分析可得 :

通过Z_Construct_UClass_UGAObject01_Statics结构体存储UClass反射相关的信息

然后FCompiledInDefer和TClassCompiledInDefer<UGAObject01>两个结构体通过一定的逻辑处理之后再调用

Z_Construct_UClass_UGAObject01_NoRegister
Z_Construct_UClass_UGAObject01
来完成对UClass的构造注册(具体内容之后COD相关分析)

所以, 这里, 反射相关, 我们只需要关注Z_Construct_UClass_UGAObject01_Statics这个结构体就可以了.

第五步



UObject* (*const DependentSingletons[])()
一个(UObject* (*)())的函数指针const数组


这个是依赖, 该类依赖于Z_Construct_UClass_UObject和Z_Construct_UPackage__Script_GUAO22, 即UObject基类和/Script/GUAO22包, 会先调用并得到依赖项

const UE4CodeGen_Private::FMetaDataPairParam Class_MetaDataParams[]
只在宏WITH_METADATA为True的时候存在, 如下, 一般只用于编辑器

/** This controls if metadata for compiled in classes is unpacked and setup at boot time. Meta data is not normally used except by the editor. **/
#define WITH_METADATA (WITH_EDITORONLY_DATA && WITH_EDITOR)


可以看到是key-value的一个结构体, 此时有值IncludePath和ModuleRelativePath


const FCppClassTypeInfoStatic StaticCppClassTypeInfo



最后值是bool值, 意义为该类是否是一个抽象类

const UE4CodeGen_Private::FClassParams ClassParams

我们先看最后Meta数据某些情况下可以丢弃的, 所以有了下面这个宏, 如果用, 传递值, 否则传空值



所以, 我们可以一一对应, 得出对应关系

由于是空类, 基本没有什么信息, 简单描述就是一个有两个依赖的非抽象类函数, 类标志是0x001000A0u,


与EClassFlags对应可得出对应的标志为 CLASSRequiredAPI | CLASS_Native | Class_MatchedSerialzers

此时, 我们就已经拿到一个空类的一些数据, 因为是空类, 可能没有什么感觉, 之后内容逐步填充之后, 就有感觉了(手动狗头)

看到这里的朋友注意了, 好好的跟做, 下篇文章有"大招"的(手动滑稽)

结语

上周因为各种原因鸽子掉了, 这篇是补上周的, 同时由于同样的原因, 这周可能也会鸽子
// 好久没用笔记本自带的键盘了, 敲起来很不习惯, 只能看看代码了, 等之后环境好点, 文章都会补上的
</code></pre>
</details>

<details>
<summary>UE4 UObject反射系列(三) Class相关</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/77593798
前言
文章之后会修改.
最近一些文章互相关联性较高, 可能随着某篇文章某些内容的深扒, 而导致一些内容更连贯, 并对所有相关内容进行修改
源码版本4.22
大钊：《InsideUE4》UObject（六）类型系统代码生成重构-UE4CodeGen_Private
在前面的文章中，我们对一个空UObject类进行了一系列的分析， 那么如果不是空类呢？

这就是这篇文章的内容了，内容较多且繁杂， 如果前面掌握不太好，那就回去复习！

同时内容较多， 受限于篇幅， 可能会省略掉很多对比等实际操作.

请根据步骤一步一步跟做， 不保证教会， 但保证看懂。



属性篇 第一节

添加一个float的成员变量， 重新生成项目， 然后与空类（UGAObject01）generated.h和generated.cpp进行对比。

// 后文简称与头文件（generated.h）或者实现文件（generated.cpp）
没有发现任何显著变化， 可以认为无变化。

属性篇 第二节

添加U宏标记， 与空类对比， 进行同样的步骤。

与头文件对比， 无明显变化

与实现文件相比， Z_Construct_UClass_UGAObject05_Statics这个反射信息结构体发生很大的变化


NewProp_TestFloatValue_MetaData

名称直译， 新的属性_属性名称_元数据

这里是收集属性对应的元数据

NewProp_TestFloatValue

从数据上看, 可以轻易的出, 这是这个属性对应的反射信息


跳一下结构体, 可以看到是FGenericPropertyParam这个结构体


属性值一一对应

这里只分析部分, 一些内容等用到的时候再分析.

NameUTF8 : 属性名称

PropertyFlags : 这个属性(EPropertyFlags)0x0010000000000000, 值实际是CPF_NativeAccessSpecifierPublic

Flags : 这个属性标记类属性的类别, 是个枚举, 这里是float

总共有下列这么多情况, 也就是说下面这些是所有可以加U宏的属性类型




PropPointers


可以看到是一个FPropertyParamsBase指针数组, 存储多个反射参数信息的指针

参考注释内容, FPropertyParamsBase只是规定了常见初始序列, 及前几个内容是这几个属性, 其他的多多少少, 会根据不同情况, 做一些拓展.

FPropertyParamsBaseWithOffset在FPropertyParamsBase的基础上多了属性偏移一个int32值

FGenericPropertyParams又在FPropertyParamsBaseWithOffset的基础上多了元数据信息

所以, 存储一个最基础信息的数据, 根据EPropertyGenFlags获得实际的类型, 就能生成对应的变量信息

上述内容就可以得到属性的反射信息, 那么怎么管理到Class上面呢?


如上, 传入Class反射参数一个属性反射信息数组和相应数量

至此, 这个float值, 反射信息就被记录并可以合理生成了.

属性篇 第三节

我们进一步添加一些信息, BlueprintReadOnly, EditAnywhere, Catergory = "Test"

再和刚才的UGAObject05进行对比


元数据添加了一个Category


PropertyFlags值发生了变化


拆分可得, 多了CPF_BlueprintReadOnly | CPF_BlueprintVisible | CPF_Edit

属性篇 第四节

再加上一个Replicated标记呢?


头文件会添加GetLifetimeReplicatedProps的override声明

// 这也是那个常见错误, 标记属性同步之后, 编译报错, GetLifetimeReplicatedProps函数没有定义的原因
PropertyFlags值发生了变化, 多了CPF_Net



属性篇 第五节

修改同步方式为ReplicatedUsing, 与UGAObject07进行对比


可以看到此处RepNotifyFuncUTF8不在为空,为对应的函数名称

PropertyFlags值发生了变化, 多了CPF_RepNotify


那些UFunction相关的就之后再说了

属性篇 第六节
前文分析的都是单一float, 下文会开始分析一些数据类型




与float类型, 只是换了一下类型






等等, 可以看出这些基本都是相同的.

属性篇 第七节


bool值的实现与float, int相比有些特殊, 感觉是因为内存对齐的问题导致的

求大佬指导

属性篇 第八节







对比可以看到, FString,FName, FText实现和float, int类似

属性篇 第九节



看一下AActor的呢, 发现多了一个指针, 联系前文, 是不是很熟悉?

是一个构造AActor对应UClass的一个函数, 详情见之后的COD

以及PropertyFlags值发生了变化, 多了CPF_UObjectWrapper









可以看到, WeakObject和SoftObject的基本类似.

属性篇 第十节



TSubclassOf<>相比AActor属性相关多了一个Z_Construct_UClass_UClass函数指针, 预计是这里依赖到了UClass, 所以要获得其构造函数, 提前调用



TSoftClassPtr<>相比又不一样

统一比较一下

struct FObjectPropertyParams
UClass* (*ClassFunc)();
struct FClassPropertyParams
UClass* (*MetaClassFunc)();
UClass* (*ClassFunc)();
struct FSoftClassPropertyParams
UClass* (*MetaClassFunc)();
具体区别在哪里? 可能在之后会有分析吧.

属性篇 第十一节


忽略调枚举本身的反射, 之后分析

枚举的处理就有些看不懂了, 相比前面属性的处理, 枚举这里有两个结构体信息


这是正常的反射信息, 函数指针是枚举对应对枚举UEnum的构建函数


这个,,, 由于ArrayDim两者相同, 所以可以对应到一起, 但用处,,, 看不懂.

属性篇 第十二节


忽略掉结构体本身的反射

相比来看, 也比较简单, 存了一个函数指针, 构建依赖的结构体(UScrUScriptStruct)

属性篇 第十三节




TArray这里的实现, 也是两个结构体, 一个是数组本身, 一个是数组对应的类型

数组对应类型结构体NewProp_TestValue_Inner数据很多都是空值, 只是为了收集数据类型.




TSet同TArray





TMap则类似, 有三个结构体, 一个键的数据类型,一个值的数据类型

其他同上

不过可以看到Offset这个值, 键为0, 值为1, 有做一定的区别

具体原因, 不知, 后文遇到分析.

属性篇 第十四节



PropertyFlags值发生了变化, 多了CPF_InstancedReference

并多了一个Z_Construct_UDelegateFunction_UGAObject26_TestGADelegate__DelegateSignature函数指针, 从代码上看及推断, 应该和前文类似, 是Delegate的依赖, 不太明白



以及最后的动态多播代理



基本同单播实现

同时, 这里PropertyFlags值添加一个BlueprintAssignable发生了变化, 多了CPF_BlueprintAssignable


属性篇 第十五节
至此, 多数常见的数据类型的反射信息就分析过一篇了.

可能存在没有分析的内容(看不懂).

可能存在没有分析到的数据类型(赖或者不常用)

自己总结概况整理一下, 很多地方都是相同的.

属性篇 第十六节
最后的最后, 是最后一种情况, 如果有很多属性呢? 如果和C++普通的属性混在一起呢?






是不是很熟悉呢? 只是重复定义并在数组里面加了一个值

至此, 反射系列关于参数相关的告一段落, 中间缺失的内容之后会视情况补上.

总共十六小节, 从GAObject04到GAObject28, 这么多个类, 希望一步一步跟做.

嗯, 虽然, 估计, 实际上, 应该不会有几个人跟着做(手动狗头)


</code></pre>
</details>

<details>
<summary>UE4 UObject反射系列(四) Class相关</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/78026582
前言
文章之后会修改.
最近一些文章互相关联性较高, 可能随着某篇文章某些内容的深扒, 而导致一些内容更连贯, 并对所有相关内容进行修改
源码版本4.22
吐槽
这篇文章是UObject系列的开始的第四篇文章

离立下这个系列的Flag已经大概三周了.

然后, 感觉, 嗯, 能收回这个flag吗(手动狗头)

大钊：《InsideUE4》UObject（六）类型系统代码生成重构-UE4CodeGen_Private
接前一篇文章, 我们对UPROPERTY()属性相关的反射数据进行了分析, 然后就是UFUNCTION()函数相关的了.

基本分析逻辑同前文, 就不赘述了.

同时, 因为篇幅问题, 省略掉对应的函数实现,

都

函数篇 第一节

普通的C++函数, 无明显变化, 忽略

函数篇 第二节

添加一个空的U宏


头文件GUAO22_Source_GUAO22_Public_GAObject30_h_15_RPC_WRAPPERS和GUAO22_Source_GUAO22_Public_GAObject30_h_15_RPC_WRAPPERS_NO_PURE_DECLS宏中添加了一些宏, 参考前文, 这里是对前文两个空宏内容的填充

两个宏的内容一致, 然后进行宏展开







Stack.Code += !!Stack.Code; /* increment the code ptr unless it is null */
// 忽略
SCOPED一个计时的宏, 忽略

剩下的, 也就是这里需要关注的调用类对象的TestFunc

然后再对比实现文件



调用FNativeFunctionRegistrar::RegisterFunctions, 注册类的函数

收集了函数名称, 和一个执行该函数的函数指针(execTestFunc)


多了一个函数反射信息的结构体

Function_MetaDataParams


元数据, 不解释了, 忽略

FuncParams


收集了函数的各种反射信息, 之后将逐步分析

OuterFunc
获得Function的Outer, 估计也是解决依赖关系用的.
NameUTF8
名称
ObjectFlags
对应UFunction类的标志, 同前文
FunctionFlags
函数本身的标志, 这里是0x00020401, 即 FUNC_Public | FUNC_Native | FUNC_Final

MetaDataArray, NumMetaData
元数据, 忽略

多了一个对应UFunction的构造函数 Z_Construct_UFunction_UGAObject30_TestFunc


类的反射信息中多了一个FuncInfo



存储了前面的函数构造函数及对应名称


然后将所有函数的反射信息, 放到类反射信息中.

至此, 一个空函数的反射信息就分析完毕了.

函数篇 第三节

添加一个BlueprintCallable宏


添加一个BlueprintCallable宏, 只有FunctionFlags发生变化, 多了 FUNC_BlueprintCallable




函数篇 第四节

添加一个BlueprintImplementableEvent宏


头文件中GUAO22_Source_GUAO22_Public_GAObject32_h_15_RPC_WRAPPERS和GUAO22_Source_GUAO22_Public_GAObject32_h_15_RPC_WRAPPERS_NO_PURE_DECLS这两个宏反而没有任何内容了??



再看实现文件中, 这里实现文件实现了TestFunction

找到TestFunction对应的UFunction并执行.




同时注意这里, 相比前文没有注册函数, 内容为空, 也就是说, 默认是没有TestFunction对应的UFunction的, 需要在蓝图中进行定义


其他内容基本相同, 这里FunctionFlags变化较大, 值为FUNC_BlueprintEvent | FUNC_Public | FUNC_Event


函数篇 第五节

添加一个BlueprintNativeEvent宏


宏展开同前文, 这里注意画圈的地方, 会声明函数TestFunction_Implementation, 如果未人工声明的话, 且该函数为虚函数

定义的execTestFunction函数执行的不是TestFunction而是TestFunction_Implementation

联系该BlueprintNativeEvent, C++里面有一定实现, 蓝图实现逻辑, 并选择性调用C++逻辑

应该不难理解, execTestFunction是为了蓝图选择性调用C++实现函数, 所以执行TestFunction_Implementation


函数体本身同BlueprintImplementableEvent, 忽略


注意, 这里有对TestFunction进行注册

如果蓝图没有定义该函数
会走C++此处注册的函数, 走即C++的实现
如果蓝图有定义该函数
蓝图函数实现会替换此处注册的函数, 同时蓝图的CallSuper函数, 实际就是调用此处C++注册的函数, 即C++的实现

最后就是FunctionFlags不同了, 相比BlueprintImplementableEvent多了FUNC_Native


函数篇 第六节

那, 如果函数有返回参数, 会怎么样呢?


基本同前面的宏展开, 所以直接贴最总结果了



然后, 我们看函数反射信息结构体


多了几个值, 是不是很熟悉? 前文中的属性相关.

PropertyFlags为0x0010000000000580, 即 CPF_NativeAccessSpecifierPublic | CPF_ReturnParm | CPF_OutParm | CPF_Parm



同前文用法, 忽略


将返回属性所占的大小, 类型, 数量记录到函数反射信息中国年

FunctionFlags值为0x00020401, 即


函数篇 第七节

添加一个BlueprintPure宏


添加一个BlueprintPure宏, 发现只有FunctionFlags有变化, 值为FUNC_BlueprintPure | FUNC_BlueprintCallable | FUNC_Public | FUNC_Native | FUNC_Final


函数篇 第八节

如果有参数, 会是什么样子呢?




可以看到通过Stack获取到Z_Param_Test的值, 并在调用函数时传递


对比CPP文件, 与有一个返回参数相比, 大致结构基本一致.

这里参数的PropertyFlags值为0x0010000000000080, 即CPF_NativeAccessSpecifierPublic | CPF_Parm, 少了CPF_ReturnParm | CPF_OutParm


这里函数的FunctionFlags值为0x00020401,即FUNC_Public | FUNC_Native | FUNC_Final



然后看这个参数结构体, 前文中返回值ReturnValue也是放在这里, 也就是说返回值和传入参数都放在这里, 都被当做一个属性, 收集其反射信息, 并根据反射信息判断是返回值还是输入参数

后面也有相应的分析印证.

函数篇 第九节

那我们给参数添加一个引用呢?




看以看到传引用的参数, 获取方式有一定不同


这里参数的PropertyFlags值为0x0010000000000180, 多了CPF_OutParm

暴露给蓝图的函数, 其中参数直接传递或者加const &传递, 会当做普通参数,如果只加&则会当成输出参数


这里函数的FunctionFlags值为0x00420401, 多了FUNC_HasOutParms


函数篇 第十节

多个参数呢?



基本同上


参数变成两个, 并有两个属性的反射信息


两个对应的熟悉给你值, 没有什么好分析的了


这里数组记录两个属性反射信息的指针.

其余地方和前面雷同, 自行比对即可.

函数篇 第十一节

然后, 既有参数, 也有返回值呢?



同上


这里参数结构体里面有三个值, 先放传递参数, 最后是返回值

// 做个不符责任的猜想, 应该就是蓝图函数节点左边输入参数, 右边输出参数的顺序

这里函数的FunctionFlags值为0x00020401, 即FUNC_Public | FUNC_Native | FUNC_Final, 前文很多情况都是这个值.

函数篇 第十二节

嗯, 还剩下几个RPC相关的, 先来看可靠服务器函数


如果C++内没有定义, 会自动定义ServerTestFunc_Validate和ServerTestFunc_Implementation两个函数


函数执行的时候回先ServerTestFunc_Validate检测, 如果有问题那么调用RPC_ValidateFailed

否则, 正常调用ServerTestFunc_Implementation函数


注册对应的UFunction函数, 当没有被其他函数重写的时候, 实际执行的就是execServerTestFunc函数


这个RPCId和RPCResponseId值为0, 好像值就是为0?? 还是之后在什么地方赋值??

这里函数的FunctionFlags值为0x80220CC0, 见图


其他基本类似


不可靠呢?


这里函数的FunctionFlags值为0x80220C40, 少了FUNC_NetReliable


函数篇 第十三节


基本同Server, 这里函数的FunctionFlags值为0x81020CC0


函数篇 第十四节


嗯, 就是一个普通的UFunction


没有什么特殊的地方, 这里函数的FunctionFlags值为0x01020CC0, 少了FUNC_BlueprintEvent


函数篇 第十五节



没有什么特殊的地方, 这里函数的FunctionFlags值为0x00024CC0


函数篇 第十六节

前文中有说到RPCId和RPCResponseId值为0, 这里是一个验证.

这里定义了很多函数, 但结果还是0, 这个值...

函数篇 第十七节



至此, 反射系列关于函数相关的告一段落, 中间缺失的内容之后会视情况补上.

总共十七小节, 从GAObject29到GAObject46, 这么多个类, 希望一步一步跟做.

嗯, 虽然, 估计, 不会有几个人跟着做(手动狗头)

四篇文章之后, 各位应该对UE4 各种数据类型反射信息生成及有哪些反射数据有一定认知了

然后, 就要在这些反射信息基础上, 创建对应的UClass类了, 并逐步构建UObject类了.



文章配套的项目和笔记

GuAoDiao/GUAO22
</code></pre>
</details>

<details>
<summary>UE4 UObject系列之UClass(一)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/78684047
前言
文章之后会修改.
最近一些文章互相关联性较高, 可能随着某篇文章某些内容的深扒, 而导致一些内容更连贯, 并对所有相关内容进行修改
源码版本4.22 源码版
吐槽
这篇文章是UObject系列的开始的第五篇文章

离立下这个系列的Flag已经大概四周了.

本周工作上出现一个网络相关的特别坑的bug, 查测折腾了三四天.

后悔当初没有选网络同步相关系列一次...

同时, 由于某毒奶粉的活动相当友好.

嗯, 所以, 之后, 最近, 那个, 偶尔拖更什么的会很正常.

在前文UObject之UClass反射系列中, 我们已经得到了一系列的反射信息.

并通过FCompiledInDefer和TClassCompiledInDefer两个静态结构体进行记录

那么, 就让我们对这些信息进行进一步的处理, 开始构建一个UClass

大钊：《InsideUE4》UObject（七）类型系统注册-第一个UClass

我们先看这两个结构体, 可以看到TClassCompiledInDefer在前, FCompiledInDefer在后

所以我们顺序分析.


从构造函数入手, 调用UClassCompiledIndef函数


FCompiledInDefer忽略掉热加载相关



一步一步跳, 并逐步替换, 在DeferredClassRegistration这个静态数组中添加了一个值


我们再来分析FCompiledInDefer


bDynamic为fasle, 里面内容不执行



参考展开后的内容, 这里会调用两个NotifyRegistrationEvent, 忽略

在DeferredCompiledInRegistration静态数组中添加了一个函数指针, Z_Construct_UClass_UGAObject

是不是很眼熟? 不眼熟? 乖乖回去补前面UClass反射相关文章去.

到此, 这两个结构体的使命, 就完成了一大半了.

在程序进入主函数前, 将反射信息集合到一起, 并在进入主函数后根据逻辑注册

// 印象中, C++反射常见的是类似写法, 但会直接进行注册, UE4是延迟之后根据逻辑注册
// 区别很大
也就是在main()之前, 两个静态数组里面就有了一堆值了.

接下来就是程序运行, 开始建立默认的UClass了

我们在GetPrivateStaticClassBody和ConstructUClass两个函数内打断点


可以看到, 最先运行的是UObject的GetPrivateStaticClassBody


这个由IMPLEMENT_VM_FUNCTION(EX_CallMath, execCallMathFunction)触发


然后执行一次UClassRegisterAllCompiledInClasses函数, 进行一部分类的注册


在FEngineLoop::PreInit中, 加载CoreModule时触发


从这个数组返回值的数量, 可以看到有2200多类需要注册


并实际调用StaticClass, 并最终调用GetPrivateStaticClassBody函数


接着会在FEngineLoop::PreInit中调用ProcessNewlyLoadedUObjects函数


UClassRegisterAllCompiledInClasses该函数又再次被调用, 注册一部分类


可以看到, 这次只有100多个类


然后在UObjectLoadAllCompiledInDefaultProperties函数内


并调用对应的函数, 即Z_Construct_UClass_UGAObject

对应UE4CodeGen_Private::ConstructUClass这个函数


这个函数, 是正儿八经拿着反射信息, 进行处理的.

再往后走, 会发现ProcessNewlyLoadedUObjects函数会不停的被调用, 模块加载啊? 插件加载啊? 等等

至此, 整个UClass的创建流程上就完毕了.

这篇文章就先这样了, 之后会有改动, 感觉缺东西.

中间的具体细节就留到之后分析了

结语

本周周更
本文中有些内容有缺失的地方, 可能会在之后找到对应资料, 或者有合适位置的时候再展开分析
原计划是本文稍微带一些UClass创建的, 相关内容, 笔记都提前做好了

这篇文章分析要用UE4.22 源码版, 不然一些断点打不上
家里笔记本没有, 好, 上周就开始下载安装...
在今天写的时候作死的点了重新编译... 一两个小时过去了
又是第一次打开UE4.22源码版的编辑器, 卡在45%编译材质... 半个小时过去了
</code></pre>
</details>

<details>
<summary>UE4 网络相关系列 序</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/79906329
导言

嗯, 被人逮到催更了.

那只好"更"了呗.

然后, 嗯, 就有了这篇文章(手动狗头)

目录(草稿)
Client-Server体系
客户端连接服务器的完整流程
客户端与服务器登录时的版本比对
客户端与服务器断开连接的完整流程
ENetMode中NM_Standalone, NM_Client, NM_ListenServer, NM_DedicatedServer的区别与用途
ENetRole中ROLE_None,ROLE_SimulatedProxy,
ROLE_AutonomousProxy,ROLE_Authority的区别与用途
网络同步的权限Owner分析及背后的取舍
地图关卡相关
StreamlLevel网络相关处理
无缝切关相关(SeamlessTravel)
无缝切关的基本流程
带Actor的无缝切关
无缝切关带数据
无缝切关时PlayerController的处理及相关bug
Gameplay相关
GameMode, GameState, PlayerController各类的先后生成和同步顺序
Server和Client中Gameplay各类的同步规则, 和注意事项
在登录的时候拒接非法用户
同步相关
RPC函数相关
RPC函数的基础调用
RPC函数的完整实现原理及流程分析
RPC函数的先后网络同步顺序
RPC函数的同步可靠性
RPC函数的常见问题
属性同步
属性同步的基础使用
属性同步原理规则
属性同步的先后顺序
属性同步的常见问题
动态重写属性同步, 自定义属性同步流程
AActor & UObject & UActorComponent
AActor的同步流程, 生成和销毁
不同端AActor的联网一一对应原理及实现分析
UActorComponent同步与不同步的区别, 对应关系原理
SubObject的同步使用和流程原理
AActor位置同步的网络分析
UActorComponent同步相关
AActor的同步条件, 休眠等等
取舍AActor是否该网络同步杂谈
同步相关杂
属性同步和RPC同步的先后顺序及常见坑
Online Subsystem 了解不深, 暂略
Session相关等等
ReplicationGraph相关 暂略
杂
自定义UStrcut网络序列化, 减少带宽销毁
网络同步相关的测试命令行, 及调试工具


作为一个工作到现在, 网络相关也用了很久, 也一致在负责, 算熟练工了吧

往大说, 要考虑延迟, 传输量, 频率, 并减少一切不必要的消耗

往小说, 要考虑bug, bug, bug

网络延迟高? 各种问题.

网络延迟低? 也有问题.

网络丢包率高? 各种问题.

网络丢包率低? 也有问题.

写法一不留心? 各种问题.

写法十分注意? 额, 暂时没有问题...

然后呢...

上述目录中, 网络相关很多东西都没有提到...

即使提到了, 没有案例, 泛泛而谈, 会很空洞...

即使空洞也看得懂, 若没有亲身经历过又真的无法感同身受...

总之呢...

UE4网络是个非常庞大的体系...

UObject系列还需要慢慢的分析(水文章)...

催更的, 我更了, 然后呢, 就挂在这了呗.

挂这了
这了

了






就挂在这, 吊着你胃口了

不服气, 来打我啊(手动狗头)
</code></pre>
</details>

<details>
<summary>UE4 UObject系列之UClass(二)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/80720040
前言
文章之后会修改.
最近一些文章互相关联性较高, 可能随着某篇文章某些内容的深扒, 而导致一些内容更连贯, 并对所有相关内容进行修改
源码版本4.22 源码版
经过前文不难得出, UClass的初始化, 核心在两个函数

GetPrivateStaticClass
ConstructUClass
下面, 就开始对这个函数进行逐步分析

GetPrivateStaticClass




进行替换可得如上图, 都是前文熟悉的内容了.


然后跳入该函数, 里面主要步骤就如图中的了.



第一步, 分配内存FUObjectAllocator::AllocateUObject


由于bAllowPermanent为true, 所以分配在常驻内存中



第二步, new UClass进行构造



// 因为实在打不到GUAO_Object的断点, 所以断点数据拿UObject进行分析了







可以看到是调用了一堆类的构造函数, 进行赋值操作.


我们参考一下UObject的数据, UFiled往上的父类, 实际赋值只有ObjectFlags

值为RF_Public | RF_Standalone | RF_MarkAsNative | RF_Transient | RF_MarkAsRootSet

一个临时原生不能被C++的其他包可见的UObject


UStruct则只有一个PropertiesSize, 取值是sizeof(UObject), MinAlignment给默认值1




UClass也基本类似, 此时多数仍为默认值, 空值.

此处的构造函数, 倾向于构建一个基础的UClass类, 并填一些最基础的数据. 并在之后逐步完善.


接着往下, 调用InitializePrivateStaticClass, 调用时会先执行Super和WithInClass的StaticClass函数



替换数据后, 基本如上图




先从FUObjectHashTables中移除, 并在设置后再添加

此处走逻辑时, 由于Name值为空, 没有任何处理





ClearFunctionMapsCaches则是清空这个UFunction的TMap缓存


调用服务UStruct::SetSuperStruct, 修改SuperStruct属性值



然后调用RegisterDependencies, 该函数在UObjectBase中定义, 内容为空, 此处是先调用自己的RegisterDependencies, 再调用Super的RegisterDependencies...

...不知道什么用? 留做扩展??


然后向FPendingRegistrantInfo中插入一个值

注意此处第一个值是this, 即一个UClass


UObjectForceRegistration这个函数在UObjectProcessRegistrants, 而UObjectProcessRegistrants在ProcessNewlyLoadedUObjects中.

就是前文中的那个ProcessNewlyLoadedUObjects函数


DeferredRegister中会调用父类的函数, 然后再次获取ClassConfigName??

然后继承父类的ClassFlags和ClassCastFlags


父类的UObjectBase::DeferredRegister中创建一个包, 看实现, 实际是寻找, 不存在创建

并标记这个包是在编译的时候创建的

//	PKG_CompiledIn					= 0x00000010,   ///< This package is from "compiled in" classes.
同时设置OuterPrivate值为这个包


设置ClassPrivate为UClassStaticClass, 传入值为Register中给的Class值或者UDynamicClass::StaticClass


然后我们跳一下AddObject, 这里会修改NamePrivate值为Name

清除RF_MarkAsRootSet和RF_MarkAsNative两个标记, 维护一个标记值设置给UObject对应的FUObjectItem



这个函数主要的处理就是赋值InternalIndex, 并建立相应的维护

最后在HashObject




最后是注册NativeFunc, 即调用传入的参数StaticRegisterNativesUGAObject


空函数, 略过(之后单独抽出来分析)

至此, GetPrivateStaticClass过程就完毕了, 主要做了

创建一个Class对象, 并分配了内存空间, 处于常驻内存中, 不会被GC
填充Class的基础数据
留着... 分析完下一篇再修改...

</code></pre>
</details>

<details>
<summary>UE4 UObject系列之UClass(三)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/81014923
前言
文章之后会修改.
最近一些文章互相关联性较高, 可能随着某篇文章某些内容的深扒, 而导致一些内容更连贯, 并对所有相关内容进行修改
源码版本4.22 源码版
接前文, 本文是对ConstructUClass函数的进一步分析.

这里打断点相当容易, 所以下面以一个空类UGAObject进行分析

废话不多说, 上源码.


如果Class已经构造过, 那么直接返回, 避免重复构造



循环调用所有依赖项


实际调用的就是UGAObject::StaticClass函数, 取其返回值, 继续创建.

使所有同一Class的创建, 基于同一个C++对象.


再次检测, 如果Class已经构造过, 那么直接返回


前文中应该, 见过, 强制注册UObject

在StaticClass函数中, 可能会将DeferredRegister函数调用延迟, 这里就是为了避免延迟函数不被调用, 而强制调用的.

回顾前文, StaticClass会在ConstructUClass之前调用, 同时在ConstructUClass之前, 会调用StaticClass中注册的UObject的DeferredRegister

感觉这里的做法, 是在假设StaticClass在这之前没有被调用而写的...

挖个坑, 以后看情况埋..


继承父类的ClassFlags并添加CLASS_Constructed标记与反射信息中的标记


见注释, 不懂.


根据反射信息初始化UFunction和UProperty相关, 之后单独分析


设置配置名称


嗯, 就 一个bool值bIsAbstract, 忽略


接口相关的, 忽略掉



元数据, GetOutermost返回的是/Script/GUAO22(UPackage)

向里面添加元数据


不懂, 忽略



主体流程就这些了, 细节之后单独分析, 或者, 就挂着不管了...

至此, 一个Class的构造就算完成了吧... 应该没有后续内容了...

然后, 我们来回顾一下


UObject中最关键也是唯一的几个属性值, 在哪里创建, 值是什么, 应该有数了.


UClass中一些属性值也该眼熟了.


</code></pre>
</details>

<details>
<summary>UE4 UObject系列之UProperty(一)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/82603132
前言
文章之后会修改.
最近一些文章互相关联性较高, 可能随着某篇文章某些内容的深扒, 而导致一些内容更连贯, 并对所有相关内容进行修改
源码版本4.22 源码版
接前文UE4 UObject系列之UClass(一二三), 我们已经对UClass相关的生成进行了一定的分析

在分析UClass使用等功能前, 让我们先停下脚步

回过头来补齐UProperty和UFunction相关的创建初始化的细节

停下

-->

->

为了更好地前行


前文可得, 在UClass的ConstructUClass函数中, 调用ConstructUProperties函数, 该函数参数是属性对应的Class和属性的反射信息



然后while循环遍历整个反射信息数组, 调用ConstructUProperty,来实际创建每一个UProperty

下文将会以UGAObject09, 一个int32的属性, 进行最基础的分析



ReadMore这个变量, 在下一篇文章中叙述

其余变量, 则是简单的初始化.

然后, 重点来了:


通过&运算, 获得反射信息中, 该属性的类型, 原始值和结果值都是EPropertyGenFlags::Int


然后, 将反射信息强行转换成FIntPropertyParams, 并new UIntProperty


显示通过operator new重载, 来分配内存空间, 实际调用StaticAllocateObject函数实现

该函数过于复杂, 且与此次关联不大, 后面再分析


从结果来看, 一个UObject需要的基础数据是被构建好的.




UIntProper会逐步调用父类的构造函数, UObject不关心, 忽略

UField构造函数体为空, 忽略

UProperty构造函数中修改PropertyFlags, Offset_Internal两个值, 属性标记和属性的偏移, 然后调用Init函数


维护多个属性之间的顺序, 前面的属性的Next指向下一个属性

UProperty与UIntProperty之中的构造函数没有什么处理, 忽略


最后, 我们看这个属性初始化后的样子, 中间继承树之后分析, 先忽略


属性大小和属性偏移, 属性标志三个被正常设置


由于是第一个属性且只有一个属性, 所以Next为空




在属性创建后, 接下来是添加属性的元数据, 会调用GetOutermost获得/Script/GUAO22的UPackage对象, 然后获得对应的UMetaData

并调用UMetaData的SetValue函数, 去添加维护元数据



实际上, 是维护一个TMap, Object为键, 元数据为值
元数据又是一个TMap, FName为键, FString为值, 存放实际数据


然后维护ArrayDim值, 和RepNotifyFunc值


如果ReadMore存在, 则递归读取, 否则返回至外面while循环

直到所有的UProperty创建完成

结语

本周周更
本文中有些内容有缺失的地方, 可能会在之后找到对应资料, 或者有合适位置的时候再展开分析
最近两三周文章可能有点水(字数篇幅上, 内容也有点吧...)

之前是某游戏活动, 之后是有些个人事情处理, 会忙不太过来

预计还会每周水, 持续到10月底11月初, 等忙完之后, 预计 :
系统整理下所有发过的文章
补补UObject已写系列里面的一些缺漏项
将UClass, UProperty, UFunction反射数据类型相关尽快完结, 开始下一个UObject创建销毁流程大坑什么的
// 弱弱说一句, 最近看UObject系列源码, 只反射数据类型相关的源码, 能写或深扒的东西, 轻轻松松过10篇
// 挖了一个好大的坑
</code></pre>
</details>

<details>
<summary>UE4 Delegate(代理)相关源码分析(四)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/93455335
前言
源码版本4.22

嗯, 有错就要认 ,挨打要立正, 所以有了这篇代理四

这篇文章主要内容, 是关于为什么代理预绑定参数无法传引用?



嗯, 首先, 现需要了解什么是指针, 什么是引用.

指针和引用_百度搜索

嗯, 自己搜索找文档去...

进入主题 : 引用和指针有一点显著区别, 引用必须被初始化, 而指针不必.

他会带来什么问题呢?


如图写法, 报错, 引用必须被初始化


那么如果是一个结构体呢? 当然也不行, 报错


那么TTuple呢? 元组和结构体很像, 也会报错, 引用无法初始化



那么, 直接代理分析有得出, 预绑定参数会通过TTuple存储, 而存储TTuple的又是一个类(DelegateInstance)

引用在类初始化的时候, 必须被初始化.

所以当然, 预绑定参数不能传递引用了

水完, 走人

结语
代理第四篇了.....

干脆下周水水文章, 再写一代理五吧, 写写代理使用的几种方式, 拿UE4几处代码使用来讲.
骗赞了, 骗评论了




// 想象一般都是比较美好的, 实现总是残酷的.

然而并不是....

先来解释下, 当初为什么会这样认为?

知识盲区


那当初做代码测试的时候, 都有做测试的, 为什么没有试出来结论不对?

官方bug(手动狗头并假装有删除线)




相信大家当初学习C++ const修饰符的时候

都多多少少应该有了解, 类的成员属性可以被const修饰

但必须在构造函数初始化列表中初始化

那引用是不是也可以在构造函数初始化列表中赋值呢?



试一下, 可以....

那TTuple呢?


当然也可以

因此, 只要写法合理, TTuple所在类完全可以传递一个引用.

那么UE4写法会不合理吗?



还是拿TBaseUObjectMethodDelegateInstance来看, 可以看到TTuple的初始化是在

TBaseUObjectMethodDelegateInstance的构造函数中的

也就是说, TBaseUObjectMethodDelegateInstance是支持预绑定参数传递引用的


那为什么编译报错呢?????


嗯, 代理还有一种绑定方式. CreateXXX 系列


那这个呢? 编译成功了????

当初测试的是哪个来着, Bind系列....

官方bug, 实锤(手动狗头)


那为什么呢?

看一下BindUObject的实现

传入的时候VarTypes是int32&, 当传递到CreateUObject的时候, 由于没有加模版, 所以&就被去掉了

就被去掉了

就被去掉了

VarTypes此时就变成int32, 但函数指针还是int32&, 互相冲突

??? 这什么神仙操作 ???


同时多播的AddXXX系列也有这个问题



嗯, 所以结论如下 :

预绑定参数可以传引用, 或者const 引用, 且只有CreateXXX系列支持.

单播的BindXXX系列和多播的AddXXX系列都不支持预绑定参数传引用.



// 有认识官方程序大佬的可以问问咋回事吗????
// 没有, 就当我没说...

水完, 走人




真的水完了, 没东西了(手动狗头)
</code></pre>
</details>

<details>
<summary>UE4 Delegate(代理)相关源码分析(五)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/94380081
前言
源码版本4.22
不知不觉, 代理相关已经分析(水)到第五篇了.

而代理相关, 也是目前所有源码分析里面最全面, 最系统的了.

其他UObject系列啊, 还是Gameplay系列都比较杂乱, 不成体系.

// 能水的东西太多, 水不动...
嗯, 今天就先把代理相关收个尾, 以UE4一些源码的使用角度, 来举一些例子 :

UE4代理(假装有删除线)

UE4委托可以怎么用? 能玩出什么花样.

同时, 本文可能会偏向于实践背后的理论, 即术, 会尽最大努力保证用词说法的严谨准确

如有错误或歧义的地方, 希望指出!

Software design pattern Wiki
最后, 表示 :

从不同的角度看同一个实现, 看到的可能是不同的东西.

下文是本人眼中的视角, 也许不是对的, 但不会是错的(手动狗头).


同学们, 集中注意力, 现在开始, 孤老师将带你们进入UE4这一神奇的世界

首先, 我们来做一个开关灯的逻辑

来, 让我们先创建一个AActor

再给AActor添加一个BoxCollisionComponent碰撞组件

接着添加一个PointLightComponent点光源

然后在BoxCollisionComponent组件的Detail详细面板中, 找到OnCompon....

...

...

走错片场了...

...

...

还是直接上源码吧(手动狗头)



如图, 这些碰撞相关代理, 都是多播动态委托的典型, 以OnComponentBeginOverlap为例

它们都是UPrimitiveComponent类的中一个UPROPERTY属性, 每一个都是一个动态多播委托, 并有多个参数

从设计模式上讲, 此处的应用可以看做是观察者模式(Observer pattern). // 自搜

从语义上讲, 这是一个 当某事物开始与该组件重叠这一事件发生时, 进行多播

从功能扩展角度讲, 在不需修改其内部代码, 不关心上下文执行的情况下, 在任何地方(蓝图或C++), 都可以监听BeginOverlap事件, 并根据运行环境或状态, 动态的绑定和解绑.

多播委托主要的用途基本类似这里了.

接着, 我们再来看一个多播普通委托的例子, 也是引擎的一个正常操作


在UWorld中, 有个TickDispatchEvent的多播委托, 有一个float参数

// 忽略掉DECLARE_EVENT, 参考前文, 当做多播委托, 没啥毛病的
该委托在UWorld::Tick中进行多播



嗯, 很普通的使用, 这里是一个扩展点, 可以扩展UWorld的Tick事件罢了.

但正常操作来了!!!

// 为啥是正常操作呢? 因为看多了, 不觉得骚了...


随便写一个RPC函数, 联网运行, 打断点, 你从函数调用栈会发现, RPC联网功能是在UIpNetDriver::TickDispatch里面



在UNetDriver初始化, SetWorld的时候, 将UIpNetDriver::TickDispatch绑定到UWorld::TickDispatchEvent委托上面

啥意思呢?

如果有网络相关, 才会有UNetDriver等相关类

如果有UNetDriver等相关类, 才会绑定UWorld::TickDispatchEvent等代理

如果绑定过UIpNetDriver::TickDispatch, 才有网络RPC等功能

一环扣一环





合理使用委托, 可以使得代码极其优雅.





啥? 你觉得用个bool值控制就行了, 为什么要这么麻烦?

是的, 没错, 您说什么都是对的(手动狗头)

最后, 我们回过头来看看, 单播委托.


如果说单播委托, 引擎最长接触到的, 估计就是Timer定时器相关的了!


例如上图, 在2.f后执行RunFunc函数

从设计模式上讲, 此处的应用可以看做是代理模式. // 自搜

// 这也是为啥UE4委托, 前文很多地方叫都写成代理的原因之一. 
// 原因之二呢? Delegate 读一下, 代理给特, 嗯, 代理实锤

// 那把UE4委托称谓UE4代理对吗? 好像只是不错...
虽然, 从不同角度和不同使用方法, 可把单播委托看成和用成不少设计模式, 所以他其实是一个乱七八糟设计模式. (手动狗头)

但设计模式不重要, 重要的是单播委托能做什么?

能做什么?

嗯, 这个问题问得好, 他可以做的是:

参考多播委托可以做什么, 单播委托也可以做, 虽然只能绑定一个, 是个阉割版(手动狗头)




那除此之外呢? 例如上面两处, 定时器和按键相关, 给委托绑定一个处理, 定时调用或者按键触发



还有吗?



还记得, 单播委托是可以带返回值的吗?

...

...

...

找不到引擎使用的例子, 就随手写了.


如上图, 定义一个获得分数的返回int32的普通委托

如果委托有绑定, 那么走委托绑定的自定义实现, 通过绑定的方法拿值

如果没有绑定, 走默认方法拿值

可以使用委托, 将一个功能实现, 放到外部去实现

例如此处的拿分数, 可以在外部实现, 直接调用委托执行取值即可

可以使用委托, 并配合逻辑, 控制使用默认逻辑还是使用自定义逻辑, 即控制逻辑走向, 方便逻辑扩展的控制



还有吗?

...

...

...


再贴一个, 代码如上 : 委托配合数组, 实现一个按键相应功能

这里是有一个委托数组, 依赖于数组顺序, 通过每个委托的执行返回值, 来控制逻辑走向.



那还有吗?

...

...

...

你猜?
</code></pre>
</details>

<details>
<summary>UE4 Subsystems 相关源码分析</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/97253584
前言
UE4 版本4.24
UE4 Subsystems 是4.22新加的功能, 最近写项目玩的时候碰到了, 感觉有点意思.
南京周润发：UE4.22 Subsystem分析
Programming Subsystems
Programming Subsystems - October 17 - Live from HQ
// Source\Runtime\Engine\Public\Subsystems\Subsystem.h
/** Subsystems are auto instanced classes that share the lifetime of certain engine constructs
 * 
 *	Currently supported Subsystem lifetimes are:
 *		Engine		 -> inherit UEngineSubsystem
 *		Editor		 -> inherit UEditorSubsystem
 *		GameInstance -> inherit UGameInstanceSubsystem
 *		World		 -> inherit UWorldSubsystem
 *		LocalPlayer	 -> inherit ULocalPlayerSubsystem
 *
 *
 *	Normal Example:
 *		class UMySystem : public UGameInstanceSubsystem
 *	Which can be accessed by:
 *		UGameInstance* GameInstance = ...;
 *		UMySystem* MySystem = GameInstance->GetSubsystem<UMySystem>();
 *
 *	or the following if you need protection from a null GameInstance
 *		UGameInstance* GameInstance = ...;
 *		UMyGameSubsystem* MySubsystem = UGameInstance::GetSubsystem<MyGameSubsystem>(GameInstance);
 *
 *
 *	You can get also define interfaces that can have multiple implementations.
 *	Interface Example :
 *      MySystemInterface
 *    With 2 concrete derivative classes:
 *      MyA : public MySystemInterface
 *      MyB : public MySystemInterface
 *
 *	Which can be accessed by:
 *		UGameInstance* GameInstance = ...;
 *		const TArray<UMyGameSubsystem*>& MySubsystems = GameInstance->GetSubsystemArray<MyGameSubsystem>();
 *
 */
虚幻引擎4（UE4）中的子系统(Subsystem)是生命周期受控的自动实例化类。

这些类提供了易用的扩展点，程序员可直接获得蓝图和Python公开，同时避免繁复的引擎类修改或覆盖。

// 老规矩, 新手教程看官方文档, 官方注释, 或者自行百度谷歌学习懒得讲
UE4 Subsystems 用一个比较通俗且易理解的说法, 它就像一个U类的组件.

目前有UEngineSubsystem, UEditorSubsystem , UGameInstanceSubsystem , ULocalPlayerSubsystem 几种类型, 可以挂载到对应的UEngine, UEditor, UGameInstance, ULocalPlayer上述几个类上面.

但和组件有些不同的地方是, 它比较NB :

UE4 Subsystems 会自动创建清理, 不需要人工维护...

什么意思呢??

就是只要你在C++代码中定义了Subsystem的子类, 那它就会自动创建一个对应的对象, 并且与对应类的生命周期挂钩, 自动初始化和清理.

什么意思呢?


举个例子, 只要UMyGameInstanceSubsystem这个UGameInstanceSubsystem子类存在.

UE4 就会上面对应位置, 自动调用类似上面代码的逻辑处理

并且会维护MyGameInstanceSubsystem的生命周期



好了, 废话不多说, 上源码

// 整篇文章如无特殊说明, 都是以UGameInstanceSubsystem为例
USubsytem



首先我们来看UGameInstanceSubsystem本类, 继承自USubsystem


并有一个帮助函数GetGameInstance


而USubsytem, 就是一个普通的UObject类, 定义了三个虚函数, 子类继承后自定义实现

综上所述, 可得 :

结论1 :
SubSystem本身没有任何特殊的地方, 就是一个普通的UObject

临时结论 :
同理, 阅读其他类型的Subsytem可以得出, 目前, 各个Subsystem除了Outer创建者不同, 有几个帮助函数外, 暂时没有任何区别.

不排除之后添加修改的可能

template FSubsystemCollection & BaseType



先看UGameInstance::SubsystemCollection这个属性

一个FSubsystemCollection<UGameInstanceSubsystem>


这个FSubsystemCollection<UGameInstanceSubsystem>模版类, 暂时只有两个帮助函数外, 也没有发现针对任何特定类型Subsytem的特殊实现

只是调用基类FSubsystemCollectionBase构造函数时, 传递了SubSystem的类型



如上图构造函数加定义, 最终设置了BaseType的值, 表明整个FSubsystemCollection是哪种Subsytem的集合



临时结论:
此处, 也可以看到, 目前, 各种类型Subsytem的管理类, 逻辑是一致的.

他们的区别, 暂时只有一个类不同.

临时结论2 :

综上所述, 因为没有针对的实现, 所以完全可以直接拿走USubsytem整套流程, 自己定义一个USubsystem类, 并使用

FSubsystemCollectionBase 初始化






接着, 我们来看FSubsystemCollectionBase的初始化函数Initialize

传入参数NewOuter, 每种类型的Subsytem都由对应的Outer来创建

所以断言Outer存在, 并保存起来.



然后, 就是if这个条件判断 : ensure(BaseType)

断言BaseType有值, 前文有描述, 这是一个类型值, 即SubsytemCollection有对应的类型.

此处是UGameInstanceSubsystem::StaticClass

如果没有对应类型, 那么整个集合也就没有意义了.

至于为什么是ensure, 而不是check?


FSubsystemCollectionBase的构造函数为空, 怀疑之后会有什么骚操作.





SubsytemMap是一个TMap, 从数据类型上看, 很容易理解, 每一个类对应一个对象.

这里断言数量为0, 错误提示, 当前集合不支持重新填充, 即现在, SubsystemCollection只能初始化一次

同上, 怀疑之后会有什么骚操作.





FSubsystemCollectionBase::SubsystemCollections是一个私有静态成员属性

这是一个数组, 存储所有的SubsystemCollection

在SubsystemCollection初始化之后, 就添加到SubsystemCollection数组中.

那么当数组等于0的时候, 也就是没有任何SubsystemCollection被初始化过

执行FSubsystemModuleWatcher::InitializeModuleWatcher

即进行SubsystemCollection整个系统相关的初始化操作, 这个稍后再看


接着根据流程, 上面是UDynamicSubsystem流程, 这个之后系统分析, 忽略


先通过GetDerivedClasses获得所有BastType的类

如果有了解UObject一些的, 会知道, 每个UObject对应的UClass在所在模块被加载的创建, 并创建对应的Default Object

即此处就获得此时加载的所有模块中, 所有BaseType对应类型Subsystem的UClass, 并遍历处理添加


然后调用获得DefaultObject, 调用USubsytem::ShouldCreateSubsystem函数来判断该类是否要被加载

如果加载, 那么创建, 并添加到SubsystemMap中, 然后调用其Initialize进行初始化

至此, USubsytem的初始化就算完成了

简单描述, 以UGameInstanceSubsytem为例, 就是获得UGameInstanceSubsytem的子类, 根据当前运行环境情况, 来创建需要的UGameInstanceSubsytem, 并调用对应的初始化函数

FSubsystemCollectionBase 清理

初始化完成之后, 就是清理了

在UGameInstance::Shutdown的时候调用FSubsystemCollectionBase::Deinitialize函数


遍历所有SubsystemMap, 逐个调用Deinitialize函数

但注意, 这里没有调用UObject的销毁函数

也就是说, 在这个时候, USubsytem还是存在着的, 指针指向空间仍然有效. 并没有在SubsystemCollection清理的时候直接销毁掉

而是进入UObject生命周期, 走UObject的GC流程

当该类被垃圾回收系统认为没有用的时候, 才会被真正销毁




FSubsystemCollection继承自FGCObject, 通过SubsystemMap表明对Subsytem对象的引用依赖

正常流程到这里, SubsystemMap清空, 一般其他地方也不会去存Subsystem的引用, 所以之后就正常销毁了.

啥, 不明白?

大白话就是 : Subsystem的生命周期由SubsystemCollection管理, SubsystemCollection负责创建, 初始化, 清理, 然后Subsystem的生命周期就完成了, 进入UObject的生命周期, 根据情况直到GC销毁.

UDynamicSubsystem

最后, 我们再来看一下UDynamicSubsystem这一特殊实现


暂时来说, 只有UEngineSubsystems和UEditorSubsystems 继承该类



从注释及文档等等得出, 这个DynamicSubsystem除了Subsystem的初始化, 还会监听模块加载卸载, 并在初始化和清理对应模块内包含的Subsystem

然后呢, 我们再反过头来, 看之前跳过的代码.


先是SubsystemCollection相关的初始化


可以看到, 是收集了所有已加载模块的UDynamicSubsystem, 并监听模块改变事件


该监听事件, 根据是加载还是卸载, 走不同逻辑


先看加载, 如图, 获得该模块所有的UClass并遍历, 如果符合条件, 那么调用

FSubsystemCollectionBase::AddAllInstances函数


遍历所有已经初始化过的SubsystemCollection, 如果是同一种类型, 添加到对应的SubsystemCollection中去




同时, 会维护一个TMap, 模块和模块内所有UDynamicSubsystem的子类UClass的TMap





模块卸载的时候, 清理所有该模块下的DynamicSubsystem, 逻辑简单, 不啰嗦了.



然后, 当没有任何SubsystemCollection, SubsystemCollection相关的清理呢?



嗯, 取消监听模块的绑定事件....





最后, 来看一下UDynamicSubsystem的初始化和清理流程.


FSubsystemCollectionBase::Initialize时, 遍历所有DynamicSystemModuleMap, 对所有已加载模块的UDynamicSubsystem进行初始化

FSubsystemCollectionBase::Deinitialize清理同普通USubsystem, 无特殊之处





到此, 几乎整个Subsystem相关的源码, 就扒了个底朝天了.

自己跳一下对应几个文件, 自己感受一下, 整理一下.

问 : 试着描述一下USubsytem.

答 : USubsytem(UObject)类会被该类对应的对象自动创建一个对象, 并被自动初始化和清理函数、维护其生命周期, 仅需要继承扩展三个虚函数使用即可



问 : USubsytem和UActorComponent 两者对比的异同

同 :

都是面向组合编程
都可以将其所在的对象功能剥离出来, 进行通用化或解耦
异 :

USubsytem由引擎内部机制维护, 而UActorComponent需要人工管理
UActorComponent功能十分强大, 本身设计很复杂. 而USubsytem很简单...
UActorComponent可以在一个AActor内挂载多个相同类型的组件, 但USubsytem每种类型只能挂载一个
UActorComponent可能会和同一Actor下其他UActorComponent之间有关联, 而多个USubsytem彼此会相当的独立




问 : USubsytem支持蓝图创建子类吗?

问 : USubsytem只支持C++编写吗?

答 :

从实现上看很多地方, 例如查找所有UClass, 例如通过寻找模块代码Package下所有类

这些C++可以直接使用的功能, 蓝图支持会很麻烦.

估计短时间内不会

即, USubsystem大概率, 只支持C++编写, 蓝图使用

(欢迎官方打脸)...





问 : USubsytem有什么用?

答 : 换个位置放代码(手动狗头)

将一些放在UGameInstance的功能解耦, 放到一个集中的类USubsytem中, 并通过UE4本身的机制自动加载和维护.

如果合理使用, 对于功能解耦, 插件扩展会很有帮助.





问 : USubsytem可以被多次继承吗? 多次继承会发生什么样的情况?

即有UMyGameInstanceSubsystem及其资料UMyGameInstanceSubsystemA, UMyGameInstanceSubsystem_B

答 : 可以

只要该类可以被当作UObject正常创建(没有Abstract标记等等)且ShouldCreateSubsystem值为真, 就会被创建, 不论继承树如何

此处, 上面三个类都会被正常创建和使用





问 : USubsytem和UDynamicSubsystem有什么区别?

答 : UDynamicSubsystem还会监听模块改变, 进行动态的Subsystem初始化和清理





问 : 为什么只有UEngineSubsystem和UEditorSubsystem是UDynamicSubsystem?

答 :

不知道

盲猜一下

因为UEngine和UEditor开关插件的时候, 这样实现, 可能一些插件就不需要重启UE4使用了.

UEngine和UEditor初始化太早, 那个时候还没有加载什么模块, 可能很多的Subsystem不能被正常创建

...

..

.

问官方去吧...







问 : 有什么USubsytem的骚操作吗?

答 :


// 随手写的, 没有测试.
在USubsystem::ShouldCreateSubsystem中判断有没有子类

没有则创建本类
有则忽略
然后再子类的USubsystem::ShouldCreateSubsystem中再次判断, 直到没有子类的时候, 直接创建该类
也就保证了, 同一继承树下, 只有没有子类的USubsytem才被创建

有啥用呢?

假设插件里定义了一个USubsystem, 但我需要对它进行扩展, 我在项目层又创建了一个它的子类

这个时候会创建两个USubsystem对象, 可能会冲突.

所以, 需要修改插件里面的USubsystem, 就破坏了他的封装性.

但这样写, 就完美避开了, 且影响, 嗯, 性能消耗, 忽略



问 : 扯了这么半天, USubsystem真的有用吗?

答 :

小项目几乎没用, 中等项目不会, 大项目可能会.

如果同时进行多个项目, 肯定会.



该功能主要目的在解耦, 方便功能的扩展和复用, 且估计主要应用地方在插件?? 而不是项目本身.

所以, 怎么说呢?

食之无味, 弃之可惜 --- 鸡肋.



// 那你费这么大功夫, 在啰嗦什么.
// ...
// 它设计的秒啊
</code></pre>
</details>

<details>
<summary>UE4 网络相关系列 导言</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/104300441
前言
鸽子了好久了, 好像, 大概, 找不到借口继续鸽子了, 毕竟, 嗯...
全文偏理论, 是篇引子, 后续会具体详细展开, 并不断修改完善本文, 关联过去.
孤傲雕：UE4 网络相关系列 序
这是一篇关于UE4 网络相关的引子.

或者说一篇UE4 游戏网络同步相关的引子.

毕竟, 游戏的网络同步要复杂很多, 也接触最广泛.

网络通信原理 - 大庚年 - 博客园
网络通信原理 - 感动#心 - 博客园
经济基础决定上层建筑, 要了解网络, 也绝对要从网络通信原理开始.

而UE4是一款强大的引擎, 自然会封装完善这些基础功能.

Socket
UE4 Sockets多线程TCP通信



对应UE4 Socket及相关内容, 属于网络通信中最基础的地方, 根据平台不同, 有不同的实现.

如果只是单纯使用UE4 的网络同步机制, 那如无特殊需求, 一般不必接触.

如果要连接自己的服务器, 例如一个聊天服务器, 就从Socket这里入手了.

HTTP



如果想和后台进行关联, 使用WEB服务是一个不错的选择.

配合Json这一数据交换格式, 实现登录系统, 日志系统啊, 也十分容易.

而在支持网络通信之后, 剩下的, 其实就是, 嗯, 那个叫, 千奇百怪了

DonaldW：网络游戏同步技术概述
网络游戏同步技术概述
实时对战网络游戏--基于帧同步的最佳实践 - GameRes游资网
聊聊网络游戏同步那点事 - 陈嘉栋 - 博客园

lockstep 网络游戏同步方案
帧同步在竞技类网络游戏中的应用 - komo - 博客园
再谈网游同步技术：实时动作游戏同步方式和传输协议选择 - GameRes游资网
影子跟随算法：FPS游戏中游戏同步性的实现 - GameRes游资网
《王者荣耀》技术总监复盘回炉历程：没跨过这三座大山，就是另一款MOBA霸占市场了
等等, 有兴趣的可以百度谷歌一下下面关键词, 有趣有价值的文章很多, 非常多.

网络游戏同步
帧同步
状态同步
角色位置同步
游戏网络防作弊
为了解决特定的网络问题, 相对应的解决方案也十分巧妙, 虽然大白话看起来也很简单(笑).

Networking Overview

UE4框架在构建时考虑到了多人游戏。只要您遵循基本的框架约定，通常不需要做太多的工作即可将单人游戏体验扩展到多人游戏。

UE4网络围绕服务器/客户端模型构建。这意味着，网络中将有一个权威性的服务器（负责做出所有重要决策），然后该服务器将确保所有连接的客户端持续更新，从而使它们保持最新、最近似于服务器的场景。即使是没有联网，单人游戏也有其服务器；在这些情况下，本地计算机将充当服务器。
上面是UE4 官方文档中对UE4 网络的概述.

然后我们来抠抠字眼(从一些角度), 分析分析 :

字眼一 : 单人游戏扩展到多人游戏
如果有做过游戏或者类似网络同步机制的话, 应该对以下这种情况并不陌生, 或者习以为常 :

游戏客户端和游戏服务器是完全独立开发的, 两者之间的通讯只依赖于一些预定义好的接口.

甚至经常, 客户端和服务器都不是一种语言, 逻辑要用两种语言分别写两遍.

以一个3D回合制游戏为例 :

客户端, 即玩家视角, 是多个3D角色释放各种炫酷的技能, 打来打去
服务器只需要几个数据, 玩家怪物名称, 玩家怪物属性, 玩家怪物索引等等来回计算.
模型? 动画? 音效? 特效? 毫不关心
这样做有优点也有缺点, 粗略描述一下(瞎扯, 本人没做过)

优 : 定制的永远比通用的强, 可以自定义实现, 自定义功能, 怎么顺手怎么方便怎么来, 尽最大程度压榨性能的极限.
缺 : 不够统一化, 服务器和客户端两套逻辑, 维护麻烦, 加大沟通成本, 加大工作量
缺 : 不够通用化, 整套游戏的客户端服务器通讯架构实现和游戏逻辑紧密耦合, 无法形成有效积累
...
ComblockEngine 引擎首页 // 举个例子
而UE4呢, 它可以将单人游戏扩展到多人游戏.

而如果有用过UE4的网络同步相关机制的话, 有一定了解, 那我们就基本可以换个说法来描述 :

UE4客户端代码和服务器代码是写在一起的!

所以对单人游戏的逻辑进行一定的处理, 将其网络化, 就变成了多人游戏(手头狗头).

也可以说, UE4 的网络同步机制, 是将客户端代码和服务器代码写在一起, 在使客户端和服务器同时跑相同逻辑, 但做不同的实现.

举个例子 : 开枪事件
经过网络同步后, 各端都有开枪这一逻辑事件

客户端实现有枪的动画, 声音, 特效
服务器的实现则是生成子弹, 计算子弹伤害等等.
因此, 重点来了 : 客户端与服务器端跑相同逻辑, 但做不同实现.

综上所述呢, 单纯从这一个角度来看, 如果使用UE4这套网络同步机制 :

UE4 对于FPS射击游戏, ACT动作游戏, RPG角色扮演游戏等很友好, 他们客户端和服务器可以直接跑相同逻辑, 并顺带的在服务器做一些防作弊检测.
UE4 对于回合制游戏, 额, 及一些游戏不友好, 如果让服务器和客户端跑相同逻辑, 服务器会有很多不必要的处理, 或者需要费很大力气优化掉, 或者就留着增加很多不必要的开销.
// 记得也是当初看一篇文章扯得分析, UE4 服务器客户端写到一起的优缺点, 忘了出处了.
那如果不使用这一套机制呢?

随你喽, 自己开发完善一套服务器, 怎么顺手怎么来.

字眼二 : 服务器/客户端模型
嗯, 服务器和客户端.

// 待完善 为什么采用服务器客户端模型

那就会有一套客户端和服务器连接的完整流程吧(待完善)

有了服务器, 服务连接多个客户端, 多端的数据状态要保证一致, 那就有需要有一个权威端, 不然各端数据不一致, 谁也不认, 就没什么意思了.

而权威端, 理所应当的就是服务器了.

既然服务器是权威端, 那客户端就只能不断的试图去获取服务器的最新状态并展示, 并试图去影响服务器.

不断的去模仿, 模仿, 模仿, 若不甘心去模仿, 妄想去改变, 也只是在服务器允许并修改后的自欺欺人的"自主表演"一样.

UE4 提供了Remote Procedure Calls (RPCs), 使客户端和服务器直接进行交互
UE4 也提供了属性同步, Actor同步, 用于客户端获取服务器当前的状态, 并根据时机逻辑不同, 可以对其定制化处理, 十分便捷.
在此功能背后, 自然是一套强大的网络同步机制, 并由于网络环境的复杂, 提供了各种各样的特性.

字眼三 : 单人游戏也有其服务器

这一点为什么要强调呢?

如果, 你做的就是一个单机游戏.

那你大可以直接忽略.

如果, 你做的是一个网络游戏.

那就耐心的听我瞎扯一下, 瞎分析一下 :



上文中有提到, UE4 客户端逻辑是和服务逻辑写在一块的, 对其进行一定的网络化处理, 大概就是UE4 的网络同步机制

也就是说, 会有客户端逻辑, 服务器逻辑两种逻辑, 也就存在这两种可能性 :

只跑服务器逻辑的专用服务器模式(NM_DedicatedServer)
只跑客户端逻辑的客户端模式(NM_Client)
我们来思考一下, 如果只有这样, 好像也没有什么毛病, 逻辑分明, 简单干脆.

那, 有没有一种情况, 他既跑服务器, 又跑客户端呢?

想一想, UE引擎起家于FPS游戏, 而FPS的局域网联机

嗯, 就是有一台主机, 既是客户端, 又是服务器, 作为房主, 其他玩家连接到这台主机上进行游戏.

嗯, 所以我们还需要一种 :

既跑客户端逻辑又跑服务器逻辑的监听服务器模式(NM_ListenServer)
以及, 和这些需要网络的做区分, 没有任何网络的单机模式

没有任何网络的单机模式(NM_Standalone) // 脱机模式
嗯, 没毛病.

那, 如果我在单机模式下写网络代码会是怎么样呢? 单机模式是只跑客户端逻辑? 还是只跑服务器逻辑? (笑)

还是说, 单机模式下不能写网络代码? 只有单机逻辑?

这问题, 废话, 单机模式只有单机逻辑呗, 写什么网络.

那么, 单人游戏为什么也有其服务器呢?

/** Standalone: a game without networking, with one or more local players. Still considered a server because it has all server functionality. */
NM_Standalone,
Still considered a server because it has all server functionality.

因为他有完整的服务器功能, 所以, 他被当做服务器(笑)

那再瞎扯一下, 完整的服务器功能?

他是单机游戏, 不会有其他客户端连接, 所有他不需要监听网络端口.

他是单机游戏, 没有其他客户端获取服务器的状态, 所以他也不需要属性同步.

好像, 这个完整服务器功能指的是RPC可以正常使用?

那RPC功能, 背后不就是函数在哪里调用? 在Server调用, 在Client调用, 好像顺便支持了, 也没什么难度(手动狗头)

等等, 还记得NM_ListenServer吗?

他去掉网络端口监听, 嗯 , 不和现在这个需求一模一样了吗?

那NM_Standalone实际没有任何特殊的处理了啊.

即 :

只是服务器 NM_DedicatedServer
既是服务器又是客户端, 有其他客户端连接 NM_ListenServer
既是服务器又是客户端, 没有其他客户端连接 NM_Standalone
只是客户端 NM_Client
我去, 好像, 这样分类就可以了, 设计上, 都按照支持网络的来写就可以了.
</code></pre>
</details>

<details>
<summary>UE4 网络相关之 网络模式(ENetMode)相关讲解</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/105754383
前言
UE4版本4.24
下文引用多数出于此处
Networking Overview | Unreal Engine Documentation
网络模式(ENetMode).

嗯, 知道我在说什么吗?


开一个NM_Standalone 模式窗口.


开一个NM_ListenServer窗口和一个NM_Client窗口


开一个NM_DedicatedServer窗口和一个NM_Client窗口

再问个问题(留个作业)


这样开, 是两个什么样的端口(手动狗头)

NM_Standalone
此类型说明服务器在本地计算机上运行且不接受来自远程计算机的客户端。此类型最适合单人游戏或本地多人游戏。
孤傲雕：UE4 网络相关系列 导言
参考前文, 字眼三 : 单人游戏也有其服务器, 此处再多加啰嗦

从网络模式讲, 他就是一个特殊的没有任何客户端连接的NM_ListenServer

NM_DedicatedServer
专属服务器没有本地玩家，可以通过丢弃声音、图形、用户输入和其他面向玩家的功能来更高效地运行。此类型服务器用于托管在受信任服务器上的多人游戏，如竞赛性MOBA游戏、MMO游戏或需要高性能可靠服务器的在线射击游戏。
DedicatedServer专用服务器, 一般和ListenServer监听服务器做区分.

这个程序, 仅被当做服务器使用, 运行之后是一个后台进程, 也可以展示服务器日志, 显示一个命令行窗口.

它不需要客户端展示性的功能(比如说画面啦, 声音啦), 也不需要接收如何用户按键事件, 它只通过网络通讯和客户端进行对应的交互.

因此, 服务器是不会有本地玩家的, 他不会有自己的ULocalPlayer, APlayerController,APlayerCameraManager等一些客户端专有的类, 会抛弃掉一些客户端独有的逻辑

服务器为了优化, 尽快能的提升性能, 也不需要很多客户端的功能, 比如文档描述的 :

声音

举个引擎内部的处理, UGameplayStatics::PlaySoundAtLocation
如果UWorld的NetMode是NM_DedicatedServer, 直接返回, 不做任何处理

图形 (嗯, 服务器渲染给谁看(手动狗头)
用户输入和其他面向玩家的功能
在丢弃了这么多功能之后, 服务器的性能开销就小了很多.

同时, 这些功能的丢失, 部分在客户端正常的逻辑, 在专用服务器上会逻辑异常

常见的有 : 指针为空, 逻辑不执行

// 举个例子 : UTextRenderComponent在专用服务器经常为空
// 没有深扒过原因


综上所述, DedicatedServer这一种网络模式是比较特别的, 它仅作为服务器使用, 会丢弃掉一些客户端的逻辑处理, 展示等功能.

在编写对应逻辑的时候, 也应该考虑到这一点, 粒子, UI等内容就不必再专用服务器上面运行了.

NM_ListenServer
监听服务器是一个既托管本地玩家，同时也对来自远程玩家的连接开放的服务器。此类型服务器适合于不需要专属服务器，且用户可以在没有第三方服务器的情况下设置和玩自己的游戏的竞争或合作类游戏。由于主机没有网络延迟，此类型网络模式可能会给主机带来一些优势，并且可以在没有主机警告的情况下终止游戏。
孤傲雕：UE4 网络相关系列 导言

参考前文部分内容, 字眼三 : 单人游戏也有其服务器, 此处再多加啰嗦

这里也不多加描述了, ListenServer它既跑服务器, 又跑客户端, 常见的就是局域网联机.

NM_Client
这是唯一为非服务器的模式。在此模式下，本地计算机是专属或监听服务器的客户端，因此不会运行服务器端逻辑。
嗯, 这个是最简单的模式

它就是一个客户端, 只跑客户端逻辑.

嗯, 就这.



然后, 我们来做一道思考题 :

单个程序在整个运行周期内, ENetMode变化常见情况有哪些?

ENetMode在程序过程中, 会发生变化吗?

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

局域网联机的FPS游戏
以NM_Standalone启动, 创建或加入房间
如果是房主创建房间, 则变为NM_ListenServer
如果是加入房间, 则变为NM_Client
广域网MMO等游戏
服务器以NM_DedicatedServer启动, 并只会是该模式
客户端以NM_Standalone启动, 连接服务器后变为NM_Client
命令行传递参数启动程序
客户端启动参数添加服务器地址, 直接连接, 以NM_Client启动
客户端启动参数中地图开启?Listen, 以NM_ListenServer启动
客户端启动参数中添加-Server, 以NM_DedicatedServer启动
.....
网络模式(ENetMode)在程序运行期间可以发生变化.

那再细想一下? 什么时候发生了变化?

局域网联机的FPS游戏创建或加入房间, 在切换关卡(ULevel).

客户端连接服务器, 在切换关卡.

服务器启动时, 在打开关卡.

因此 : 网络模式(ENetMode)是跟随关卡变化的.

同一关卡内, 各程序, 根据自己实际情况, 有对应的网络模式



那不同关卡呢?

网络模式就毫无关联了呗.

其他机制呢?

网络模式都没有关联了, 其他也自然而然没有了呗.

因此 : UE4的网络机制, 是所有程序在同一个关卡内, 才能使用的.

即RPC机制和属性同步机制, 必须在同一个关卡内, 才能使用.

不太明白?

举个例子, 还是局域网FPS游戏为例 :

A玩家创建了一个房间, 打开House关卡
B玩家加入了这个房间, 进入House关卡
A玩家开始游戏, A和B玩家进入Game关卡
C玩家想加入房间, 进行游戏, 此时没有House关卡, C玩家只能直连进入Game关卡
而无论是B玩家, 还是C玩家, 在进入House或Game关卡前, 他是得不到关卡里面的信息的

即无论是RPC还是属性同步, 此时B玩家获取不到House关卡信息, C玩家获取不到Game关卡信息

只有通过open服务器地址, 进入对应的关卡, 然后才能正常使用RPC和属性同步, 获得房间实际信息

那不对啊?

常见的游戏中, 玩家B, C进入游戏或房间前, 都可以知道房间信息的啊.

这就是另外一套机制, UE4里面叫Online Session.

这套机制将记录房间信息, 并提供查找房间, 加入房间, 获取房间信息等等一系列房间管理功能.

Multiplayer Shootout Online Session Nodes

当然, 这套机制也可以丢弃掉, 自己实现.

// 如无意外, 这套机制不会详细展开描述
// 无论是目前工作的实际使用情况(丢弃Session机制, 自己实现)
// 还是目前对Session的已知了解, 要实现一套Session的接口进行扩展(挺麻烦的, 文档较少乱)
// 个人感觉自定义实现更可靠.

</code></pre>
</details>

<details>
<summary>UE4 网络相关之 网络模式(ENetMode)的获取</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/138084687
前言
UE4版本4.24
孤傲雕：UE4 网络相关系列 导言
孤傲雕：UE4 网络相关之 网络模式(ENetMode)相关讲解

ENetMode有以下几种类型



只是服务器 NM_DedicatedServer
既是服务器又是客户端, 有其他客户端连接 NM_ListenServer
既是服务器又是客户端, 没有其他客户端连接 NM_Standalone
只是客户端 NM_Client
前文阐述了ENetMode具体的区别, 并得出 : 在程序运行过程中ENetMode会随ULevel关卡的变化, 而变化.

本文则是继续深扒, ENetMode在运行中, 是怎么获得当前值的:

UWorld::GetNetMode


看逻辑, 先判断是不是专用服务器, 是则直接返回NM_DedicatedServer


FPlatformProperties不同平台有不同的实现, 但基本逻辑相同, 不深究

如果IsServerOnly, 仅是服务器, 那直接返回true, 是NM_DedicatedServer

如果IsGameOnly, 仅是游戏, 那就返回false




然后我们以Windows代码为例.

IsGameOnly返回的是一个宏UE_GAME

IsServerOnly返回的是IS_DEDICATED_SERVER, 实际上是宏UE_SERVER



这两个宏是在编译时确定对应值的, 具体条件没完整试过

WindowsServer 是 UE_SERVER 为1, 仅用作专用服务器

而Editor编辑器模式下, 则是判断命令行参数(通常可以看做程序的启动命令行参数)是否有SERVER或RUN=SERVER.

综上所诉, 正常情况下, 是不是专用服务器在程序运行开始的那一刻, 就固定了

他的网络模式, 也就是NM_DedicatedServer, 不会发生改变.

// 前面文章也说过, UE4会对专用服务器进行一定的优化, 丢弃掉不必要的资源
// 此处对应的证明, 在打服务器包体的时候, 编译期标记该包体仅用作服务器
// 然后就可以进行一系列的编译预处理优化, 走不同逻辑, 打包不同的资源等等




转过头来, 我们再看其他情况, 如果不是专用服务器, 则再通过UWorld::InternalGetNetMode函数获得当前的ENetMode


我们先把这个IsRunningClientOnly解决掉

基本同上, 判断是宏WITH_SERVER_CODE.

如果仅是客户端, 则不需要任何服务器代码, 如果和服务器或其他程序进行连接, 客户端的网络模式, 也只能是NM_Client了


再参考NetDriver的注释, 此处逻辑也就可以表示成 : 如果客户端和服务器之间已经有网络连接, 则从这个网络连接UNetDriver中获得对应的网络模式




UNetDriver::GetNetMode里面实现也很简单

判断有没有ServerConnection, 客户端向服务器的连接, 客户端有值, 服务器无值

有, 则是客户端, 否则是服务器

/* Whether engine was launched as a client */
bool GIsClient;

如果是服务器, 再次判断, 服务器有没有同时跑一个客户端, 通过GIsClient这一全局值来判断.


该值在程序运行的时候设置, 嗯, 具体什么情况取什么值就不细分析了

简单判断 : 有画面渲染的, GIsClient是true.

是客户端, 则是NM_ListenServer, 否则是NM_DedicatedServer


如果NetDriver不存在呢? 即没有建立服务器和客户端之间的连接

则是判断DemoNetDriver是否存在, 存在通过他获取




如果NetDriver和DemoNetDriver都不存在呢?

那只能通过URL中获取, 如果有参数listen, 认为是NM_ListenServer, 否则是NM_Client

URL对应的是程序打开的完整地图路径, 例 : MapTest?listen

至此, 整个UWorld获得网络模式ENetMode的函数, 就分析完了.

先判断, 是不是专用服务器
是 : 直接返回
否 : 判断NetDriver是否存在, 即客户端服务器之间已有连接
是 : 根据NetDriver连接返回网络模式
否 : 判断DemoNetDriver是否存在
是 : 根据DemoNetDriver返回网络模式
否 : 尝试从打开地图时的地图参数, 获取当前的网络模式.
AAcotr::GetNetMode




AActor这里又多了一个NetDriverName, 但基本逻辑类似

NetDriverName之后再细说了
</code></pre>
</details>

<details>
<summary>UE4 网络相关之网络驱动器(UNetDriver)的顺藤摸瓜</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/141574986
前言
UE4版本4.25
孤傲雕：UE4 网络相关之 网络模式(ENetMode)的获取


接前文

通过深扒ENetMode的获取, 发现和UWorld::NetDriver这个属性有很大关联

不出意外, 这个属性将会在UE4整套网络体系中, 发挥着重大作用.

那, 顺藤摸瓜, 扒一下该对象的创建, 那客户端服务端之间网络的确立, 创建, 连接就清楚了呗!

兴许, 还能摸到一个大西瓜! (手动狗头)

// 本文可能没多少干货
// 主体内容就是沿着UWorld::NetDriver, 不断深扒, 引出其他东西, 方便后文直接具体分析
UNetDriver是个对象, 储存在UWorld中.

是个变量, 就需要被赋值, 在一个合适的时间点被赋值.

那找找UWorld::NetDriver的全局引用, 看看在那里被赋值的.(如下图)


好像很多, 长长的进度条.

等等, 我们只是找找这个变量在那里被赋值的.

也就是找他在=号左边的赋值语句, 忽略掉其他情况.

再细细排除一下, 剩下的也就不多了


UWorld::SetNetDriver, 有一个专门的Set函数, 之后需要重点排查.


UWorld::Listen, 一个函数内有赋值操作


UWorld::SetActiveLevelCollection, 又一个函数内有赋值操作




再继续接着查UWorld::SetNetDriver的全局引用



忽略掉一些无效, 与本文关联不大的地方.

有效的就只有UEngine::MovePendingLevel这个函数了.

综上所述, 就找到了三个函数, 对NetDriver进行赋值 :

UWorld::Listen
UEngine::MovePendingLevel
UWorld::SetActiveLevelCollection
再一步步深扒

UWorld::Listen


先看UWorld::Listen函数

很明显, UWorld::Listen这是一个创建UNetDrive的地方, 在继续顺藤摸瓜


排除掉不相关内容, 剩下两处地方 :

UGameInstance::StartPlayInEditorGameInstance
UEngine::LoadMap



UGameInstance::StartPlayInEditorGameInstance中UWorld::Listen的调用

判断当前是不是编辑器下PIE_ListenServer模式, 是则使用对应的URL启动监听服务器(ListenServer)

监听服务器嗯, 所以此处的ENetDriver是服务器端的.

// 一些PIE相关的, 只在编辑器内运行存在的函数, 深扒意义是不太大的
// 他们很多有一些针对编辑器的优化, 和实际打包后运行, 有很大差距





UEngine::LoadMap中UWorld::Listen的调用, 该函数如字面意思加载地图.

看到红圈内容没有?

Listen参数? 是不是很熟悉?

写过UE4 联网项目的是不是都有印象?

服务器地图要在地图后面加参数Listen, 用于表明它是一个服务器, 可以接受其他客户端连接.

而专用服务器又不用加这个参数后缀



在看代码实现, Pending是传入参数UPendingNetGame, 当这个Pending不存在则判断是否满足以下情况

地图参数中有Listen
程序本身是服务器, 不是客户端
有则调用UWorld::Listen, 创建服务器端的UNetDriver, 再结合前文, 此时网络模式变成NM_DedicatedServer或NM_ListenServer, 成为为专用服务器或者监听服务器.

UEngine::MovePendingLevel
先查一下UEngine::MovePendingLevel该函数在哪里被调用


UEngine::LoadMap, 眼熟? 和上面服务器创建UNetDriver的是同一个函数



如果传入参数UPendingNetGame存在, 则调用UEngine::MovePendingLevel

调用UEngine::MovePendingLevel函数前有个断言检测,

所以, 此处也就是将UEngine::LoadMap传入参数UPendingNetGame的NetDriver设置给UWorld


那看看UPendingNetGame的NetDriver

注释字面翻译, 连接新服务器时创建的网络驱动器, 连接成功后传递给World

连接服务器, 那UPendingNetGame这个NetDriver就是客户端的网络驱动器了.


同理, 再查下该属性在哪里被赋值的, 查到唯一地方UPendingNetGame::InitNetDriver


再查UPendingNetGame::InitNetDriver在哪里被调用, 发现都在UEngine::Browse中, 有两处调用



第一处(可忽略)


第一处在这个else if大括号内, 从注释及相关内容看像是当连接失败或连接关闭等的处理


其中当是EWorldType::GameRPC这种类型的时候, 尝试重新连接, 不是则走默认情况, 加载默认地图

从使用情况语境上课上看, 此处, UPendingNetGame就是用来重新连接服务器的, 即用于客户端连接服务器.





第二处


第二处这里就很明显了, 地图参数转换成FURL后, 当URL不是本地的且当前程序是客户端的时候, 创建UPendingNetGame连接服务器



UWorld::SetActiveLevelCollection

最后再来看一下UWorld::SetActiveLevelCollection



嗯, 扫扫注释, 和切关流程没啥关系.

忽略
</code></pre>
</details>

<details>
<summary>UE4 网络相关之网络版本获取与比对</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/158986763
前言
UE4版本4.25
没啥大东西, 就是一个版本号比对

UWorld::NotifyControlMessage函数中, 当服务器收到客户端的NMT_Hello消息的时候

会进行一次版本号比较, 如果版本号不同, 则会将发送NMT_Upgrade(服务器告诉客户端其版本不兼容)消息,告知客户端版本不一致, 并关闭连接



再看一下客户端发送时网络版本号的取值, 都是通过FNetworkVersion::GetLocalNetworkVersion这个函数获取的.

而比较则是FNetworkVersion::IsNetworkCompatible函数

嗯, 接下来就是对这两个函数相关联的东西进行深扒了

FNetworkVersion::GetLocalNetworkVersion

生成一个版本号，默认情况下，该版本号基于引擎版本, 项目名称, 项目版本


这个函数可以通过绑定FNetworkVersion::GetLocalNetworkVersionOverride委托, 自定义处理.


代码主体逻辑十分简单, 对生成的uint32版本号做一个缓存, 有缓存直接返回, 不再重复计算.

如果有绑定代理, 且调用传参AllowOverrideDelegate是true, 返回自定义实现, 否则都走默认逻辑.

AllowOverrideDelegate这个用途, 注释也有说明, 就是自定义实现的时候, 可以传false调用引擎的默认实现, 在自己进一步处理.

而引擎相关调用该函数时, 都传递参数true, 保证调用自定义实现.

// 实现很巧妙, 但疑似只是单纯的在炫技
// 有兴趣可以深入思考一下 : 
// 如果引擎调用自定义实现, 自定义实现又调用默认实现CachedNetworkCheckNum会有什么变化
自定义的网络版本号, 就见仁见智, 不啰嗦了.

这里重点看一下引擎的默认实现

这是一个项目, 引擎最后生成的版本号字符串, 当做参考

GUAO_CPlusPlusCode25 1.0.0, NetCL: 13144385, EngineNetVer: 14, GameNetVer: 0
然后我们根据FString::Printf格式[%s %s, NetCL: %d, EngineNetVer: %d, GameNetVer: %d], 一个一个对应的看



第一个, 项目名称, 没什么好说的.






第二个, 项目版本号, 在UEngine::Init中有设置, 就是项目的版本号, 写法疑似在炫技(手动狗头)


第三个, 引擎兼容版本号, 这个...


默认是ENGINE_NET_VERSION引擎的网络兼容版本

然后在第一次调用的时候, 取命令行参数networkversionoverride的值来覆盖

之后再次判断, 如果值为0, 则判断ENGINE_NET_VERSION是否也为0


如果ENGINE_NET_VERSION也为0, 则取BuildSettings::GetCompatibleChangelist的返回值

然并卵, 没用过




第四个, 引擎的网络版本, 嗯, 参考这个枚举, 引擎网络也改了好多版本了...


最后一个, 游戏的网络协议版本, 上面截图中有, 是个0

最后就拼成了这样的版本号 : GUAO_CPlusPlusCode25 1.0.0, NetCL: 13144385, EngineNetVer: 14, GameNetVer: 0

然后FCrc::StrCrc32进行字符串CRC校验, 减少版本号位数, 方便比对, 和减少网络传输消耗

FNetworkVersion::IsNetworkCompatible



FNetworkVersion::FIsNetworkCompatibleOverride同样有一个委托, 可以自定义实现.

那么, 了解这么多网络版本号相关的东西可以干什么呢?

老话说的好 : 书到用时方恨少, 多读总比不读好.(手动狗头)



在联网游戏中, 如果客户端版本和服务器版本, 允许存在一定的差异, 可以兼容运行, 则可以在这一套的基础的进行自定义扩展.

// 虽然, 盲猜, 通过其他非UE4方式做, 更可控, 更通用, 更好.
</code></pre>
</details>

<details>
<summary>UE4 网络相关之网络连接的建立UPendingNetGame</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/143104152
前言
UE4版本4.25
孤傲雕：UE4 网络相关之网络驱动器(UNetDriver)的顺藤摸瓜

接前文, 在扒了一大堆代码之后, 对网络连接最开始的地方, 有了一定的了解.

服务器什么时候创建UNetDriver开始监听端口, 支持客户端连接.
客户端什么时候创建UPendingNetGame开始连接服务器.

下一步, 自然是进一步深扒, 客户端是如何和服务器建立连接, 直到两边可以发送RPC事件和进行属性同步为止.

客户端开始向服务器进行请求, 尝试创建连接, 主要处理在UPendingNetGame类中


创建UPendingNetGame, 通过NewObject创建对应对象, 构造函数无处理, 略

2. 调用UPendingNetGame::Initialize初始化函数, 传入FURL信息

这个信息包含了服务器地址、端口、地图信息、连接参数等内容.


3. 调用UPendingNetGame::InitNetDriver, 开始初始化网络驱动



先看上图这个全局变量GDisallowNetworkTravel, 如果为true, 则禁止任何网络连接切换, 在处理切换关卡时拒绝这一请求.

此处客户端与服务器的连接处理与该值对应, 如果不处理, 直接连接错误, 记录日志


然后, 扫一眼, 明显分为创建UNetDriver网络驱动和初始化两部分


创建初始化UNetDriver相关, 此处不做扩展, 见其他文章


如图广播FNetDelegates::OnPendingNetGameConnectionCreated



如果NetDriver中的ServerConnection的PacketHander存在, 会先调用PacketHandler的BeginHandshaking建立连接, 完成后调用SendInitialJoin.

不存在, 则直接创建.

在做了这么多准备工作(见其他文章)后.

这个时候, 和服务器一个沟通的渠道就建立完成了, 接下来就开始和服务器友好的"沟通"一下.

第一回合 NMT_Hello

客户端先向服务器友好礼貌打一声招呼!

Hello!


服务器收到这一NMT_Hello消息

从UWorld::Tick函数的多播转交到UNetDriver

从UNetDriver再转交给与客户端对应的UNetConnection, 并进一步处理

最后, 又反手丢回给UWorld::NotifyControlMessage


ServerConnection, 和服务器的连接, 存在自然就是客户端.

嗯, 那if里面是客户端逻辑, else里面就是服务器逻辑.


废话不多说, 否管哪来的, 先检查!


不合格? 简单, GoodBye! 走你!


嗯, 检测合格了,.?

好孩子, 来, 再让我看看, 有没有先和我问个好, 打个招呼.

好, 看起来像个样子.


孤傲雕：UE4 网络相关之网络版本获取与比对
但我们这可不是什么随随便便的地方, 打招呼的礼仪对不对? 是现在最流行的, 最高贵最优雅的那一种吗?

不是???

???

...

滚回去学, 学完了再说...


然后客户端就收到了服务器的NMT_Upgrade消息

从UEngine::TickWorldTravel转发到UPendingNetGame::Tick再

从UEngine::TickWorldTravel函数的转交到UPendingNetGame::Tick

从UPendingNetGame再转交给对应的UNetConnection, 并进一步处理

最后, 又反手丢回给UPendingNetGame::NotifyControlMessage


然后, 客户端就多播UEngine::BroadcastNetworkFailure, 类型为ENetworkFailure::OutdatedClient, 并记录对应错误日志

然后苦兮兮的更新版本去了.

第二回合 NMT_Hello
客户端好好的学了学最新的礼仪(更新到最新的客户端版本), 再一次向服务器友好礼貌打一声招呼!

Hello!


服务器再次看到了客户端.

嗯, 这次礼仪对了, 口令!

没有口令? ...

嗯, 对就是没有口令!

// 如果有口令, 会对口令进行验证, 并考虑是否传输进行加密, 见其他文章


通过FPlatformTime::Cycles获得一个数字, 取WinAPI QueryPerformanceCounter得到高精度计时器的值64位, 取其低32位

// server sends client challenge string to verify integrity
DEFINE_CONTROL_CHANNEL_MESSAGE(Challenge, 3, FString);
当网络状态有效, 就向客户端发送NMT_Challenge信息


同时调用SetExpectedClientLoginMsgType, 参数NMT_Login, 招呼打完了, 该干正事了 : 登录.

第三回合 NMT_Login
客户端又收到了服务器的NMT_Challenge消息

兜兜转转又回到了UPendingNetGame::NotifyControlMessage处理



然后PartialURL数据, Host清空, Port取默认值

嗯, 与服务器连接已经建立了, 这两个值没用处了


然后如图


当ULocalPlayer::GetNickname有值时候, 添加一个Name参数


当ULocalPlayer::GetGameLoginOptions有值时, 添加对应参数

然后设置UConnection的PlayerID, 通过ULocalPlayer::GetPreferredUniqueNetId获得

例如 : L"DESKTOP-10Q6V1I-FCDB05414DB72C66F61B6E80E315FEA9"


然后获得OnlinePlatformName, 平台名称



通过UGameInstance::GetOnlinePlatformName, 然后找UOnlineEngineInterface::GetDefaultOnlineSubsystemName获得

UOnlineEngineInterface是个接口类, 自然不同平台有对应的子类, 有不同的实现



其中, UOnlineEngineInterfaceImpl是一个常用实现, 从IOnlineSubsystem中获得对应的平台名称



同理又得, FOnlineSubsystemImpl又是IOnlineSubsystem的一个常用实现, SubsystemName该属性就是平台名称



以FOnlineSubsystemSteam为例, 它将STEAM_SUBSYSTEM作为SubsystemName传入, 最后平台名称, 也就是SubsystemName了

参考文件Engine\Plugins\Online\OnlineSubsystem\Source\Public\OnlineSubsystemNames

里面定义了若干平台名称对应(如下图)





发送NMT_Login消息, 带有的字符串, 就都逐个介绍过.

再总的概况一下, 客户端向服务器发送包含玩家昵称, 网络ID, 连接地图参数, 平台名称的内容

给, 这是我的身份证明(玩家昵称与网络ID), 工作单位(平台名称), 来干什么的(连接参数), 放我进去吧!

服务器收到NMT_Login消息, 兜兜转转又走到UWorld::NotifyControlMessage处, 开始处理



老规矩, 先检查


好的, 检查通过, 我看看, 你写的什么.

嗯, 一个登陆请求, 想进去.




先看看信息对不对, 并确认一下.



没问题, 好, 至少我觉得没问题.

我再问问你要去的地方(游戏地图内)允不允许你去.

AGameModeBase, 这个人的信息有问题没? 人你要不要? 有问题就让他滚蛋了.

// 这个时候就是Gameplay里面, 可以处理很多, 比如人满了, 不让进, 参数不对, 不让进等等

没问题!

听见了没, 还不快gu...等den, 没问题...

...

先生, 欢迎光临, 里边儿请!




AGameModeBase, 招待下新人, 他要去哪里, 干什么?


哦, 好的.

来, 看这张地图, 去这个地方(LevelName)做这个事 (GameMode),


第四回合 NMT_Welcome
客户端又收到一条NMT_Welcome信息

还是在老地方UPendingNetGame::NotifyControlMessage处理


我可以进去了?


嗯, 我要去这个地方干在这个事, 和之前想的不太一样啊!

// 客户端连接服务器时, 请求地图和GameMode是无效的, 以服务器为准


赶紧过去报道!


我要过去报道了, 马上就到!

服务器收到NMT_Netspeed消息, 又走到UWorld::NotifyControlMessage处



日常检查一下, 然后设置一下客户端的网络速度



收到, 速度还挺快!

第五回合 NMT_Join

客户端加载完地图, 准备正式加入服务器


我准备好了!

我准备好了!

服务器又收到一条NMT_Join信息, 兜兜转转还是UWorld::NotifyControlMessage在处理

检测, 通过略




好了, 你的身份牌(PlayerController)生成了, 好好干!

经过这么多道手续, 客户端终于通过了身份验证, 和服务器建立起连接.

客户端就进入到AGameModeBase流程, 见其他文章


</code></pre>
</details>

<details>
<summary>UE5 正数倒计时(催更)系列 (序)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/369300127
前言
这是一个因鸽子太久, 而诞生的一个专栏
这是一个, 觉得皮起来会很有趣, 而诞生的一个专栏
这是一个, 常年放鸽子, 这次被放鸽子, 而诞生的一个UE5 催更专栏
历史背景和前因是吐槽, 可以直接下滚跳转到介绍, 看本文内容.
历史背景
鉴于之前鸽子了很久, 嗯, 原因也很多 :

工作忙, 程序这行, 嗯, 都知道.
忙于工作, 能休息时候又补休息, 娱乐娱乐, 再接着忙工作(中间穿插些赛博朋克, 戴森球等等耗时很久的游戏), 能水文章的时间很少了
现在算连着忙完三四个阶段了, 之后会空闲一点
系列文章不好写(水)
UObject系列, 再写的话, 一篇文章花费的精力会很久, 再加上UE4 4.25 反射的一些类换成了F类
网络系列呢, 写一些RPC和属性同步底层的话, 不好下手; 应用的话, 没有项目不好写.(网络系列写着写着就开始忙了)
疫情原因
疫情的后遗症, 人有点伤, 佛系了很多, 然后就, 懒得不想写了.
总之, 鸽子的理由有不少, 就心安理得的放鸽子了, 咕咕咕~~~

最后, 嗯, 太监是不会的, 但鸽子是一定的.

咕咕咕~~

前因
然后呢, 在五一前几天, 突发奇想(闲得无聊), 想到一个好点子.

一天写(水)一篇文章, 写一些 UE4 相关的, 篇幅不长, 内容很少, 零碎的内容, 内容水平也不需要很一致

如 :

无用的知识又增加了 +1
你可能不知道的冷门技巧
恶作剧技巧, 教你如何搞同事心态 (慎用)
简简单单的小Tips
这种内容, 写起来不会特别费劲(毕竟用了这么久UE4), 别人阅读看起来也有一点内容

并且, 在有空的时候, 顺手写一点, 多攒点, 水100多篇还是没什么问题的.

以及, 如果, 正的没有东西可以写, 那, 嗯, 再就 ---扒一扒别人的教程功能喽---(假装有删除线)

开一个测试 或者 编辑器系列, 把内容打碎的不成样子, 嗯, 不就有了吗?

然后, 就是日更的动机了, 需要一个强烈的动机, 才能进行日更.

不然, 仿佛看到了隔壁鸽子的专栏系列, 自己手里鸽子的游戏Demo.

嗯, 想一想, 想一想.

UE5不是放人鸽子了吗? 去年说的2021年第一季度, 嗯, 跳票了!

算一算日子, 盲猜, 可能, 大概, 会推迟到今年的UnrealOpenDay了吧!

早的话, 暑假? 再迟也在10月前了吧!

5, 6, 7, 8, 9 五个月, 按这样算, 七月中旬就是得75篇, 十月初就是150篇.

应该还是写(水)的动的!

因此.

这个专栏就诞生了!

同时, 这个专栏也在2021.5.25号, 历经25天, 成功完结, 撒花!
介绍
面向人群 : UE4程序员同行

内容复杂度 : 简易, 零碎, 有趣, 好玩

目的 : 皮一下很开心

更新频率 : 日更

更新开始时间 : 2021.5.1

更新结束时间 : UE5发行

更新的所有内容及分类, 见下文

你可能不知道的冷门技巧(无用的知识又增加了)
孤傲雕：UE5 正计催系列 5.6号 减少编译次数小技巧

孤傲雕：UE5 正计催系列 5.7号 减少"空白UI"

孤傲雕：UE5 正计催系列 5.8号 去除默认蓝图节点

孤傲雕：UE5 正计催系列 5.9号 去除默认C++节点

孤傲雕：UE5 正计催系列 5.11号 美化的蓝图连接线

孤傲雕：UE5 正计催系列 5.12号 高亮方便查看蓝图节点

孤傲雕：UE5 正计催系列 5.14号 Delay的亲兄弟

恶作剧技巧, 教你如何搞同事心态 (慎用)
孤傲雕：UE5 正计催系列 5.1号 之 UE5它"来"了

孤傲雕：UE5 正计催系列 5.5号 谁动了我的变量???

孤傲雕：UE5 正计催系列 5.13号 "罢工的"蓝图节点

孤傲雕：UE5 正计催系列 5.18号 "上班"的蓝图节点

简简单单的小Tips
孤傲雕：UE5 正计催系列 5.3号 之分辨Cast类型

孤傲雕：UE5 正计催系列 5.4号 之 蓝图属性面板过滤选项

孤傲雕：UE5 正计催系列 5.10号 按键事件名称

孤傲雕：UE5 正计催系列 5.15号 类似PrintString的DevelopmentOnly蓝图节点

孤傲雕：UE5 正计催系列 5.16号 奇怪的Random节点

孤傲雕：UE5 正计催系列 5.17号 这也是个"临时变量"?

孤傲雕：UE5 正计催系列 5.20号 类似PrintString的隐藏部分参数节点

孤傲雕：UE5 正计催系列 5.21号 控制蓝图属性面板参数是否可编辑

孤傲雕：UE5 正计催系列 5.22号 Class相关过滤标记

孤傲雕：UE5 正计催系列 5.23号 控制台命令ConsoleCommand

孤傲雕：UE5 正计催系列 5.25号 Ending.

一本正经的胡说八道系列
孤傲雕：UE5 正计催系列 5.2号 之 "脚本"?

孤傲雕：UE5 正计催系列 5.19号 论文章是怎么水的

孤傲雕：UE5 正计催系列 5.24号 添加Pack资源包到任意项目
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.1号 之 UE5它"来"了</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/369318530
前言
UE5 正数倒计时(催更)系列 第一篇
孤傲雕：UE5 正数倒计时(催更)系列 (序)
如果没有看过序的, 请看过之后, 再阅读本篇文章, 食用更佳
如果没有看过序的, 请看过之后, 再阅读本篇文章, 食用更佳
如果没有看过序的, 请看过之后, 再阅读本篇文章, 食用更佳
日更系列第一篇, 废话不多说, 先看个视频, 上干货

UE5偷跑
106 播放 · 0 赞同视频
点击可播放视频


系列完结散花!!!





教程
嗯, 偷跑是不可能偷跑的!

就简单看一下为什么会是这个样子吧!


首先项目启动的时候, 窗口样子如图.

熟悉UE各系列引擎的朋友们, 应该都知道 :

这里的背景图是可以定制的, 自己随便用图片替换.


在ProjectSetting->Platforms->Windows->EditorSplash设置, 随便更改.

既然我们可以更换这张图片, 那么我们就以这张图片为基础, 找到这张图片路径, 进而找到所有相关使用的地方.

只要找到图片使用的地方, 也自然能找到版本号, 版权信息文本设置的地方.

然后修改一下文本, UE"5", 它不就有了吗?

首先, 要找到这张图片使用的地方.


在Rider中(VS同理), 用全局搜索(Ctrl+Shift+F), 在整个项目中搜索Editor Splash配置名称, 会找到几处引用:



Linux和Mac的忽略, 只看Windows的

Windows的有WindowsTargetSettingsDetails.cpp和WindowsPlatformSplash.cpp两个文件

字面翻译, 很明显, 前面是一个设置相关的, 后者Windows平台Splash

Splash 这个东西, 嗯, 找不到直接的字面翻译
Splash screen 是 启动画面
那Splash中文参考意思 ? 启动? 还是Splash screen 简写.
Windows的平台启动画面?

那自然先看一下这个喽, 兴许直接找到了呢!


426行, 注释内容 : 强制让编辑器启动屏幕 显示在任务栏和alt-tab列表中, 略


659行, 注释内容 : 在编辑器初始屏幕中显示版权信息


版权信息? 好我们找到位置了


往上看一点? 是不是就找到了?

把这里的Version修改成5.0.0试一下!(仅限源码版)


然后编译运行.


简单极了! 不是吗?

教程2
如果, 我说如果, 搜索功能没有这么直接找到.

毕竟, 搜索结果是两个注释, 那又该怎么办呢?


接上文搜索结果, 我们不看注释, 那就是WindowsTargetSettingsDetails文件176行.


跳转看一下, 看红色箭头, 这个属性在下面Slate界面中使用, 对应的是配置UI的部分

SExternalImageReference字面翻译, 外部图片引用, 联系UI实际功能, 就是一个选择本地图片资源的SlateUI界面了.


它既然显示着有UE4的默认图片, 那找一下类似参数, 字面上看, 就是这个喽.

然后看一下函数GetWindowsSplashFilename这个函数时怎么获得这个路径的呢?



相对路径, 路径转换忽略, 只看红色圈起部分.

一个文件名称常量, 结合路径, 不难推出实际的路径

以引擎的为例, 在\UnrealEngine-4.26\Engine\Content\Splash下面


然后, 看一看, 这个常量在哪些地方使用, 不就能找到启动UI了吗?


可惜, 现实没有怎么简单, 他只在这一个地方使用过???

线索好像中断, 推理陷入了僵局...

...

..

.

回想一下, 我们得到了什么, 这张图片的物理路径和名称.

物理路径是一些相对路径和常量Splash/EdSplash.bmp推导出来的.

常量, 搜索一下常量试试?


一无所获!

那去掉前面的文件夹呢?


还是什么都没有!


那只搜索文件名, 后缀去掉, 总该有东西了吧?

排除掉NeedSplash和SupportedSplash两个只是包含这几个字符的变量名称


在这一行, 有一个TCHAR用到了文件名



看到这个常量Splash/了吗? 路径获取也相同.

那这里, 应该就是使用这张图片的另一个地方.



接着, 赋值给了一个全局变量, 并在之后调用, 创建一个解码器, 解析图片.


那这个解码器的函数是什么? 加载图片.

与他无关, 往上反.



SplashPath设置给全局变量前面的代码. 文本是不是很熟?

破案
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.2号 之 "脚本"?</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/369429144
前言
UE5 正数倒计时(催更)系列 第二篇
UE4 4.26源码版
分类 : 一本正经的胡说八道系列
分类 : 一本正经的胡说八道系列
分类 : 一本正经的胡说八道系列
正文
据说, UE5 要出新的脚本语言了?

那大家知道UE4 其实也有脚本语言吗?

"""
Begin Object Class=/Script/BlueprintGraph.K2Node_Event Name="K2Node_Event_2"
   EventReference=(MemberParent=Class'"/Script/Engine.Actor"',MemberName="ReceiveBeginPlay")
   bOverrideFunction=True
   CustomProperties Pin (PinId=661291C14DAA612DF1148DB6F727EA23,PinName="OutputDelegate",Direction="EGPD_Output",PinType.PinCategory="delegate",PinType.PinSubCategory="",PinType.PinSubCategoryObject=None,PinType.PinSubCategoryMemberReference=(MemberParent=Class'"/Script/Engine.Actor"',MemberName="ReceiveBeginPlay"),PinType.PinValueType=(),PinType.ContainerType=None,PinType.bIsReference=False,PinType.bIsConst=False,PinType.bIsWeakPointer=False,PinType.bIsUObjectWrapper=True,PersistentGuid=00000000000000000000000000000000,bHidden=False,bNotConnectable=False,bDefaultValueIsReadOnly=False,bDefaultValueIsIgnored=False,bAdvancedView=False,bOrphanedPin=False,)
   CustomProperties Pin (PinId=7410C6D44D025343D5D671A674C5295B,PinName="then",Direction="EGPD_Output",PinType.PinCategory="exec",PinType.PinSubCategory="",PinType.PinSubCategoryObject=None,PinType.PinSubCategoryMemberReference=(),PinType.PinValueType=(),PinType.ContainerType=None,PinType.bIsReference=False,PinType.bIsConst=False,PinType.bIsWeakPointer=False,PinType.bIsUObjectWrapper=True,LinkedTo=(K2Node_CallFunction_0 6E1B62E8474FD80321EC52B43E5E777C,),PersistentGuid=00000000000000000000000000000000,bHidden=False,bNotConnectable=False,bDefaultValueIsReadOnly=False,bDefaultValueIsIgnored=False,bAdvancedView=False,bOrphanedPin=False,)
End Object
Begin Object Class=/Script/BlueprintGraph.K2Node_CallFunction Name="K2Node_CallFunction_0"
   FunctionReference=(MemberParent=Class'"/Script/Engine.KismetSystemLibrary"',MemberName="PrintString")
   CustomProperties Pin (PinId=6E1B62E8474FD80321EC52B43E5E777C,PinName="execute",PinToolTip="\nExec",PinType.PinCategory="exec",PinType.PinSubCategory="",PinType.PinSubCategoryObject=None,PinType.PinSubCategoryMemberReference=(),PinType.PinValueType=(),PinType.ContainerType=None,PinType.bIsReference=False,PinType.bIsConst=False,PinType.bIsWeakPointer=False,PinType.bIsUObjectWrapper=True,LinkedTo=(K2Node_Event_2 7410C6D44D025343D5D671A674C5295B,),PersistentGuid=00000000000000000000000000000000,bHidden=False,bNotConnectable=False,bDefaultValueIsReadOnly=False,bDefaultValueIsIgnored=False,bAdvancedView=False,bOrphanedPin=False,)
   CustomProperties Pin (PinId=BEF4B1134F790BC997890DB340852912,PinName="InString",PinToolTip="In String\nString\n\nThe string to log out",PinType.PinCategory="string",PinType.PinSubCategory="",PinType.PinSubCategoryObject=None,PinType.PinSubCategoryMemberReference=(),PinType.PinValueType=(),PinType.ContainerType=None,PinType.bIsReference=False,PinType.bIsConst=False,PinType.bIsWeakPointer=False,PinType.bIsUObjectWrapper=False,DefaultValue="Hello World!",AutogeneratedDefaultValue="Hello",PersistentGuid=00000000000000000000000000000000,bHidden=False,bNotConnectable=False,bDefaultValueIsReadOnly=False,bDefaultValueIsIgnored=False,bAdvancedView=False,bOrphanedPin=False,)
End Object
"""
如上, 这是一段UE4的脚本语言, 是不是看起来很麻烦的样子?

这么多行, 这么多属性赋值, 参数.

你能想到这只是一个简简单单的Print String函数吗?


就和上图这点蓝图实现的功能一样.

同时, 这个脚本语言, 没有任何语法编辑器!

一个错别单词, 整段代码就不可以使用了, 编写起来特别麻烦!

敲完上面这个Print Hello World!的Demo, 我这里, 一个一个单词校对了好久!

以及呢!

这个脚本语言兼容性极差, 不信你复制一下上面的代码, 去使用一下? 看能不能用?

嗯, 大概率是不可以的.

哦, 忘了说使用方式了!

由于这个脚本糟糕的编写方式, 以及糟糕的编写效率, 兼容性等等各种各样的问题.

官方连给这个脚本语言起名字, 这么必要的事情都没有做!

所以, 它使用还需要依赖蓝图界面!

你需要先写好所有的脚本代码, 然后全选Ctrl+C复制, 接着选择任意一个蓝图, 在里面Ctrl+V进行粘贴.


如上图, 这个脚本语言, 这个没有编辑器界面的脚本语言!

最后的展示形式, 竟然是 蓝! 图! ?

唉, 心累!

就这样, 不断的恶性循环, 最后, 知道这个脚本语言的人, 没有几个.

能掌握的人更是少之又少, 可悲啊!

也不知道UE5的脚本语言会是什么样子!



脚本制作编写方式

先在蓝图界面, 用蓝图编写好脚本实际实现内容, 然后全选Ctrl+C.

选择一个文本界面Ctrl+V.

逐步删掉一些无用的属性字段, 就可以喽!



嗯, 是不是一个很麻烦的 "脚本语言"呢?
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.3号 之分辨Cast类型</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/369536322
前言
UE5 正数倒计时(催更)系列 第三篇
UE4 4.26源码版
分类 : 无用的知识又增加了





如图, 如果在项目中有两个同名的蓝图节点, 是不太容易分辨哪个类是哪个类的

当然, 可以并推荐通过避免重名来规范
尤其是两个类又相同变量名称的时候


那我们怎么来分辨呢?


选中Cast节点, 然后Ctrl+C复制

然后打开一个文本框Ctrl+V粘贴

两个都这样操作


然后在复制的文本中, 看TargetType这个类, 就是Cast对象的类路径

好的, 这个技巧你Get了吗?
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.4号 之 蓝图属性面板过滤选项</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/369785593
前言
UE5 正数倒计时(催更)系列 第四篇
UE4 4.26源码版
分类 : 简简单单的小Tips
正文

蓝图的属性界面, 往往有很多的参数, 同时又有很多的层级.

如果比较恰当的掌握一些参数过滤等技巧, 也有时候可以省很多功夫.

其中有以下选项或按钮

ShowOnlyModifiedProperties选项
ShowOnlyKeyableProperties选项
ShowOnlyAnimatedProperties选项
ShowAllAdvancedDetails选项
ShowHiddenPropertiesWhilePlaying选项
ShowChildOnCategoryMatch选项
CollapseAllCategories按钮
ExpandAllCategoris按钮
下文将描述一下这几个选项或按钮的使用.

ShowChildOnCategoryMatch选项没找到相关介绍文档或资料
源码扫了几眼, 有点多, 没细看
嗯, 估计, 大概, 很多人不知道这些方便的功能.

ShowOnlyModifiedProperties

这是一个过滤选项, 将仅展示值被修改过, 且不和默认值相同的参数.

或者换一个说法, 将仅展示继承父类的属性, 在子类属性被修改过, 不和父类属性值相同.

那有什么常见用途呢?

便捷查看父子类属性差异
基础用途, 不啰嗦
便捷查看蓝图类对C++类继承后的属性修改
同上一点, 这里是进一步补充
便捷查看生成的组件的属性值修改
以下图第三人称模版中的CharaterMovementComponent为例, 可以很方便查看哪些属性修改过



ShowOnlyKeyableProperties & ShowOnlyAnimatedProperties
这两个选项是和Sequnce打交道的


ShowOnlyKeyableProperties是过滤, 仅展示在Sequence可以被编辑的的属性

可以看到, 属性名称右边有一个小图标 : 右上角带加号的菱形

点击这个图标, 可以把属性直接添加到Sequnce编辑器内


这个属性能否编辑呢? 这里举个方法, 变量属性中将ExposeToCinematics打勾, 暴露出去


当这个属性添加到Sequnce编辑器内后, 那么就可以用ShowOnlyAnimatedProperties选项进行过滤了

ShowHiddenPropertiesWhilePlaying


ShowHiddenPropertiesWhilePlaying如上两张图

开启之后, 调试会十分方便, 看到更全的数据

ShowAllAdvancedDetailsy & CollapseAllCategories & ExpandAllCategoris

CollapseAllCategories按钮, 收齐所有的分类


ExpandAllCategoris展开所有的分类



ShowAllAdvancedDetails也比较简单了

由于一个类属性特别多, 看起来很乱.

所以, 会把一些不常用的属性隐藏掉, 只在需要的时候, 再点击下拉三角进行显示.

当ShowAllAdvancedDetails这个选项勾选后, 相当于默认全部展示, 不隐藏任何属性

同时, 也不允许你隐藏属性, 你人工点击上拉三角不会有任何反应
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.5号 谁动了我的变量???</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/369732328
前言
UE5 正数倒计时(催更)系列 第五篇
UE4 4.26源码版
分类 : 恶作剧技巧, 教你如何搞同事心态(慎用)
正文


如上图, 在C++定义一个结构体, 有变量是EditDefaultsOnly

在蓝图中的BeginPlay中, 打印一句话, Hello World!


哦, 忘了加标点符号了, 我们在场景中修改一下, 将Content2改成World!

然后运行, 看日志打印情况


LogBlueprintUserMessages: [NewBlueprint_2] OK World!

???

??

?

谁动了我的变量


我们将World!变量改为World, 再看一下

???

没有任何修改, 为什么还是小黄三角

那我们点一下小黄三角, 再打印一下呢?


LogBlueprintUserMessages: [NewBlueprint_2] Hello World

又正常了!?

发生了什么?

教程


在地图的属性面板中, 右键Copy整个结构体属性值, 粘贴到一个文本编辑器中.

修改Content中的Hello为OK



再将值粘贴回去, 修改完成.

原理
简单描述就是EditDefaultsOnly仅是在编辑器编辑界面内不展示

但是在序列化存储的时候还是要保存这个值

所以在地图中的Actor属性存值时, 存的还是整个结构体的值.

此时, 我们单独针对修改结构体中某一个属性的值, 就会造成上面的效果.

恶作剧指南
如果, 此时, 地图中结构属性复杂一些

修改某个关键值, 是很不容易查找到的, 或者通过堆栈调试查找到之后, 也会特别懵, 为什么是这个样子的.

这个操作是修改地图资源, 是一个比较正常的操作.

同时, 版本管理对应的也是二进制文件修改, 历史记录不容易精确定位谁的提交, 不好查证

加上, 常年使用UE4蓝图的, 会潜意识的知道, 蓝图编辑器内, 序列化相关有很多的坑, 往往不会认为是人为因素.

甚至, 该bug在UE4正常使用流程, 都可以造成.

嗯, 总之, 这个小恶作剧

危害性弱, 解决方法有简有易, 不易追踪被发现, 如果有兴趣, 可以和别人试一试, 皮一下.

(被揍了当我没说[假装有删除线])
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.6号 减少编译次数小技巧</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/370211758
前言
UE5 正数倒计时(催更)系列 第六篇
UE4 4.26源码版
分类 : 你可能不知道的冷门技巧
正文
作为一个UE4重度C++使用患者

在项目中建立C++类是特别常见的操作

尤其是在经过长时间的思考准备, 设计完这个功能的框架结构后

往往会连续建立特别特别多的C++类

然后


嗯, 不急, 听一首歌, 放松一下


再添加一个类, 再来一首歌.

这才两个, 还有下面这么多的类

TestGameInstance
TestPlayerController
TestPlayerState
TestPawn
...
愉快的休闲的一个小时就这样过去了.

等等, 你现在在家, 不是在公司.

嗯?

嗯?

大好的时光怎么能这样浪费.

看我的.


Edit->EditorPreferences 引擎设置中的
->General->Miscellaneous 杂乱的常见设置中
->HotReload->Antumatically CompileNewly Added C++ Classes

将这个勾选去掉, UE4就不会自动编译了


然后我们就可以在短时间内, 建立大量的C++类

然后, 将项目完整的编译一遍.


简简单单, 完成收工!
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.7号 减少"空白UI"</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/370486018
前言
UE5 正数倒计时(催更)系列 第七篇
UE4 4.26源码版
分类 : 你可能不知道的冷门技巧
正文

如果, 家里的显示器比较小, 或者用的是笔记本

电脑屏幕是不太够用的, 很多窗口都小的可怜.

关了吧, 又经常使用, 打开麻烦.

那, Get些小技巧, 试着拯救下.



如上两张图, 在窗口的左上角名称处右键->HideTab, 可以减少一行小字大小的空间




通过EditorPreferences->General->Appearance->UserInterface->UseSmallToolBarIcons选项, 开启可以将编辑器上面, 一行大大的图标变小, 减省出大量空间.

这两个小技巧是不是很好用呢?

什么? 为什么问你们好不好用.

27寸曲面屏了解一下(手动狗头
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.8号 去除默认蓝图节点</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/370779021
前言
UE5 正数倒计时(催更)系列 第七篇
UE4 4.26源码版
分类 : 你可能不知道的冷门技巧
正文

作为一个专业的, 有强迫证的程序员, 对于每次新建蓝图之后, 默认创建的三个节点.

总是, 左手一拉全选, Del删除键一按, 直接删除, 豪不犹豫.

再经过成百上千次的磨炼后, 我选择了投降┗( ´・∧・｀)┛

才怪.


Editor Preference ->ContentEditors->BlueprintEditor->Workflow->SpawnDefaultBlueprintNodes

将这个选项关闭


啊, 世界瞬间清净了
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.9号 去除默认C++节点</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/370947757
前言
UE5 正数倒计时(催更)系列 第九篇
UE4 4.26源码版
分类 : 你可能不知道的冷门技巧
正文
孤傲雕：UE5 正计催系列 5.8号 去除默认蓝图节点

接昨天的文章, 对于蓝图节点都不能忍, 那C++这一大堆无用节点, 就更不能忍了.


怎么去掉呢?

如果我们知道他怎么写的, 修改写的地方, 不就可以了吗?


首先, 通过创建C++文件的按钮, 找到对应的Slate类, 是SNewClassDialog


然后通过这个按钮, 找到对应的CreateClass按钮, 进一步找到SNewClassDialog::FinishClicked事件

这个事件, 就是当创建文件按钮点击之后的执行事件, 这个事件中, 将创建对应的C++文件.



Domain领域, C++类自然是Native, 原生了, 我们接着看Else里面的内容

为了方便起见, 可以一步一步打断点执行, 去查找, 哪里写入文件的.

或者跟着我, 直接进入重点, 当你读码读多了之后, 会有一种直觉或者说本能 : 功能该如何拆分, 参数如何传递.


GameProjectUtils::AddCodeToProject将新的Class名称路径各种信息都传入进去, 返回一个GameProjectUtils::EAddCodeToProjectResult结果枚举

那它应该是一个实现函数了


UE4常见操作, Internal内部处理继续跳


忽略部分参数有效检测, 和引擎内部提示框, 我们接着往下


两个Filename?文件名称

最后代码文件一定会写到硬盘里面, 同时上下有个SlowTask的进度更新


接着NewHeaderFilename头文件变量参数继续往下看, 会有GenerateClassHeaderFile函数


扫一眼整个函数的实现, 最后是一个WriteOutputFile写文件函数.

嗯, 写头文件的相关实现就是这里了.



然后, 找一下写入的内容, 是怎么来的?


常见写法, 先找模版, 创建头文件的模版


然后, 获得实际的一些名词, 类前缀, 带前缀修饰的类名等等


再往下, 就是一些文本替换, 最后将内容写入文件.



显而易见, 在模版这一块, 就已经决定了, 最后文件是什么样子


此时, 我们跟着断点走, 发现bTemplateFound没有找到, 没有注册自己写指定类的脚本模版


在跳模版的时候, GetHeaderTemplateFilename跳进了ActorClass.h.template



最后, 通过ReadTemplateFile函数中代码拼接, 根据路径, 可以推导出, 脚本最后的模版路径在



模版看起来是不是很熟悉?

最后, 我们将ActorClass.cpp.template和ActorClass.h.template模版中的构造函数, BeginPlay, Tick删掉, 就图中红色框起部分


然后, 新建一个Actor类.

啊, 世界瞬间又清静了许多.

怎么样? 你学废了吗?
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.10号 按键事件名称</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/371247205
前言
UE5 正数倒计时(催更)系列 第十篇
UE4 4.26源码版
分类 : 简简单单的小Tips
正文

随着EKeys新版本的修改, 不同平台的手柄, 有对应专门的枚举, 不再混合使用.



枚举数量也跟随着成倍增加, 已经有670-270=400行了.

排除掉一些空白行, 但也能看到是一个不小的数字了.

一个一个去找对应设备的名字, 是一件很麻烦的事.






简简单单一个AnyKey蓝图节点, 按一个按键, 就可以直接获得对应的名字.
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.11号 美化的蓝图连接线</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/371256630
前言
UE5 正数倒计时(催更)系列 第十一篇
UE4 4.26源码版
分类 : 你可能不知道的冷门技巧
孤傲雕：UE5 正计催系列 5.10号 按键事件名称




有细心的朋友注意到图中的蓝图节点有什么变化吗?


再看看这张呢?

是不是加上一个小箭头, 看起来更清晰直白了一点呢? 蓝图执行线的方向都标明了!





这样的蓝图界面你想拥有吗?

动动你的小手指, 马上拥有


EditorPreference->ContentEditors->BlueprintEditor
->VisualStyle->DrawMidpointArrowsInBlueprints

小勾一选, 新的蓝图样式, 立刻带回家!
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.12号 高亮方便查看蓝图节点</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/371840169
前言
UE5 正数倒计时(催更)系列 第十二篇
UE4 4.26源码版
分类 : 你可能不知道的冷门技巧
正文

这是正常的蓝图界面


这是开启HideUnrelated之后的界面





这个HideUnrelated, 隐藏无关的节点按钮开启后, 点击某个节点, 会高亮显示该节点执行线相关联的节点.

在复杂蓝图界面, 查看逻辑的时候, 十分好用.
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.13号 "罢工的"蓝图节点</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/371844684
前言
UE5 正数倒计时(催更)系列 第十三篇
UE4 4.26源码版
分类 : 恶作剧技巧, 教你如何搞同事心态(慎用)
序
孤傲雕：UE5 正计催系列 5.5号 谁动了我的变量???

接前文, 有没有勇者去实际尝试一下呢?

啊? 没有?

不不, 是他们没有活着回来罢了!

正文

新建一个空Actor蓝图, 如上图建立蓝图节点, 进行一个字符串拼接

然后打印拼接后的整体Hello World!

然后建立一个空场景, 将这个Actor放置到场景中, 点击BeginPlay运行


只打印了一个Hello!

???

World呢???

???

教程
有完整教程原理, 我不写, 我就藏着, 哎, 就是玩儿!
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.14号 Delay的亲兄弟</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/372115593
前言
UE5 正数倒计时(催更)系列 第十四篇
UE4 4.26源码版
分类 : 你可能不知道的冷门技巧
序
孤傲雕：UE5 正计催系列 5.13号 "罢工的"蓝图节点

你以为今天会揭晓答案吗? 并不会.

开局一张图, 内容全靠编.

不是, 你听我正经的给你念叨.
在UE4蓝图中, Delay有个亲兄弟, 叫做RetriggerableDelay, 是一个毫无存在感的家伙(虽然也毫无用处[假装有删除线]).

在BeginPlay类似这种单向执行的节点, 他们干着相同的活, 延迟一段时间做某事.

动图封面
但当Tick这样高频率运行的时候, Delay会很勤快的, 在它力所能及的范围内, 尽可能多的去做事.

像上图中的Tick, 会每秒打印一次Tick Delay, 勤快的很

而RetriggerableDelay就很偷懒了, 你一直给我新活, 那我就不干了!

不给我活得时候, 我再慢悠悠的把最后一个活干了, 休息, 懒得不成样子.
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.15号 类似PrintString的DevelopmentOnly蓝图节点</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/372734979
前言
UE5 正数倒计时(催更)系列 第十五篇(补)
UE4 4.26源码版
分类 : 简简单单的小Tips
正文

在日常学习工作中, PrintString是一个特别常用的蓝图节点.

在某次UE4升级版本之后, 它变得特殊起来, 变成了一个DevelopmentOnly的节点.


This node will only be executed in the editor and in Development builds in a packaged game (it will be treated as disabled in Shipping or Test builds cooked from a commandlet)
这种节点将仅在编辑器中以及打包游戏中的“开发”版本中执行（在发行和测试版本将特殊处理, 视为已禁用, 不再执行）


然后, 看一下UKismetSystemLibrary::PrintString这个函数定义

UFUNCTION中meta元数据中, 有个DevelopmentOnly标记

我们自定义一个函数试一下


嗯, 搞定, 然后, 有什么用呢? 好像, 没有吧!
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.16号 奇怪的Random节点</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/372773913
前言
UE5 正数倒计时(催更)系列 第十六篇
UE4 4.26源码版
分类 : 简简单单的小Tips
试卷
闲着无聊, 先来一套卷纸压压惊!

请在规定时间内认真作答, 不要交头接耳, 不要试图作弊!


问题一, 如上图逻辑, 节点中的打印值, FirstValue和SecondValue是否一样?

请思考后作答, 可能有点难了.

作答完毕, 好, 请记住你的答案. 继续答题.


问题二, 如上图逻辑, 节点中的打印值, FirstValue和SecondValue是否一样?

请思考后作答, 是不是很简单啊?

作答完毕, 好, 请记住你的答案. 继续答题.


问题三, 如上图逻辑, 节点中的打印值, FirstValue和SecondValue是否一样?

请思考后作答, 有点懵? 那随便才一个呗!

作答完毕, 好, 请记住你的答案. 继续答题.


最后一问, 如上图逻辑, 节点中的打印值, FirstValue和SecondValue是否一样?

请思考后作答, 送分题, 很容易吧!

作答完毕, 好, 请对比下面的实际输出记录, 比对答案.





问题一答案, 不一样


问题二答案, 不一样


问题三答案, 不一样


问题四答案, 一样


测试

新建一个函数, 每次运行打印一次日志, 返回值为固定值

函数本身标记为纯函数, 勾选Pure选项, 此时这个函数没有执行线




代替问题二题目, 运行, 结果如下



代替原图一的问题, 运行, 结果如下



再猜一下, 上图中的输出结果, 会是四个一样的Float值, 还是四个不同的值






原理
动图封面
当运行到PrintString时, 这是一次执行, 需要一个字符串参数, 然后去找节点MakeColor生成

MakeColor节点运行一次, 需要四个浮点数, 去找RandomFloat生成

RandomFloat运行一次, 返回值赋值给MakeColor, 逻辑闭合.

此时RandomFloat运行一次, 生成了一个随机数

下一个PrintString时, 又是一次执行, 同理RandomFloat再次被调用, 此时的值变成了一个新的值.

概况就是, 蓝图节点运行之后, 返回值会临时存储, 直到下一次再被执行的时候覆盖.

而RandomFloat节点又在反复执行, 导致最后输出的值不断变化.

所以, Random生成的值, 如果多次使用的话, 不能用上面的写法, 需要新建立一个变量存一下.
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.17号 这也是个"临时变量"?</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/372780964
前言
UE5 正数倒计时(催更)系列 第十七篇(提前)
UE4 4.26源码版
分类 : 简简单单的小Tips
正文
孤傲雕：UE5 正计催系列 5.16号 奇怪的Random节点

概况就是, 蓝图节点运行之后, 返回值会临时存储, 直到下一次再被执行的时候覆盖.
这是昨天文章里面的一句话, 嗯, 单纯针对这句话, 昨天的用法可能还比较直白, 易于理解, 今天的做法, 就有点, 那个词叫, 骚.


使用第三人称模版, 此时Pawn的类型是Character, Cast成功有值

然后BeginPlay输出一句话.

接着跑Tick帧, 每一秒输出一次, 此时获得Character的DisplayName

此处的AsCharacter引脚, 是临时储存有Character的值


最后打印的日志如上.

也就是说, 这个Cast之后的AsCharacter我们可以不用变量保存, 直接使用

此处的Cast节点引脚会变成一个"临时的变量"

同理, 其他的节点引脚也可以做相同的操作.



那么, 有什么用呢?

额鹅呃诶嗯噩...
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.18号 "上班"的蓝图节点</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/373389256
前言
UE5 正数倒计时(催更)系列 第十八篇
UE4 4.26源码版
分类 : 恶作剧技巧, 教你如何搞同事心态(慎用)
导言
孤傲雕：UE5 正计催系列 5.13号 "罢工的"蓝图节点


经过一个周末的休息, 罢工的蓝图节点休息够了, 开始正常工作了.


大家, 认真看一下图, 看图找不同.


是不是, "罢了个工"回来, 节点本身颜色靓丽了许多?

原理
使用魔法语句, EnabledState=Disabled, 就可以让蓝图节点罢工了!

孤傲雕：UE5 正计催系列 5.2号 之 "脚本"?
孤傲雕：UE5 正计催系列 5.3号 之分辨Cast类型


参考前文, 蓝图是有"脚本语言"的, 我们同理, 将上诉节点全选复制到文本框中.


长长的一串文本, 看起来好乱.



接着, 我们单独复制想要罢工的节点, 找到他的NodePosX和NodePosY, 如上图


并根据这两个属性, 将魔法语句, 复制到前面长长一段文本中, 对应节点内

再将原来的蓝图节点删掉, 用这长长一段文本替换


你学废了吗?
多数蓝图节点都是可以这样操作的哦?
恶作剧指南
指南啥啊?

如果没看过这篇文章, 蓝图节点直接怼到你脸上, 你都不知道怎么回事!

我就问你是不是?

是不是? (理直气壮手叉腰)

遇到这种情况, 是不是骂骂咧咧的吐槽UE4又又又出bug了, 蓝图节点删掉重写就能解决!

没毛病吧!

去试试呗, 怂啥, 这bug你能查出来? (嘴角一歪斜脸笑)

嗯, 总之, 这个恶作剧危害性强, 适用范围广, 解决方法基本同无, 不易追踪被发现, 如果有兴趣, 可以和别人试一试, 皮一下.

(腿打断那就当我没说[假装有删除线])
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.19号 论文章是怎么水的</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/373666781
前言
UE5 正数倒计时(催更)系列 第十九篇
UE4 4.26源码版
分类 : 一本正经的胡说八道系列
分类 : 一本正经的胡说八道系列
分类 : 一本正经的胡说八道系列
序
不知不觉已经水了近二十篇了, 以一百篇为目标的话, 已经五分之一了, 胜利在望啊!

并且, 小道不靠谱消息, 可能, 大概, UE5 有希望在今年GDC大会上发布, 嗯, 7月下旬, 这样一算就已经近四分之一了!

好像扯远了, 扯回来先!

今天这篇文章, 是胡说八道系列, 嗯, 一本正经的描述一下最近怎么水的文章, 以及背后的趣事.

PART A
话题要从这篇文章说起 :

孤傲雕：UE5 正计催系列 5.8号 去除默认蓝图节点

这篇文章之前的文章, 纯粹是消耗常年所得的经验.

这篇文章接下来的一篇, 原计划是一个恶作剧的, 虽然没有验证过, 但感觉行得通的, 结果引出了好多好玩的东西.

我们来复原一下当时的操作 :


首先, 我们还是勾选SpawnDefaultBlueprintNodes节点


新建立一个蓝图TestA, 会有三个默认蓝图节点


然后建立蓝图TestA的子类TestB, 类TestB此时也有三个默认蓝图节点

并且注意, 此处三个节点都没有调用Super


修改类TestA, 此时TestB的BeginPlay由于没有调用Super::BeginPlay

所以, 大概, 应该, 不会打印"Hello Wolrd!"这句话, 没毛病吧?


我们将类TestB放置到场景中运行.

哎, 它打印了!


那在类TestB中加一个节点, 打印一句话, 现在又会是什么情况?


正常了, 父类TestA的BeginPlay不再调用了.

这才对嘛!

当初打算水, 不写文章, 就是奔着这个容易出bug的地方去的, 结果没出.


再把类TestB类的BeginPlay后面的输出语句删掉呢?


什么输出都没有了...


然后, 在仔细对比了两者的区别后, 发现, 颜色不一样.

默认创建的节点(占位节点)是偏虚, 偏透明的, 上面还有一行提示 : 这个节点被禁用了, 并且不会被执行, 拖出节点去构建功能.

嗯, 好像确实不一样, UE4本身做了一些"友好的处理", 虽然容易引起其他bug.

像上面写的那样, 子类没有调用父类的节点, 嗯, 这个bug概率不低.


孤傲雕：UE5 正计催系列 5.2号 之 "脚本"?

参考前文, 蓝图节点是可以序列化成文本的, 这个时候一对比, 发现一个明显的文本字段

EnabledState=Disabled
启用状态禁止, 估计就是它了!


用一个PrintString蓝图节点替换一下, 嗯? 默认有一个EnabledState=DevelopmentOnly

替换掉, 试一下, 搞定, 没毛病, 水文章去.

接着, 就是打开知乎一顿键盘操作.


然后, 越写越不对劲, 这样替换后, 是这个样子!

这是不是太明显了? DevelopmentOnly都没了, 明显对这个蓝图节点动了手脚?


不行, 我得改一改节点, 这样多好, 中间的一个变量赋值出问题了, 颜色浅一点, 根本看不出来.

虽然, 在复制 罢工魔法代码的时候, 误断了一个节点, 最后差点变成了一个乌龙( Ĭ ^ Ĭ )

好在好心人指出来了, 嗯, 再次感谢.

最后有了这篇文章 : 孤傲雕：UE5 正计催系列 5.13号 "罢工的"蓝图节点

然后, 就是水水其他的文章.

这么有意思的东西, 原理当然要迟点写!

PART B
慢慢的, 又过了几天


等等, 好像可以接着皮, 不对, 接着写东西.

PrintString的DevelopmentOnly应该能做做文章, 改个EnabledState=DebugGameOnly试试

不行, DebugOnly? ShippingOnly? TestOnly?

还不行, 那扒源代码去呗!


key键为EnabledState, 那Ctrl+Shift+F全局搜索, 找就是了.

刚巧找到一个看起来特别想的, ENodeEnabledState节点启用状态, 后面还有FBlueprintMetadata::MD_DevelopmentOnly一个蓝图元数据的什么东西



接着, 节点一点, 代码一跳.

刚刚好, 键为EnabledState, 省略了Node, 值为Disabled|DevelopmentOnly, 对的上

可惜, 就只有这三种状态, 水不了Debug版本的PrintString了

额鹅呃诶嗯噩...

那, DevelopmentOnly? 做一个DebugEditor不能执行PrintString的小Tips?


然后切换尝试, 一切照常, 什么变化都没有, 不应该吧?


Shift+F12全局查找使用


在UEdGraphNode::IsNodeEnabled函数内, 找到了, 这个枚举最后如何生效.


如果在编辑器内, 返回不是编辑器运行的, 或者 是否编译蓝图在开发者模式下

保留后者GetDefault<UCookerSettings>()->bCompileBlueprintsInDevelopmentMode水文章的权利, 反正, 大概, 这么啰嗦的文章, 没人看的到的.
看得到的, 过段时间也就忘了
好像, 这段英文很熟悉.


当鼠标放到PrintString的DevelopmentOnly提示框上的时候...

好吧, 白费功夫...


等等, 还有这个玩意

同上, 保留水文章的权利
不排除没有文章可以水的时候, 随便从这里面扒一个修饰符来水
反正, 估计, 大多也都没用过
FBlueprintMetadata::MD_DevelopmentOnly, C++的函数宏标记, 看到上面下面属性的节点, 应该新建个函数, 写上DevelopmentOnly这个标记, 就可以和PrintString一模一样了


像这样, 然后, 我该如何想大家解释, 这个DevelopmentOnly的由来呢?

额鹅呃诶嗯噩...

对了, 我们可以找到UKismetSystemLibrary::PrintString的函数原型


好像, 兜了一个大圈子, 随意, 有的水就行了.

于是, 又有了这一篇文章 : 孤傲雕：UE5 正计催系列 5.15号 类似PrintString的DevelopmentOnly蓝图节点

PART 3
孤傲雕：UE5 正计催系列 5.18号 "上班"的蓝图节点

最后的最后, 当然是揭晓谜底的时候了!

写着写着, 发现已经写了好多了, 文章内容已经够丰满了, 没必要再添加这些内容了, 那就这样吧, 之后再接着水喽.(对, 例如今天)

孤傲雕：UE5 正计催系列 5.8号 去除默认蓝图节点

孤傲雕：UE5 正计催系列 5.13号 "罢工的"蓝图节点

孤傲雕：UE5 正计催系列 5.15号 类似PrintString的DevelopmentOnly蓝图节点

孤傲雕：UE5 正计催系列 5.18号 "上班"的蓝图节点

是不是很巧妙呢? 看起来没有关联性的四篇文章内, 背后有这么多的故事?

PART LAST
最后, 还是一本正经的胡说八道一下, 如有雷同, 纯属巧合!

没有根据代码去考古, 去查历史代码什么情况, 查查, 估计会很有趣. 但我不!

为了新人的友好使用, 所以, UE4编辑器界面默认创建几个蓝图节点.

又为了避免, 这几个默认创建的占位节点, 顶替掉父类的相应节点, 所以加上了ENodeEnabledState::Disabled禁用状态

然后又发现, 很多很多节点只在编辑器内时使用运行, 只起到一些帮助作用, 可以添加一个DevelopmentOnly限制, 已经有一个类似的功能, 稍稍扩展一下, 简单粗暴, 完美极了.

最后的最后, 就成了我们看到的样子, 当然, 内部还有一些其他的使用.

但, 估计, 大概, 也许, 可能, 或许, MayBe, 应该, 绝对.

嗯, 程序员要精确!

写这个功能的程序员, 应该想不到, 这个功能还能这样用 : 恶作剧! (笑)

结语
再接再厉, 争取这次完结, 不鸽子(手动狗头)
手头还有编辑器扩展系列, UObject反射等相关系列, 网络系列, 测试自动等系列, Gameplay流程系列等知识, 嗯, 就是小块的知识点不多了...
也就还有个小20篇(继续狗头)
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.20号 类似PrintString的隐藏部分参数节点</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/373986790
前言
UE5 正数倒计时(催更)系列 第二十篇
UE4 4.26源码版
分类 : 简简单单的小Tips
孤傲雕：UE5 正计催系列 5.19号 论文章是怎么水的

对, 没错, 今天就明目张胆的水文章了!

孤傲雕：UE5 正计催系列 5.15号 类似PrintString的DevelopmentOnly蓝图节点

还记得我们之前说过的吗, 在UFUNCTION宏中, 添加meta=(DevelopmentOnly)可以使一个蓝图节点, 仅在编辑器内和打开发包的时候有效, 其他时候无效.


我们是通过UKismetSystemLibrary::PrintString找到这个标记的, 除此之外, 这里还有很多有意思的其它标记, 我们今天就进一步的来分析一下.


PrintString常用的参数就InString一个, 其余参数都被隐藏了.


算上WorldContextObject这个参数, 嗯, 对应, 刚好.

AdvancedDisplay标记, 加一个int值, 从第几个参数开始高级显示.



没毛病, 水完收工!
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.21号 控制蓝图属性面板参数是否可编辑</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/374367820
前言
UE5 正数倒计时(催更)系列 第二十一篇(补)
UE4 4.26源码版
分类 : 简简单单的小Tips
正文


举例 : UPrimitiveComponent::CustonDepthStencilWriteMask和UPrimitiveComponent两个属性, 在蓝图属性面板中, 只有勾选了RenderCustomDepthPass 这个bool值, 才可以更改



查证 : 通过源代码查看, 是通过标记editcondition = "bRenderCustomDepth" 处理的

也就是说, 使用这个标记, 可以让参数A, 用指定的一个带反射的bool类型参数, 控制参数A在蓝图中的编辑状况

验证 : 鸽子掉了, 咕咕咕.

扩展 :

水, 不, 写文章的时候总得顺手扒扒源码.

兴许能发现其他能水的知识点, 不, 能更完善的分享这个知识点,

这不就找到了吗? (手动狗头)

动图封面

这个属性标记写法, 还支持很多其他写法, 如上.

在UPropertyEditorTestObject 中还有很多其他的, 例如枚举啊, 位运算啊写法, 有兴趣的可以自己扒一下.
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.22号 Class相关过滤标记</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/374378055
前言
UE5 正数倒计时(催更)系列 第二十二篇
UE4 4.26源码版
分类 : 简简单单的小Tips



在日常使用中, 经常需要在C++中定义一个Class用于生成对应对象或者是指定类型资源的引用.

同时, 这个时候Class的范围特别的广, 在蓝图中选择对应的非常麻烦, 常常会有很多不希望的值存在

其实, 可以在C++中属性参数中, 添加AllowedClasses和DisallowedClasses过滤, 多个Class之间用逗号进行分割.

如上图的展示效果, 是不是会方便很多?

你学废了吗?
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.23号 控制台命令ConsoleCommand</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/374918575
前言
UE5 正数倒计时(催更)系列 第二十三篇(补)
UE4 4.26源码版
分类 : 简简单单的小Tips
正文
在UE4中, 是默认带有一个控制台的.



如图, 当我们在一个模块加载的时候, 比如游戏模块.

FConsoleManager::Get().RegisterConsoleCommand 通过这个函数去注册一个控制台命令.

此处命令是一个匿名函数, 打印一句Hello World!

然后, 就可以在编辑器界面, 调用这个命令, 执行对应的函数.


这种控制台命令, 支持多种参数形式

FConsoleCommandDelegate 无参
FConsoleCommandWithArgsDelegate 多个字符串参数
FConsoleCommandWithWorldDelegate UWorld参数
FConsoleCommandWithOutputDeviceDelegate 输出设备
FConsoleCommandWithWorldAndArgsDelegate 字符串参数加UWorld参数
FConsoleCommandWithWorldArgsAndOutputDeviceDelegate 字符串参数加UWorld参数加一个输出设备

如果这个命令不再使用的话, 则通过FConsoleManager::Get().UnregisterConsoleObject 注销掉

无论是通过IConsoleCommand 对象, 还是命令名称都可以.
</code></pre>
</details>

<details>
<summary>UE5 正计催系列 5.24号 添加Pack资源包到任意项目</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/374928724
前言
UE5 正数倒计时(催更)系列 第二十四篇
UE4 4.26源码版
分类 : 你可能不知道的冷门技巧 & 一本正经的胡说八道系列
正文

当我们一不小心建立了一个空空的项目.

为了展示我们快速, 无人能比的开发能力!

接下来, 教大家在1分钟之内, 快速完成一个第三人称模版, 并搭建一个完整的地图出来!




简简单单, 一个第三人称模版就建立完成



接下来要创建地图了, 模型, 材质, 地编, 灯光, 音效, 可麻烦了!


应用我们刚才写好的第三人称Demo


是不是很不错呢?

结语
Useless knowledge has increased again!
</code></pre>
</details>

<details>
<summary>UE5 网络相关系列 序</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/410409635
前言
鸽子精又又又又又又复活了!!!
已有完结系列, UE5 正数倒计时(催更)系列-完结撒花
所以放心, 太监是不可能太监的, 但鸽子是一定会鸽子的!
孤傲雕：UE4 网络相关系列 序 旧的UE4系列就停止更新了, 在这里重新整理引用变成新的文章了.
序
将一个单机游戏, 变成网络游戏, 可不是简简单单的将单机两个字替换成网络, 这么简单.

时序! 延迟! 丢包! 权限! 一致性! ...

每一个词汇会将简单的事情, 复杂很多, 很多, 很多.

当它们相互纠缠在一起的时候, 那就, 那就, 无法用言语形容, 就像一团毛线球硬生生塞进了脑袋一样.

随心所欲, 由浅入深(尽量), 扒扒源码, 结合多年的踩坑经验, 缓缓谈起.

导言
先从试着零建立一个网路游戏打打底, 导言八篇, 一句不提虚幻

孤傲雕：UE5 网络相关系列 导言(一)
孤傲雕：UE5 网络相关系列 导言(二)
孤傲雕：UE5 网络相关系列 导言(三)
孤傲雕：UE5 网络相关系列 导言(四)
孤傲雕：UE5 网络相关系列 导言(五)
孤傲雕：UE5 网络相关系列 导言(六)
孤傲雕：UE5 网络相关系列 导言(七)
孤傲雕：UE5 网络相关系列 导言(结)
正文目录(仅供参考)
Client-Server体系系列
孤傲雕：UE5 网络相关系列 之 再谈 ENetMode 网络模式
孤傲雕：UE5 网络相关系列 之 网络模式背后的主人UNetDriver
孤傲雕：UE5 网络相关系列 之 服务器网络连接的初始化
孤傲雕：UE5 网络相关系列 之 客户端网络连接的初始化
孤傲雕：UE5 网络相关系列 之UNetConnection初始化
孤傲雕：UE5 网络相关系列 之客户端和服务器的握手请求
Actor & Object 网络同步相关
第一章 Actor的网络同步, 创建, 管理, 销毁
第二章 Actor的同步条件, 休眠机制
第三章 Actor中SubObject的同步使用, 流程原理
RPC相关
第一章 RPC函数的反射注册相关
第二章 RPC函数的实现原理流程分析
属性同步相关
第一章 属性同步的实现原理流程分析
第二章 属性同步的场景问题
第三章 TArray属性同步如何减少网络带宽
第四章 自定义优化结构体的网络同步
</code></pre>
</details>

<details>
<summary>UE5 网络相关系列 导言(一)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/421184765
前言
孤傲雕：UE4 网络相关系列 导言 旧的鸽子系列导言
视角不同, 所见, 自不同!
序
这是一篇关于网络相关的引子.

或者说一篇UE5 游戏网络同步相关的引子.

毕竟, 游戏的网络同步要复杂很多, 也接触最广泛.

上面的话语, 是不是很熟悉? 嗯, 没错, UE4系列就说过, 现在修修补补, 拿来继续用.
一个广为流传、引人入胜的例证是：现代铁路两条铁轨之间的标准距离是四英尺又八点五英寸。原来，早期的铁路是由建电车的人所设计的，而四英尺又八点五英寸正是电车所用的轮距标准。那么，电车的标准又是从哪里来的呢？最先造电车的人以前是造马车的，所以电车的标准是沿用马车的轮距标准。马车又为什么要用这个轮距标准呢？英国马路辙迹的宽度是四英尺又八点五英寸，所以，如果马车用其他轮距，它的轮子很快会在英国的老路上撞坏。这些辙迹又是从何而来的呢？从古罗马人那里来的。因为整个欧洲，包括英国的长途老路都是由罗马人为它的军队所铺设的，而四英尺又八点五英寸正是罗马战车的宽度。

任何其他轮宽的战车在这些路上行驶的话，轮子的寿命都不会很长。可以再问，罗马人为什么以四英尺又八点五英寸为战车的轮距宽度呢？原因很简单，这是牵引一辆战车的两匹马屁股的宽度。故事到此还没有结束。美国航天飞机燃料箱的两旁有两个火箭推进器，因为这些推进器造好之后要用火车运送，路上又要通过一些隧道，而这些隧道的宽度只比火车轨道宽一点，因此火箭助推器的宽度是由铁轨的宽度所决定的。

所以，最后的结论是：路径依赖导致了美国航天飞机火箭助推器的宽度，竟然是两千年前便由两匹马屁股的宽度所决定的。

来源 - 路径依赖_百度百科
马屁股决定了火箭助推器的宽度, 那游戏的网络化, 网络同步的路径又是什么样呢?

P2P联机模式, 开房间模式, 服务器-客户端模式, 这些一个个又是怎么来的呢?

帧同步, 状态同步, 又是怎么来的呢?

网络同步中, 的重点难点到底是什么? 又为什么?

...

十万个为什么之, 自己补充!(懒得写了, 假装有删除线)

嗯, 很碰巧, 在接触网络游戏的时候, 这些概念都成了基础知识.

毕竟没有亲生经历过这些概念是如何在实际中, 被一步一步集成概况出来的.

只能简单查阅一些资料, 加上一丢丢脑洞, 试着补全一下.

如有巧合, 不甚荣幸!

如有妄言, 还请见谅!

毕竟, 皮一下, 开心就好.

起源
在文章开始前, 想问大家一个问题 问单机还是网络游戏, 哪一个先出现, 好像太简单了, 那就这个问题了:
问 : 大家觉得电子游戏单机单人游戏最先出现? 还是单机多人游戏最先出现?





思考一下.





确认吗?





真的确认了吗?





真的真的确认了吗? (题目有陷阱的哦)





现在要揭晓答案了!





现在真的要揭晓答案了, 确认选择了吗? (再思考思考, 题目有没有陷阱)



双人网球》在电子游戏历史上十分重要，被认为是用图像显示的第一个电子游戏。

《双人网球》的游戏方式为两个玩家操作控制器，在示波器的屏幕上进行模拟的网球比赛。屏幕上会显示由光点组成、侧面视角的网球场简图。画面下方的横线代表地面，中间与其垂直的直线代表网球网、空中的一个光点代表网球，画面上没有显示球拍。
如同现实中的网球，玩家必须将画面上的网球打过球网、与对手反复击打网球使其在画面左右两端来回，对手若漏接就胜利。

-- 来源 双人网球-维基百科
问 : 大家觉得电子游戏单机单人游戏最先出现? 还是单机多人游戏最先出现?

答 : 电子单机多人游戏最先出现.

很惊讶是不是? 多人游戏竟然比单人游戏更早出现?

参考被认为是电子游戏历史上第一个街机电子游戏 : 乓-维基百科

这个简单或者类似类型的游戏, 可能很多人在初学游戏制作的时候, 都跟着教程实践过.



拆分并简化一下游戏规则:

一个移动的点, 当做球
两块方形的板子, 当做球拍
球沿直线移动
球碰到上下边界墙时, 球改变移动方向
球碰到球拍时, 球改变移动方向
当球碰到左右边界墙的时候, 另一侧得分, 游戏结束
玩家可以通过两个输入键, 控制球拍移动
游戏规则背后简易的代码逻辑

移动的球, 点, 一个像素坐标, (X, Y)
边界墙, 整个屏幕的上下边界 (0, MaxY)
得分区, 整个屏幕的左右边界 (0, MaxX)
球拍, 一段线段, 如果和球坐标相同, 改变球的移动方向
球移动到边界墙或者得分区, 判断XY坐标是否在边缘值, 进行得分或者改变移动方向
玩家按键控制球拍的上下位置, +1或者-1, 移动球拍的Y轴开始位置.
整体逻辑非常非常简单, 一个双人游戏就这样出来了.

那如果是单机的呢?

嗯, 单机, 另一边就不是玩家, 是电脑了.

再添加电脑玩家的行为, 根据球的位置, 自动移动球拍.

第二代计算机出现在1950年代末及1960年代，其电路板都装有独立的晶体管和磁芯内存。
晶体管计算机-维基百科
嗯, 想想那个时候的电脑的性能, 发展阶段.

添加一个电脑玩家, 无论程序代码本身大小, 计算数据所占空间, 每帧计算所需性能, 都是一个很大的开销.

电子游戏中, 单机多人游戏比单机单人游戏先出现, 也就不奇怪了. (笑)

初生

在有了单机多人游戏之后, 玩游戏的时候, 两个人必须看着同一个显示器, 操控自己的角色.


这么小屏幕, 嗯, 人和人得靠的多近, 才能看清啊, 好急, 头经常撞在一起, 怎么办, 在线等, 很急!

问题: 两个人同时盯着同一块屏幕, 头很容易撞一起, 有解决办法吗?

换一个特别特别特别大的屏幕, 分别率不变.

玩家离屏幕距离特别远, 头就不容易撞到一起了.

额, Pass, 如果能做大早做大了.

一块屏幕太小了, 那能不能有两块, 显示一样的画面, 每个人各看各的? 嗯, 可以, 屏幕还是好处理的, 加个屏幕, 用同一份游戏机产生的视频数据线输出数据, 连接处理下就好了.


此时, 我们可以看出, 只要显示画面是一致的, 那么, 即使在同一台电脑的两块屏幕上, 玩家玩的也是一个游戏.

// 不要觉得是废话, 虽然是废话, 嗯, 怎么说呢, 就是废话, 不能当做废话, 毕竟,
// 它也是一句话
嗯, 既然如此,那么我们修改一下机器, 就可以变成这个样子


嗯, 这个游戏还是一个单机多人游戏, 但看起来是不是很像单机联机游戏了呢?

问题: 现在两个人不需要盯着同一块屏幕, 各有各的屏幕了, 但还是要在同一个屋子里面打游戏, 能不能隔得再远一点?

简单, 线拉得长一点不就可以了吗? 长度100m, 1000m的线, 够用了吧!

只是实时传输一下手柄的输入和屏幕显示的输出, 应该很容易的吧.

传输画面? 想得简单.

// 是不是和现在云游戏的概念很像, 对, 差不多
HDMI_长度限制问题_百度百科

嗯, 事实在今天, HDMI这种常见的音视频线, 长度都有一定的限制, 长度过长就会有一定的衰减.

在当初那个年代, 嗯, 基本没戏, Pass, 那个时候, 你能传送几个字节的数据了, 就不错了

// 硬件水平, 或者说科技水平, 生产力, 会制约很多很多很多想法, 没撤.
传输数据太多了? 那再省一省? 容我想想...

..

.



不想了, 推到重来.

现在是两个人, 隔得很远, 先来看看我们有些什么:

两块屏幕, 一个地方一个屏幕, 没毛病.

两个手柄, 也是一个地方一个手柄, 也没毛病.

一个游戏机, 嗯, 一个? 两个地方怎么用同一个游戏机, 除非它有两个.

等等, 我刚才说了什么? 好像找到答案了!

但我们只有一个游戏机?

不对, 不是这句!

两个地方用同一个游戏机??

不是, 等等, 我想想, 是它 : 除非它有两个, 我真是个天才, 有两个游戏机不就可以一人一个了吗!

孤傲雕：UE5 网络相关系列 导言(二)

但这两个游戏机的画面不一样啊? 说了白说.



思考 :

传输屏幕画面, 是不用考虑了, 毕竟在1202年的今天, 还是一个麻烦的问题.

再思考思考, 我们能做什么, 之前是怎么做的, 是不是之前的步骤就有问题了?

之前解决方法 : 将玩家的输入, 输入到一台游戏机, 然后将处理后的画面, 输出到两个普通的屏幕上, 这样两个人看着两个屏幕, 进行同一个游戏.
可行步骤 : 少量数据传输
可行步骤 : 添加设备, 两个游戏机
画面是由游戏逻辑实现计算得出的, 游戏逻辑的变动只受到玩家输入的影响...

..

.

也就是说画面受且只受玩家输入的影响...

..

.

也就是说, 如果一台游戏机上, 每次的玩家输入一致, 那每次的画面也一致...

..

.

也就是说, 如果两台游戏机上, 玩家的输入一致, 那两台游戏机的输出画面, 也应该一致...

..

.


这样应该是可以的, 我先去试试?

现在, 每个手柄后面有两根数据线, 一根连接游戏机A, 一根连接游戏机B, 其中一根特别特别长, 几百米, 几千米长.

然后, 我们就可以在两个屋子里面, 打一个游戏了!

至此, 一个最简单最简陋的网络同步游戏就诞生了!

此处应有掌声, 鼓掌.



问题
为什么最开始的一个屋子下, 较近的解决方案, 会优先思考并使用游戏机输出两个屏幕相同画面? 而不是像现在一样, 加个游戏机, 加个屏幕, 手柄输入到两个游戏机呢?

???



??



?





嗯, 谁TM上来就考虑添加多个设备的, 设备那么贵, 不是能省一个是一个.

再说了游戏机可贵了, 屏幕才值几个钱!

尾声

在经过了长篇的胡诌八扯之后, 再来看看, 这第一个网游, 是一个什么样的:

P2P联机方式, 每个玩家之间直接连线.(虽然只有且只能两个玩家互相连接)
即使战斗游戏, 每一次玩家输入都被即使处理.(哪来的性能去做帧限制或者其他东西)
具有划时代, 开创性的一款简约但不普通的游戏.
补充说明:

那历史上真正的第一款网游是什么样子的呢?

游戏的进行方式为两名玩家各自以杠杆及按钮操作一艘虚拟的太空船，在虚拟太空中互相发射鱼雷进行对战，直到消灭对方为止。外型较胖的太空船被称为“楔形船”（Wedge）、较细长的叫“针形船”（Needle）。玩家操控的太空船被鱼雷击中或接触画面中央的恒星就会被毁灭，太空船若太靠近恒星就会被其重力所吸引，若太空船进行超空间跳跃、会随机出现在画面的任一位置。太空船的运行轨道会显示在画面上，爆炸时会出现类似烟火爆发的效果。此游戏没有音乐及音效。 太空战争!-维基百科 第一款真正意义上的网络游戏可追溯到1969年，当时瑞克·布罗米为PLATO（Programmed Logic for Automatic Teaching Operations）系统编写了一款名为《太空大战》（SpaceWar）的游戏，游戏以八年前诞生于麻省理工学院的第一款电脑游戏《太空大战》为蓝本，不同之处在于，它可支持两人远程连线。 在20世纪60年代，RickBloome实现了Spacewar！一场关于柏拉图(PLATO)的两人游戏。 网络游戏史-维基百科
最早的网络游戏, 应该就是柏拉图(PLATO)上的SpaceWar了, 然而关于这个游戏更多的资料, 并没有找到

这款游戏的远程连线方式, 具体是什么样子, 并不清楚

按照, ARPANET阿帕网(互联网)鼻祖的年份资料等, 推断应该是一款两人联机P2P游戏, 并可能有一个简单的房间系统? 谁知道呢!

// 其实, 从这个第一款网游开始, 后面的历史数据, 游戏诞生情况, 查了不少资料.
// 参考意义有, 但, 嗯, 串不太起来
// 毕竟视频, 图片, 啥都没有, 游戏是个啥都不知道, 当初的视角和现在差那么多, 考据个毛线.
// 其次, 中间之间的经历, 这些没有记录下来的东西, 才是背后隐藏的路径依赖关系, 
// 又由于不同游戏的类型, 网络同步需求完全不同, 并不是有一条线, 直直的把所有串联起来, 简单粗暴
// 所以, 瞎扯呗.
// 认真, 就输了
</code></pre>
</details>

<details>
<summary>UE5 网络相关系列 导言(二)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/427760914
前言
上一篇文章 : 孤傲雕：UE5 网络相关系列 导言(一), 系列文章, 请逐篇阅读
好游戏当然要让更多的人的知道

在之前, 一个漫长的摸索过程中, 我们实现了一个简单的双人联机即时战斗游戏.

这么好的东西, 当然不能只有两个人知道, 一定要大幅度的推广出去.

好, 朝着三个人, 更多人的方向努力!

先来思考一下, 三个人.

三个人的话, 会变成这个样子:


人越多, 手柄所需要连接的设备越多, 这个...

一个手柄连接N台游戏机, 好像不太现实..

嗯, 看看需求

要将玩家手柄的输入事件发送到其他游戏机上面.
游戏机要收到其他玩家手柄的输入事件.
发送, 收到.

这些是省不掉的!


然后, 就是上图了, 好像很简单的样子, 只要能把中间的线连起来, 就可以了.


嗯, 就是这样! 没有什么是加一层中间件解决不了的, 如果有, 那就再加一层.

所有玩家手柄输入统一输入到一个地方 : 中转设备, 然后由中转设备, 发送到其他的游戏机上面.

这样, 如果多了一台游戏机, 只需要多两条线 :

将玩家手柄输入事件发送到中转设备
将中转设备中的其他玩家手柄输入信息接收
没毛病, 就这样, 网络设备中, 集线器诞生了!

集线器将无脑的接收信息, 并转发出去! 此时, 可以很多人很多人一起玩这个游戏了!

混乱无比的现场, 这还怎么玩?
随着中转设备 : 集线器的诞生, 这个时候, 越来越多的人知道了这个游戏, (不多, 也就5-6个人)

但场面已经混乱的无法形容了!

没有人能安心的玩完一局游戏, 你猜为什么?

因为刘一, 陈二, 张三, 李四, 王五, 赵六, 都在同时玩这个游戏.

每个人都操纵手柄, 对球拍发出不同的信号, 向上, 向下, 向上, 向下...

可怜的球拍, 同时收到好多好多消息, 根本不知道该听谁的...

大家也不知道到底是谁在操控手柄, 莫名其妙的就赢了/输了.

这可不行, 得加个限制, 同时只能有两个人操控, 一个操控左边的球拍, 一个操控右边的球拍.

盘一下逻辑 :

刘一操控左边球拍移动, 向其他游戏机发出手柄操作指令, 左手柄就被占用了
陈二接着操控手柄, 这时左手柄被占用, 默认操控右边球拍了
然后, 在陈二操控的一瞬间, 左右都有人了, 这个时候等个倒计时, 游戏就开始了
刘一和陈二对打, 嗯, 其他人只能看着, 没毛病
需要记录一下当前是谁在操作

1就是刘一, 2就是陈二, 3就是张三......

嗯, 加一台游戏机, 就加一个数字, 这个信息写死到游戏机里面.

每个人手柄发信息的时候, 带上自己的数字, 表明自己是谁.

然后, 接收到的时候处理, 游戏还没有开始, 那么占用一个位置, 开始了, 就忽略这个信息.

接下来, 大家就可以愉快的玩耍了!

顺便, 还可以在屏幕上显示, 对方的数字, 也知道谁和谁在一起玩游戏了!

我可真是个大聪明!



别人玩的时候, 自己还能观战, 不错, 不错.

游戏不错, 我也想玩
这个游戏还是很有诱惑力的, 隔壁的隔壁的隔壁的学校的校花也想玩, 但距离属实是有点远, 手柄线那么长, 信号断断续续的, 十分难受.

身为一个正经的读书人, 这个问题当然要优先解决.

我们来看看问题, 远距离传输信号的问题.

额, 我一个臭做游戏的, 解决这种物理材质问题...

好像, 没辙的样子, ┓( ´∀` )┏

不行, 不能这么简单的放弃, 再思考思考.


需求是将数据传输10000米, 但我们现在只能传输1000米, 需要提高10倍, 等材质提升的话不知道要等到猴年马月.

1次传输10000米是绝对不可能的, 多次传输还差不多.

多次?


只要我能传个1000米, 接收一下, 再传出去, 好像就可以了吧!

这个简单, 看我3-5分钟搞定.

这下, 无论多远距离的人, 都可以一起玩了! 完美!

至此, 一个新的设备就诞生了 : 中继器

等等, 那之前我们最开始的时候, 远距离传输视频的时候,为什么没想到这个方案呢?

额, 好像想到也没用, 要传视频的话, 不知道需要多少多少多少个中继器才能满足, 毕竟, 这是一个传几位bit都很麻烦的时代.

垃圾游戏, 根本不能玩, 全是别人的游戏画面
在不断地努力下, 玩家数量自然是越来越多, 现在已经突破了个位数, 来到了十位数.

然后, 就开始垃圾游戏, 垃圾游戏骂个不停了 : 机器死贵, 然后买回去一局游戏都没玩上, 全是看着别人在玩.

额, 是你手速不xing...抢不到游戏位zhi...

停, 停, t, 别打, 没说你.

现在这么多人了, 同时只能两个人玩, 确实是有点问题, 让我看看怎么优化!

前两个玩家各锁定一个手柄, 其他人就只能看着了, 也就是这样:


实际上, 当玩家AB进行游戏的时候, 玩家CD完全可以去玩他们自己的.

让我看看, 怎么修改一丢丢:

玩家AB进入, 游戏左右手柄都被占用, 存有信息A和B对局, 游戏机A和B就可以忽略掉其他所有玩家的信息了
玩家C进入, 新建一个对局, 这个对局忽略掉所有A和B的信息, 然后等一个D进来, D进来之后, C和D就是一个对局, 忽略掉其他所有信息
然后依次类推...
没毛病, 这样就可以两个人一局, 两个人一局, 各打个的了

然后当游戏结束的时候, 再次接收所有的玩家输入信息, 额, 此时又会像之前一样乱糟糟的.

那, 干脆, 让他们看一个空界面, 按下, 开始找另一个玩家, 找到了就进行游戏, 嗯, 没毛病.

现在的情况:


AB和CD各玩各的, E等个人一起玩.

完美.

推广游戏去了, 这个游戏一定大火!

十万个为什么:
问题 : 这个游戏还存在那些问题? 你能想到的和不能想到的?

问题: 这个游戏还存在那些限制? 你能想到的和不能想到的?

问题: 这个游戏还存在那些不足? 你能想到的和不能想到的?

问题: 如果更多的人, 不同地方的人, 玩这个游戏, 又会出现什么样的问题呢?

答 : 你猜!

// 慢慢水喽.

尾声

在经过了长篇的胡诌八扯之后, 再来看看, 现在这个游戏, 是一个什么样的:

P2P联机方式, 每个玩家之间直接连线.
最简单的多房间模式, 两两对局匹配对战.
即使战斗游戏, 每一次玩家输入都被即使处理.
然后呢, 我们也"发明"了两种基础的网络设备 : 中继器和集线器.

接下来, 这么好玩的游戏, 将迎来更多的玩家, 也会接受到更多的挑战!
</code></pre>
</details>

<details>
<summary>UE4 自定义图片上, 画上文字, 并保存Asset资源</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/429074230
前言
UE4版本4.26
这篇不属于任何系列文章诞生的原因, 嗯, 上次UOD过去快一年了, 然后, 懂得都懂
正文比较啰嗦, 习惯就好.
毕竟, 解决问题的思路, 步骤, 比答案, 往往更重要.
正文
需求 : 文字转图片

目的 : 批量, 大规模生成图片, 提前占位

其他用途 : 批量处理指定图片, 进行一定的加工

老生常谈的话题, 程序化自动生成, 只是一个文字转图片, 然后保存资源, 网上那么多教程, 简单的很!

在图片上添加文字, 随随便便一个编程语言, 自带的图像处理库, 都可以轻轻松松的完成.

先找一找UE4怎么在图片上画文字, 之前还没碰过.

从哪里开始找呢? 百度谷歌一下 : ue4 draw text on the texture

Draw Text on a texture-UE4 Answer Hub

Render Text on texture-UE4 Answer Hub

找到解决方案了.

用FCanvas就可以在UTextureRenderTarget2D上添加文字了, 然后导出图片, 或者直接处理保存成UAsset就可以了.

// .h
UFUNCTION(CallInEditor)
void CreateTextureAssetSimple();
// .cpp
void AMyActor::CreateTextureAssetSimple()
{
	UTextureRenderTarget2D* RenderTarget = UKismetRenderingLibrary::CreateRenderTarget2D(this, 256, 256);
	UKismetRenderingLibrary::ExportRenderTarget(this, RenderTarget, TEXT("D://"), TEXT("a.png"));
}
随便建立一个A类, 然后添加一个CallInEditor(UFunction修饰符)

将这个类, 直接拖放到任意场景中, 就可以看到一个可点击的按钮, 按下就会执行对应函数.


UKismetRenderingLibrary中的CreateRenderTarget2D和ExportRenderTarget 两个帮助函数, 可以创建和导出RenderTarget2D, 十分好用

点击按钮, 尝试一下, 去找一下导出的图片.

打不开? 无法显示...


打断点, 逐步执行, 看一下内部实现, 在ExportRenderTarget导出函数中, 走到了导出EXR???


而导出PNG类型的函数里面, 需要格式PF_B8G8R8A8, 格式不对...

创建CreateRenderTarget2D函数中的枚举中, 和它最像的就是ETextureRenderTargetFormat::RTF_RGBA8

// 图片文件格式, 深究的话, 自行找文章, 嗯, 与本文无关
UTextureRenderTarget2D* RenderTarget = UKismetRenderingLibrary::CreateRenderTarget2D(this, 256, 256, RTF_RGBA8);
修改后, 再试一下, 一张纯黑的图片就诞生了.

UTextureRenderTarget2D* RenderTarget = UKismetRenderingLibrary::CreateRenderTarget2D(this, 256, 256, RTF_RGBA8);

// 绘制文本内容
const FString SimpleContent = TEXT("世界你好");

// GMaxRHIFeatureLevel 直接编译会报错, 所以替换成实际值ERHIFeatureLevel::SM5
FCanvas Canvas(RenderTarget->GameThread_GetRenderTargetResource(), nullptr, 0.0f, 0.0f, 0.0f, ERHIFeatureLevel::SM5);
// 清除整个画布, 底色白色(将这个图片变成白色)
Canvas.Clear(FLinearColor::White);

// UFont是字体指针, 可以使用自己的, 这里偷懒, 就用引擎的了
FCanvasTextItem txtItem(FVector2D(0.0f, 0.0f), FText::FromString(SimpleContent), GEngine->GetMediumFont(), FLinearColor::Black);
// 画一个Item, 这里是一个文本Item
Canvas.DrawItem(txtItem, FVector2D(0, 0));

// 在游戏线程, 强制刷新
Canvas.Flush_GameThread(true);

UKismetRenderingLibrary::ExportRenderTarget(this, RenderTarget, TEXT("D://"), TEXT("a.png"));

GMaxRHIFeatureLevel 直接编译会报错, 所以跳转一下, 替换成ERHIFeatureLevel::SM5

然后, 编译, 运行:


是不是简单极了? 调整一下每个字符的位置, 大小, 尺寸, 然后

// 使用FSlateFontInfo, 需要导入SlateCore模块, 然后可以定义字体的大小
// 编译的时候, 链接失败, 缺少模块的时候, 跳一下结构体/类的头文件, 打开文件夹路径
// 目录一层一层向上找到.build.cs文件, 添加到项目的.build.cs对应位置就可以了
const FSlateFontInfo SlateFont(GEngine->GetMediumFont(), 50);
FCanvasTextItem txtItem(FVector2D(0.0f, 0.0f), FText::FromString(TEXT("世界")), SlateFont, FLinearColor::Black);
Canvas.DrawItem(txtItem, FVector2D(0, 0));

FCanvasTextItem txtItem2(FVector2D(0.0f, 0.0f), FText::FromString(TEXT("你好")), SlateFont, FLinearColor::Black);
Canvas.DrawItem(txtItem2, FVector2D(0, 128));

好了, 画文字, 我们实现了, 接下来是保存成UE4 Asset资源了.

BearChild：[UE4] 读取与导出本地图片
嗯, 参考一下现有的文章, 还是很简单的, 就懒得长篇大论描述了, 毕竟, 现成的东西摆着呢!



// 源于https://zhuanlan.zhihu.com/p/402087676 BearChild
// 微调
UTexture2D* CreateTexture(const FString& PicturePath, const FString& ImageName, const FString& PackageDir)
{
    UTexture2D* Texture = nullptr;

    if (!FPlatformFileManager::Get().GetPlatformFile().FileExists(*PicturePath))
    {
        return nullptr;
    }

    const FString PackageName = PackageDir + ImageName;

    // Read loacl PNG to Texture

    TArray<uint8> RawFileData;
    if (!FFileHelper::LoadFileToArray(RawFileData, *PicturePath))
    {
        return nullptr;
    }

    IImageWrapperModule& ImageWrapperModule = FModuleManager::LoadModuleChecked<IImageWrapperModule>("ImageWrapper");

    TSharedPtr<IImageWrapper> ImageWrapper = ImageWrapperModule.CreateImageWrapper(EImageFormat::PNG);

    if (ImageWrapper.IsValid() && ImageWrapper->SetCompressed(RawFileData.GetData(), RawFileData.Num()))
    {
        TArray64<uint8> UncompressedRGBA;
        if (ImageWrapper->GetRaw(ERGBFormat::BGRA, 8, UncompressedRGBA))
        {
            int32 SizeX = ImageWrapper->GetWidth();
            int32 SizeY = ImageWrapper->GetHeight();
            const EPixelFormat PixelFormat = PF_B8G8R8A8;
            int32 PixelSize = SizeX * SizeY * GPixelFormats[PixelFormat].BlockBytes;

            if (SizeX > 0 && SizeY > 0 && (SizeX % GPixelFormats[PixelFormat].BlockSizeX) == 0 && (SizeY % GPixelFormats[PixelFormat].BlockSizeY) == 0)
            {
                // Create new texture pointer           
                UPackage* TexturePackage = CreatePackage(nullptr, *PackageName);
                TexturePackage->FullyLoad();
                Texture = NewObject<UTexture2D>(TexturePackage, FName(*ImageName), RF_Public | RF_Standalone | RF_MarkAsRootSet);

                Texture->PlatformData = new FTexturePlatformData();
                Texture->PlatformData->SizeX = SizeX;
                Texture->PlatformData->SizeY = SizeY;
                // Texture->PlatformData->NumSlices = 1;
                Texture->PlatformData->PixelFormat = PixelFormat;

                // Determine whether it is a power of 2 to use mipmap
                if ( (SizeX & (SizeX - 1) || (SizeY & (SizeY - 1))) )
                    Texture->MipGenSettings = TextureMipGenSettings::TMGS_NoMipmaps;

                // Allocate first mipmap.
                FTexture2DMipMap* Mip = new FTexture2DMipMap();
                Texture->PlatformData->Mips.Add(Mip);
                Mip->SizeX = SizeX;
                Mip->SizeY = SizeY;

                // Lock the texture so that it can be modified
                Mip->BulkData.Lock(LOCK_READ_WRITE);
                uint8* TextureData = (uint8*) Mip->BulkData.Realloc(PixelSize);
                FMemory::Memcpy(TextureData, UncompressedRGBA.GetData(), PixelSize);
                Mip->BulkData.Unlock();

                Texture->Source.Init(SizeX, SizeY, 1, 1, ETextureSourceFormat::TSF_BGRA8, UncompressedRGBA.GetData());
                Texture->UpdateResource();

                // Create Assets
                TexturePackage->MarkPackageDirty();

                FAssetRegistryModule::AssetCreated(Texture);

                FString PackageFileName = FPackageName::LongPackageNameToFilename(PackageName, FPackageName::GetAssetPackageExtension());

                UPackage::SavePackage(TexturePackage, Texture, EObjectFlags::RF_Public | EObjectFlags::RF_Standalone, *PackageFileName);
            }
        }
    }

    return Texture; 
}
​
// 最后资源引用路径 Texture2D'/Game/textures/Test.Test'
// Test						资源名称
// /Game/textures/			资源的储存Package路径
// /Game/textures/Test		资源的储存Package名称
CreateTexture(TEXT("D://a.png"), TEXT("测试"), TEXT("/Game/textures/"));

然后, 中间加一些For循环遍历啊, 读UE4的DataTable表啊, 中间也可以通过FCanvas画画材质, 几何等等, 对现有纹理加工, 等等, 都可以.

就可以, 批量的, 自动生成一大堆图片资源了.

其实, 这个函数可以关联UE4 的命令行相关实现, 外部调用一个命令, 一键执行, 嗯, 什么时候想起来再水文章喽.

正文(伪)

真实的解决问题的步骤, 怎么会这样简单...

百度谷歌, 查到一大堆零零散散的东西, 不过绕来绕去, 都没有完整的教程, 都是零散的几个函数, 然后用Rider全局搜索一下, 嗯, UCanvas::DrawText, 这个很眼熟, 应该就是它了!

多找找几个调用的地方, 看一下传参:



字体, 内容, 位置, 尺寸, 渲染信息

UEngine内部还有一个GEngine->GetSmallFont, 那就直接拿他的字体了


于是, 我们就得到了如上代码, 画文字的我们实现了, 但这个Canvas怎么变成图片, 或者纹理?


然后又全局搜索UCanvas的引用, 排除一些乱七八糟的, 看到眼熟的UKismetRenderingLibrary


又在UKismetRenderingLibrary::DrawMaterialToRenderTarget里面, 看到了K2_DrawMaterial

嗯, 相同操作, 把DrawMaterial换成DrawText就可以了.

其他一行有关RENDER_COMMAND都没敢动, 全部Ctrl+CV

Canvas->DrawText(GEngine->GetMediumFont(), SimpleContent, 0,0, 10, 10);
然后, Canvas的DrawText, 画出来的文本, 是模糊的...

查了查这个函数的相关使用, 发现传的是FSlateFontInfo

const FSlateFontInfo SlateFont(GEngine->GetMediumFont(), 50);
FCanvasTextItem txtItem2(FVector2D(0.0f, 0.0f), FText::FromString(TEXT("你好")), SlateFont, FLinearColor::Black);
Canvas->DrawItem(txtItem2, FVector2D(0, 128));
接着, 代码变成了这个样子.

嗯, 功能反正是实现了.

最后, 在写文章的现在, 谷歌发现上面两个直接告诉你答案的回答, 并且当初还看过, 眼熟了Canvas,

(╯‵□′)╯︵┻━┻
</code></pre>
</details>

<details>
<summary>UE5 网络相关系列 导言(三)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/428251358
前言
上一篇文章 : 孤傲雕：UE5 网络相关系列 导言(二), 系列文章, 请逐篇阅读
随着房间模式的实现, 这个网络游戏, 迎来了井喷式的发展!

现在已经有40-50人在玩这个游戏了!

趁热打铁, 我们再修复一些已知的bug, 优化下性能, 再试着降低一下硬件价格.

嗯, 一定会受到更多的玩家欢饮, 游戏一定会更加热闹!

五十人大关
不出所料, 越来越多的人在慢慢加入近这个游戏.

但! Bug, 不, But, 好像, 我们的集线器支撑不住了!

那个集线器已经开始冒烟了! 噼里啪啦, 哦, 不对, 是已经烧坏了.

赶紧更换一个, 嗯, 硬件质量问题, 没事.

隔天, 又一个集线器报废了...

...

..

.

一定是有什么地方不对


现在, 有100台设备了, 当手柄A发出信息的时候, 经过集线器, 发给其他所有的设备.

所有??? 为什么是所有的???

当A和B进行游戏的时候, A发生给B, B发送给A不就可以了吗?

...

这种无脑广播的集线器, 满足不了需求了, 该淘汰了.

现在需要一个更高级点的玩意, 我告诉他给谁发, 他就给谁发!

然后, 理一下 :

匹配的时候, 还是群发, 去找一个玩家.
游戏进行的时候, 记录一下对局信息, 两两点对点通讯就够了.
就这么办.

经过1-2天的折腾, 新的网络设备 : 交换机 , 他相比集线器而言, 可以提供点对点的通讯.

我们还是定制版本, 更高级, 更智能 : 他可以存一个对局列表, 如果在列表中, 他会点对点的传输数据, 如果不在, 仍然转发给其他所有玩家!

嗯, 现在绝对没问题了.

拷贝问题

随着设备越来越多, 越来越多, 现在每添加一台设备都很麻烦, 这才添加了40-50台, 以后成百上千台可怎么办?

嗯, 未雨绸缪, 为了以后成百上千台的时候, 维护起来方便.

我们要复盘并优化一下, 并开始提前考虑以下, 以后会有什么问题了.

现在新加一台设备, 要做的操作:

操作一 : 准备一台新的游戏机, 新的屏幕, 新的手柄.

省不了, 没辙

操作二 : 一根手柄连接交换机的长长的线, 交换机还要有空的插口, 现在一个交换机插口, 嗯, 定制的, 150个, 暂时够用...

然后就是交互机了, 这么些插口, 绝对不够用的, 但, 好像没有什么好办法.

只能定制硬件, 做更大的插口,300个插口, 麻烦是麻烦点, 复制粘贴的, 但还是能做的.

再往上的话, 嗯, 慢慢考虑, 兴许, 什么时候灵感就来了呢.

操作三 : 每个游戏, 在程序里面写死玩家ID序号, 确保唯一, 然后重新编译, 生成游戏包体, 以及手柄中的固件


目前来看, 这个打包有点麻烦, 多一个玩家, 要改一下ID, 打一次包, 改一下ID, 打一次包.
如果这个ID可以在打包后动态的修改就可以了...

等等, 他不就是一个int8大小的数字, 能存250多个, 不对, 用int16吧, 嗯, 6万多, 绝对够用了.

然后, 试着把他在打包后固件中的位置固定, 然后, 每次修改这个位置不就可以了吗?


这样, 打包后还能动态修改这个值, 以后还可以修改一些其他东西, 不错, 感觉又是一个大突破.

// 一大堆看起来废话, 实则废话.
// 这个, 大致就当做最早的配置的雏形了
百人大关
一百个人了, 在经过怎么久的努力之后, 在我们突破式的发明了 : 中继器, 集线器, 交换机之后, 在这么长时间, 不留余力的bug修复, 游戏机维护下, 终于有一百个人在玩我们的游戏了!

为了庆祝这个日子, 我决定, 举办一场游戏竞技比赛, 从明天开始, 到下下周末, 为期两周14天, 在这个时间内, 每赢一场, 得一分, 总分靠前的将有奖励!

好耶, 好耶!

大家回去练习游戏了!

然后, 徒留一人孤影成双... 为着这个活动而头疼.

牛皮已经吹上天了, 但这个分数怎么记录啊? 现在传来传去的数据, 只有一个手柄按键信息 上或者下, 1bit, 手柄信息带了一个玩家ID, 16bit

这信息还是手柄发出去的.

遇事不决, 先复盘, 我们有什么:

游戏机 : 接受其他玩家输入事件, 更新玩家逻辑的
屏幕 : 接收游戏机的输出画面的
手柄 : 带有一个可编辑的16bit玩家ID, 然后通过线或中继器一起, 将信号传送给交换机或者淘汰的集线器的
集线器 : 会接受所有玩家的输入事件, 在接受到玩家的输入事件, 然后无脑的广播出去
交换机 : 会接受所有玩家的输入事件, 会记录一个对局信息, 对局中的玩家, 两两直接通讯, 其他情况, 玩家的输入事件, 还是广播出去
首先, 我们必须得能发出一个信号, 这个信号是玩家胜利, 需要一个玩家ID

但胜利是在游戏机的逻辑处理后的, 发信息是在手柄线上.

这个消息肯定是从游戏机逻辑上判定的, 然后, 再通过手柄连接交互机的线发送出去.

不, 这个时候, 这条线就不是单纯的手柄线了, 再把这条线, 和收信息的线, 统一到一起, 这么多线连在一起, 成了一张大网, 那单独的一根, 就叫网线吧!


发信息最后处理收信息最先处理的地方, 也可以单独取个高大上的名称, 它可是最大的功臣.

叫网什么呢? 网络控制器, (Network Controller), 不, 网络调度设备! 高大上.

// 这个设备其实就是, 网卡, Network Interface Controller, 后文就直接叫网卡了
然后, 现在我们可以发送一个游戏胜利的消息了, 为了和玩家输入作区分, 这个时候, 玩家ID在前面, 后面不跟任何信息, 而玩家输入信息时上下1bit加上玩家ID16bit.

区分很简单, 判断是不是16bit就可以了.

游戏胜利的逻辑, 会同时在两台游戏机上面, 发生, 那我们只让胜利那一台主机发就可以了.

然后这个信息呢, 我再专门写个程序接收记录一下, 就可以了.

这个程序, 就叫, 排行榜服务器, 但交换机收到这种信息的时候, 只让他给这台游戏机发就好了.

这个排行榜, 就占用00的位置吧, 我之前00位置的游戏机, 就再分配一个新ID玩了.

再思考思考, 没毛病.

不过这次的设备调整有点大, 不多说了, 调整设备, 更新设备去了


尾声
在经过了长篇的胡诌八扯之后, 再来看看, 现在这个游戏, 是一个什么样的:


P2P联机方式, 每个玩家之间直接连线.
最简单的多房间模式, 两两对局匹配对战.
即时战斗游戏, 每一次玩家输入都被即时处理.
有一个游戏机, 专门用来记录玩家的得分情况, 排名服务器
然后呢, 我们又"发明""发现"了几种基础的网络设备 : 交互机, 网卡, 网线

接下来, 比赛开始, 谁会笑到最后, 最终夺冠呢?
</code></pre>
</details>

<details>
<summary>UE5 网络相关系列 导言(四)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/438672426
前言
上一篇文章 : 孤傲雕：UE5 网络相关系列 导言(三), 系列文章, 请逐篇阅读
异常数据(一)
现在是比赛的第一天, 参与人数特别多, 玩家特别积极, 看起来, 嗯, 一切都很正常的样子.

那我们来看一看排行榜 :

张三 201
李四 193
王五 185
...
不对啊, 这才开始一个上午, 怎么会有这么多场胜利.

9点到12点, 过了三个小时, 1场游戏平均也得1分钟吧!

哪怕不停的赢也才应该60*3=180胜场吧, 200场? 还很多? 什么问题?

不行, 我得赶紧查一查, 怎么查呢, 嗯, 嗯 :

胜利方, 发送胜利场次的时候, 加上对手, 32bit, 自己ID在前, 对手ID在后
失败方, 发送也失败场次, 加上对手, 32bit, 对手ID在前, 自己ID在后
这样, 32bit, 我们就得到了一整个对局信息, 并且胜利法和失败方, 各发送各的信息, 互相对照一下, 还能防止作弊.

玩家操控信息还是17bit(方向1bit+玩家ID16bit), 也能区分开

嗯, 这个好改, 今天下午改完, 晚上发布出去!

. . .

. .

.

在第一天比赛结束的时候, 排行榜数据被清空, 新的游戏版本更新, 主办方推迟了游戏比赛.

嗯, 由于不可知的技术问题, 现在帮排行榜的数据异常, 无法准确的统计数值, 所以, 我们先试比赛三天? 这个时间将修复掉绝大多数的bug, 给玩家一个友好的体验!

玩家们嘘声一片片...

小声逼逼 : 要不是只有你家这一个游戏, 谁TM玩...

异常数据(二)
现在是正式比赛的第二天, 不, 试比赛的第一天中午.

现在我们看一下排行榜:

名称	姓名	胜	负
1	张三	225	62
2	李四	203	79
3	王五	195	102
4	...		
5	...		
...	...		
X	某某	3	1053
这个 "某某", 嗯, 给你打个码, 嗯, 赢了几场, 输了1053场, 平均10s输一场, 你就是游戏开始后就不动了吗?

去他家看看实际情况, 警告一下:

结果某某压根就没在玩游戏, 嗯, 据他说 : 比赛开始后, 输了几把后, 就砸手柄, 然后, 手柄一扔, 就不管了.

结果手柄的上方向键被卡住, 一致是按下的状态, 嗯, 会不断的进行匹配, 然后在比赛开始的时候, 一直向上移动, 几乎白给.

嗯, 手柄按钮一直按下, 移动没毛病, 这里还能匹配, 就有点糟糕了.

那匹配得改一下, 按下, 弹起, 按下, 弹起.

那开始游戏改成上或下按钮, 连续快速的按下弹起按下弹起两次, 嗯, 这种问题就不会发生了.

下午修复, 晚上再更新一版, 然后又又清空一次排行榜!

异常数据(三)
现在是比赛试比赛的第二天, 我们再来看一看排行榜:

名称	姓名	胜	负
1	张三	123	62
2	李四	10	79
3	王五	85	102
4	...		
5	...		
嗯, 现在看起来正常多了,前几平均一分钟一场, 数据还算正常.

我们看一下总计 : 胜场 8765, 负场8712

? ? ?

? ?

?

这凭空的胜场53哪来的?

8	X宅	53	0
X宅 这个数据不太对, 胜利53场, 一场没输, 这个技术宅不会在刷场胜利数吧!

还小规模小规模的刷, 可惜道高一尺, 数据还计算了你的败场, 这就不知道了吧!

这么明显的数据, 傻子都知道有问题.

看看他怎么刷的数据:

32bit(X宅编号 编号15)
32bit(X宅编号 编号17)
32bit(X宅编号 编号23)
32bit(X宅编号 编号23)
32bit(X宅编号 编号23)
32bit(X宅编号 编号23)
32bit(X宅编号 编号23)
嗯, 赢了23号50次, 我信你个大头鬼

编号23号总共场次才5场, 你这50场怎么赢的啊! !

光接收一个人的信息, 记录是不可能的, 这个场次两边信息对应一下, 都接收到, 才算, 一个记录信息不算.

单个玩家是不可信的, 两个都这样, 总应该是对的吧!

对吧, 像X宅这种玩家绝对是少数的吧!

嗯, 这个更新下排行榜的逻辑就可以了, 中午改好中文更新, 很快, 晚上还可以再看一版数据看一下, 嗯, 又又又清空排行榜了!

异常数据(四)
今天晚上前几数据, 看起来都很正常, 总计也对上了, 再来看看这个X宅.

X宅 胜场 58 负场 0

这个数字, 感觉代表了什么, 嗯, 他又是怎么刷的:

32bit(X宅编号 编号23)
32bit(X宅编号 编号23)
...
En? 还是赢得23???

编号23 胜场 5 负场 60

那个, 嗯 , 他破解了, 他知道了, 他也发了一条编号32 X宅编号的负场编号.

估计是蒙出来的, 编号32位代表胜利, 还是两个ID, 反过来失败, 还是比较好猜的.

这个胜负信息对的上, 但这个场次是不存在的, 他们没有匹配到一起, 对, 匹配信息

我把谁和谁匹配在一起也记录一下.

现在 匹配信息是动态产生的, 可靠的, 他没法修改发出的, 加上两边玩家的胜负信息, 他怎么发也没用.

嗯, 很可靠, 防作弊能力很强.

只有自己产生的数据才是可靠的, 玩家的, 像这种X宅的, 都有可能出问题

防作弊系统有了, 新蜂(New Bee)
今晚熬个夜, 修改掉, 不需要修改玩家主机, 更新版本, 好弄得很!

然后又又又又清空一次排行榜.

异常数据(五)
今天是试比赛的第三天中午, 最后一天了, 绝对不能再有什么幺蛾子了!

看一看数据, 前几名, 问题不大, 总胜负场次??

胜场比负场多了114场. 嗯, 看看X宅, 58场, 还是这个微妙的数字.

114-58 = 56, 估计前2场是凭本事赢得, 然后, 又发现规律, 后面就是作弊了.

匹配, 发送胜利信息, 下一场.

然后对面看到的是一没有操作送分的对方, 轻松胜利

这, 怎么防? ? ?

? ?

?

要不, 我们收拾X宅一顿? 不, 这样显得不太友好.

那么, 封掉他的账号, 他的胜场负场概不记录

封号系统也有了, Perfect!
然后又又又又又清空一次排行榜.

正常数据(一)
在经过了三+一天这么久的测试后, 最后一天下午的数据, 看起来十分正常, 烦人的X宅也没有再出现在排行榜上!

虽然, 嗯, 每个小时进行场次在不断的减少, 但是不要怕, 明天比赛开始, 一切都会恢复的!

尾声
在经过了长篇的胡诌八扯之后, 再来看看, 现在这个游戏, 其实没有什么改变, 修复了一些操作缺陷.

只是多了一个排行榜服务器, 对数据进行了一定的收集, 添加了一丢丢的防作弊系统和账号封禁系统.

这种防作弊和排行榜的修改, 不需要更新玩家主机, 真好, 简单方便, 如果玩家的游戏版本升级也这么容易就好了!

对X宅这种不当人的玩家进行一种合适的管理, 嗯, 没毛病.
</code></pre>
</details>

<details>
<summary>UE5 Hello World!</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/443330696
前言
嗯, 由于各种各样的原因, 嗯, 到现在还没写过一篇真正和UE5有关的文章
// 隔壁网络系列, 写序写了两个多月....
所以, Hello World! UE5我来了


尾言
水完收工, 简单干脆



序
好吧, 还是要有点东西, 今天这篇文章的主旨, 就是如何Hello World!

为了避免过渡炫技, 不过于复杂, 以下所有的实现效果, 都是二进制版本的UE5, 并尽量使用其比较简单的形式.

同一种方式尽量只使用一次, 嗯, 尽量(笑)!

欢迎补充!

基础篇



新建一个HelloWorldProject的C++项目


得到一个HelloWorldProject游戏模块, 然后就可以, 可以, 尽情的, 自在的, Hello World 了!




一个HelloWorld蓝图类继承C++HelloWorld基类

C++中定义一个HelloWorldLog的日志类型, 并在HelloWorld函数中打印HelloWorld.

蓝图调用C++HelloWorld实现并扩展, 打印调试字符串HelloWorld.




将这个HelloWorld蓝图类放到场景M_HelloWorld中, 会得到LableName为BP_HelloWorld的HelloWorld对象.

这个对象实例有一个根组件叫做HelloWorldComp

在细节面板的HELLOWORLD分类下有一个编辑器可调用的HelloWorld函数和一个值为HelloWorld的HelloWorldString属性变量.

在运行之后, 在游戏窗口(Title带有HelloWorldProject)中.

HelloWorld对象的BeginPlay调用HelloWorld函数并输出调试日志:


HelloWorldLog分类记录HelloWorld日志信息.

BP_HelloWolrd_C_1打印HelloWorld并且中显示Hello World!

是不是很HelloWorld!

Hello!

World!

编辑器扩展篇

创建一个EditorMode的HelloWorldPlugins插件, 然后如下图修改一丢丢的代码, 就可以各种HelloWorld了!



在ToolBar中添加一个按钮(Icon没给, 所以看起来很奇怪)

点击按钮, 弹出HelloWorldPlugins的 Toolkit(工具箱)界面

这个界面包含一个HelloWorld按钮


点击弹窗 : Wait : Hello World!


伴随着进度条, 逐步等待到Hello和World, 变成HelloWorld.


最后在右下角弹出HelloWorld!

完成!

Hello!

World!


左边这个位置当然也不能放过, 嗯, 扩展整个大的按钮有点小麻烦, 要继承扩展类什么的, 没有默认模版写起来太多了, 就简单一个按钮吧(右边Setting同理):



在FHelloWorldPluginsModule::StartupModule中添加上述代码即可

关键字LevelEditor.LevelEditorToolBar, 全局搜索一下, 嗯, 怎么扩展, 有哪些扩展位置.找着抄就知道了.

是不是很简单啊!

资源类型扩展

首先我们定义一个UHelloWorldObject, 然后我们就有了一种UHelloWorldObject资源类型



UHelloWorldFactorys使得我们可以创建UHelloWorldObject


FAssetTypeActions_HelloWorld又是这个资源的显示和操作编辑接口


当然, 还是要在HelloWorldPlugins入口处, 注册一下FAssetTypeActions_HelloWorld

注 : 这三个类创建在HelloWorldPlugins模块中
然后, 我们就可以:


在内容浏览器右键创建HelloWorld资源类型资源


这个资源默认名称为HelloWorldObject并且带有描述 : Hello World Object Desc : HelloWolrd


在HELLOWORLD分组下, 它有属性HelloWorld, 值为HelloWorld, 这个属性值是在创建的时候, 动态设置过去的.

嗯, 很HelloWorld!

Hello!

World!

蓝图扩展篇
然后呢, 蓝图节点也是少不了的:



一个最最基础的蓝图函数库节点








然后, 来个异步节点也很简单吧!



一个Hello? World? 最终执行线像薛定谔的猫一样, 不可预测的HelloWorld异步节点就诞生了








然后, 嗯, 再自定义一个蓝图节点不过分吧!






如上图代码, 嗯, 一个HelloWorldNode就诞生了, 虽然中间还去找了下UHelloWorldBPLibrary::HelloWorldFunc2函数, 实现不太优雅, 但, 真的很简单易懂(手动狗头)


最后贴一张HelloWorld的蓝图节点全家福!

Hello!

World!


</code></pre>
</details>

<details>
<summary>UE5 网络相关系列 导言(五)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/444131557
前言
上一篇文章 : 孤傲雕：UE5 网络相关系列 导言(四) 系列文章, 请逐篇阅读
正常数据(二)
正式比赛正式开始, 玩家们的热情超乎想象, 嗯, 现在开始一个小时, 数据一切正常:

名称	姓名	胜	负
1	张四	85	12
2	李三	83	19
3	赵五	75	22
4	...		
5	...		
...	...		
50	某某	0	10
正常数据(三)
现在是第一天的中午, 数据一切正常, 嗯现在已经有八十个人参与进这场比赛了!

正常数据(四)
现在是第一天的深夜, 数据一切一切都很正常, 现在有一百二十个人参与进这场比赛了!

正常数据(五)
现在是第二天的深夜, 数据还是很正常, 白天新安装了不少设备, 都预约到明天了.

嗯, 明天晚上应该就能有一百五十人参与进这场比赛了!

之前测试三天的付出都是值得的!

推迟正式比赛是值得的!

值得的!

异常数据(六)
现在是第三天的深夜, 有一百五十人参与进这场比赛中了, 可喜可贺.

就是数据有点小问题, 正负场次和总场次对不上, 有点美中不足了, 额.

赵三和刘五两个人对战了一场, 正常匹配到的, 场次记录有的, 结果两个人都赢了, 这可奇了个怪.

看起来也不像作弊的样子, 想不出为什么.

异常数据(七)
现在是第五天的深夜, 白天忙碌于安装新的设备, 晚上则在思考, 这个异常数据怎么回事?

现在有七场对局, 都是类似的样子嗯, 五场两边都胜, 一场两边都负...

不是玩家作弊, 那会是哪里的问题.

容我想想, 之前好像有过这样的情况.

记得, 那是,

那是.

哦, 对, 在那个X宅出没的日子里, 出现过胜场比负场多了114场的情况.

是X宅作弊直接胜利, 然后没有操作, 对面打一个木头人, 自然也是胜利.

嗯, 如果是类似情况的话, 一边胜利了, 但另一边并没有输, 还在继续游戏, 对着一个发呆的球拍, 很轻松的获得了胜利, 然后就有了一场, 两边都是赢家的场次.

嗯, 那两边都负, 就是连木头人都打不过了, 五场胜, 两场负, 好像也是啊, 手残的毕竟少数, 木头人还是打得过的!

那为什么会这样呢?

? ? ?

? ?

?

为什么这样子. . .

这样子. . .

为什么这样子, 你拉着我说你有些犹豫. . .

好像, 串台了...

异常情况(一)
现在是正式比赛第六天, 安装完新设备回家的路上, 碰上了陈七.

陈七这小子, 可是一个大客户, 买了两台设备, 城里一台, 乡下一台.

我 : "陈七, 游戏怎么样? 你现在胜率好像是个百分之六十来着."

陈七 : "是63.25%, 你一个数学专业的, 对数字这么不敏感!"

陈七 : "前两天回乡下了, 现在才回来. 如果不会乡下, 胜率绝对不会从70%掉下来.

陈七 : "你说也奇怪, 总感觉哪里有问题, 同样的设备, 同样的游戏, 在乡下打, 比在城里容易输多了."

我 : "能有什么问题, 也就距离远一点, 拉了一根更长的线, 还有其他不同? 能力不行怨设备."

我 : "等等, 好像你昨天有场对战有问题, 就那个, 那个, en, 你和那个, 叫, 对, 张四, 就排名第二那个, 还有印象吗?"

陈七 : "张四, 有啊, 昨天打的不多, 但他那场还记得, 就和他打了一场, 战斗十分激烈, 鏖战了很久, 难舍难分, 最后惜败于我! 我是不是很厉害!"

我 : "得了吧, 对方是不是最后傻呆呆的不动, 让你随便打的!"

陈七 : "是, 我都奇怪了. 不对! 你怎么知道的."

我 : "GM吗, 啥能不知道. 先走了, 好像发现了什么, 我需要静静, 嗯, 静静."

陈七 : "静静? 静静说她下午要去商场购物, 那里估计能找到她. 喂! 你往反方向走干什么? 奇怪的人"

Think...
T.

H.

I.

N.

K.



Crash!



Re Try. . .

Re. . .

T.

R.

Y.



Fatal error!!!

. . .

.

.

Restart failed!

脑袋混乱
现在是正式比赛第六天晚上八点十分, 明天就是第七天, 一周就结束了, 然后这个问题, 毫无头绪.

现在有十三场场次出问题了, 算上陈七那场, 嗯, 大致可以验证, 是和X宅作弊后的效果一致.

但到底为什么呢?

呐, 问你呐? 为什么?
</code></pre>
</details>

<details>
<summary>UE5 网络相关系列 导言(六)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/444382710
前言
上一篇文章 : 孤傲雕：UE5 网络相关系列 导言(五) 系列文章, 请逐篇阅读
奇怪的问题找到了
现在是正式比赛的第七天, 也是一个周日, 礼拜天.

今天不能出门去布置新的设备了, 要好好测试找到这个问题, 为什么会这样子...

陈七在乡下有一场异常情况, 嗯, 城里, 乡下, 也就网线拉得长一点.

那我拉一条特别特别长的网线, 模拟一下, 是不是和它有关. 说干就干!

等等, 记得, 好像网线过长无法传输了, 需要添加中继器, 对信号进行一次转发.

我想想, 乡下到城里, 好像大概经过了六个? 还是七个中继器来着...

不管, 拉上十个中继器, 拉长点网线, 就这样了.

测试开始 :

第一场, 一切正常.

第二场, 同样.

第三场, 没有任何变化.

. . .

第N场, 嗯, 出问题了, 对面没反应了, 赢了.

看看场次记录出问题了, 我赢了一场, 对面败了. . .

. . .

巧合, 估计对方有事离开了. . .

继续

第N+X场, en, 又出问题了, 对面没反应了, 赢了.

看看场次记录出问题了, 对面也赢了. . .

猛地一愣, 刚刚最后发生了什么, 容我想想, 记下来.


最后一球, 接的非常惊险, 按着按钮向上移动球拍, 几乎插边而过.

然后, 对面就发呆不动了.

嗯, 最后接的这个球有问题, 这个比较极端的球, 我这边接到了, 但对面没有接到.

对面发现我没有接到, 赢了, 然后我这边, 对方不动了, 也赢了.

没毛病.

也就是说, 我这边的移动, 对方并没有收到, 不, 应该会收到的, 应该是慢了一丢丢.

一个按键事件, 由我这边按键触发, 经过网卡, 网线, 十多个中继器, 交换机然后又经过网线和连接到对方设备的多个中继器网线, 网卡, 最后再通过程序计算, 模拟球拍的移动.

这, 信号经过了好多好多设备, 需要一丢丢时间, 这个时间毫秒为单位的, 嗯, 一丢丢.

一丢丢, 好像不是什么大问题, 在极端情况下, 擦着极端的边缘的接球, 可能导致这差一丢丢的问题.

嗯, 不断乘算, 实际发生的概率很小, 应印证了异常数据只有十六场这么少的现象, 不, 十七场, 刚刚又多了一场.

那咋解决?

或者说, 要解决什么?

不让这种现象发生呢?
物理材质的信号传播, 能解决的话, 早解决了, 我又不是什么物理学家.
是发生这种现象, 直接判负结束对局吗? 一方赢了另一边直接判负, 多加一个通信?
游戏体验极差, 这边极端情况的插别挽回对局, 多么紧张刺激, 我做到了, 然后你告诉我输了???
是发生这种现象, 可以恢复正常情况吗?
另一边都获胜了怎么恢复, 我都看到球通过它的球拍, 它没接到了
头大. . .

并且这个问题, 嗯, 不可避免呢, 如果推广游戏到隔壁城市, 一路上的设备只会更多, 绝对会发生这样的问题, 并且特别多.

所以, 我们还是的从这个慢一丢丢入手, 嗯, 这个按键事件慢了一丢丢.

时间延误了一点点, 网络延迟, 好糟糕的问题.

最大的一次更新
既然按键事件会慢, 那就等一等呗!

现在流程 :

玩家按下手柄按钮, 发出输入事件
按键事件经过各种设备到达对方设备, 然后立即处理应用, 变成球拍的移动事件.
那, 不立即处理了呗!

两边都等一下, 有自己的按键事件了, 然后对面的按键事件也到了, 再统一进行下一步处理.

嗯, 这个时候, 就得考虑没有按按钮, 固定不动的输入情况了, 这种情况也要记录并发送了.

那就再加一个bit, 00无操作, 01向上, 10向下, 11既上也下同00, 加上玩家ID16位, 也好处理.

新流程 :

输入手柄操作, 00|01|10|11, 本地记录, 并向对方设备发送
接收对方手柄的操作
同时应用自己的手柄操作和对方的手柄操作, 变成球拍的移动事件
嗯, 这个时候, 哪怕延迟稍稍高一丢丢也没有问题, 不会有操作被丢掉了.

那如果延迟特别高呢, 好像, 每按一个键要等很久的样子, 好像没辙, 中间的信号传输速度这么慢, 软件层解决不掉, 只能看硬件链路上怎么解决了.

嗯, 这次可是一个大更新, 所有的游戏机都需要升级, 还好之前把手柄剥离出去了, 手柄的处理固件不需要更新, 不然工作量可太大了.

现在二百多台设备, 更新可不简单, 得叫上一个人帮忙.

明天宣布暂停赛一天, 更新游戏了, 修复了一个网络延迟的bug.

虽然说了他们也不懂.

没想到吧!
惊喜吧!
帧同步出来了!
暂定比赛更新设备的一天
上午, 在X宅的协助下, 以解封他账号为条件的基础上, 更新了近一半的设备, 忙碌充实!

中午在外面吃饭的时候, 被陈七找到, 吐槽 : "你更新了个什么玩意, 游戏卡死了! 怎么操作都没反应!"

我 : "嗯? 发生了什么. 容我想想先!"

现在是记录自己的输入信号, 然后等待对方的输入信号, 如果长时间没有反应, 那就是对面没有输入.

不好, 得加个限制, 长时间没有接收到对面的信号, 游戏就结束, 不然对面出个事故, 断个电什么的, 就糟糕了.

我 : "陈七, 知道哪里出问题了, 我回去修一下, 打个补丁就好!" 转身, 小碎步, 扔下吃了一半的饭, 钱都没付, 准备回去.

陈七 : "等等, 别这么急啊! 还有, 你这次更新后, 是不是手柄的按键出问题了, 感觉比上次迟钝一丢丢, 也就我这种技术大神能发现."

我 : "玩傻了吧, 能改啥? 还大神, 排名前十都没进去, 再多练练吧! 技术不好怨设备!"

回到实验室, 先打个补丁: 长时间没有接收到对面信号, 这场游戏结束, 直接获得胜利.



接着思考一下 : 陈七感觉按键迟钝了一丢丢.

好像, 大概, 可能, 估计, 也许, Maybe, 会有的吧.

在当前记录下手柄按键事件, 比如未响应, 在对面信号接收到之前, 这个短暂的时间, 手柄信号是被忽略掉的.

这个, 不太好解决, 毕竟一个输入事件, 已经被记录, 就不可以被更改了.

玩家要提前按下按钮了, 嗯, 还好吧, 也就按下时机要快一丢丢的问题.

这个, 那个, 游戏特性懂不懂, 不对, 这样说 :

这次更新提高了对游戏操控的精确度的把握, 修复了由于各个地方位置不同带来的微小优势.

如果感觉手感不对的, 可能是之前这些微小优势造成的, 多适应一下就好.



下午近傍晚的时候, 修复完毕, 继续和X宅去更新设备, 全部弄完估计要深夜了, 唉, 总感觉还遗忘了些什么!

尾声
在经过了长篇的胡诌八扯之后, 再来看看, 现在这个游戏, 是一个什么样的:

P2P联机方式, 每个玩家之间直接连线.
最简单的多房间模式, 两两对局匹配对战.
帧同步, 战斗游戏, 每一次玩家输入都被记录, 然后同时处理.
有一个游戏机, 专门用来记录玩家的得分情况和场次情况, 排名+匹配信息服务器
这段时间最大的突破, 就是我们从一个即使响应游戏变成了一个帧响应游戏.

帧同步了, 是进步了还是退步了?

不知道, 不过, 嗯, 网络延迟这个问题, 可以解决一丢丢了, 之后可以考虑安利到隔壁城市去了.
</code></pre>
</details>

<details>
<summary>UE5 网络相关系列 导言(七)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/445814591
前言
上一篇文章 : 孤傲雕：UE5 网络相关系列 导言(六) 系列文章, 请逐篇阅读


测试等于发现奇怪的问题
第八日, 无事, 于在家中测试 : 赢, 输, 卡死, 输, 输, 输, 赢, 卡死, 输, 赢, 卡死. . .

? ? ?

卡死次数好像有点多了吧!

并且又卡死了? 又!

上次陈七卡死, 是对面掉线了, 没有按键事件产生, 这边收不到按键事件, 无法进行下一次操作, 程序就卡死了.

那这几次, 总不是对面都掉线了吧!?

估计也是类似问题 : 没有收到输入事件.



没有收到输入事件, 没有收到.

之前一周多应该没有这个问题, 等等, 想想, 不, 可能也有, 不不不, 大概率有!

那些不正常的场次记录, 甚至一些看起来正常的场次记录, 都可能是这个问题, 某个或某些输入事件没收到导致两边的状态不一致.

网络同步不一致比较大的时候, 就会出问题, 不一致小的时候, 问题就被掩藏起来了.



那输入事件为什么没有收到呢?

上次是线拉得特别长, 经过了很多的设备, 然后信号传输会慢.

很多设备, 还记得为什么有中继器吗? 线不能直接拉特别长, 会没有信号.

那线拉得稍微长一些, 不需要中继器, 那又快到需要中继器的长度呢? 信号比较差, 断断续续的, 有错误信号.

线短一点, 这个信号稳性要好一点, 但极端情况下, 还是会出问题的.

嗯, 没错, 还是物理硬件线材导致的, 不是我程序的问题.



Ok, 推算得出, 发出的数据, 到接收的时候, 概率性的会出问题, 很糟糕了!

糟糕一 :

如果发送出去的数据, ID的bit错了任何一位, 他就会发送到一个其他设备上(虽然, 这个信号在我们的交换机上被屏蔽掉了, 游戏开始后只能互相通讯).

但这个按键事件就没了啊!

糟糕二 :

如果发送出去的数据, 前两位代表移动方向的bit错了任何一位, si~~

那就很严重了, 两边操作又对不上了!

糟糕三:

如果发生出去的数据, 凭空多了一位, 或者少了一位...

就, 现在按固定bit位做的事件解析, 问题好大.



吐槽 :

为什么要改帧同步啊? 这样我沉浸在原来那个问题发生次数特别少的情况不好吗?

为了修复那一丢丢的小问题, 这么多问题, 又出现了...

没有bug发生, 不代表没有bug
被惊醒的"鸵鸟"
问题发生了, 便不能当做无事发生, 否则, 问题只会越来越多.

既然按键事件传播的信号有概率出问题, 那我们就要想办法避免他发生, 或者说, 让这个问题在可控范围内.

如果按键事件丢了, 那么就再发送一次, 嗯, 没错, 很简单的道理.

回顾一下现在的流程 :

发送设备的按键事件A
等待接收对面的按键事件A
处理所有按键事件A, 并进行下一次按键事件B
发送设备的按键事件B
等待接收对面的按键事件B
如果发送的按键事件A丢失的话, 那么是可以收到对方的按键事件A的, 然后对方下一次按键事件B收不到.

对方在等待丢失的这个按键事件A, 无法进入下一帧.

我们需要发送的就是上一帧的按键事件A.

说起来好拗口, 不过, 嗯, 理解理解就好.

这样, 丢失帧的发送, 就解决了, 同一个按键事件, 我们会发送多次.

对面设备总会接收到一次的, en? 一次, 他接收到多次怎么办? 两边球拍位置又对不上了.

要发送多次, 但只接收一次.

一次, 信号中加一个, 唯一标识符, 收到应用过, 就忽略掉.

这个标识符, 可以递增, 然后递增到最大值, 符号位溢出, 值归零.

那这个标识符就得很大, 不然, 溢出就出问题了

注 : 如果用标识符的话, 可以通过巧妙的设计规避掉这个问题, 或者说在正常时序上规避这个问题
使得这个标识符特别小, 实际也可以是1位, 多位最佳, 但思路不一样, 并且可以扩展到其他地方使用, 例如下面的问题
不不不, 简单点, 奇偶, 奇数1, 偶数0, 1和0轮流替换

收到1, 应用1, 等下一个0

嗯, 打断一下, 做事要考虑极端情况, 那刚好A1, B2, C3, 在接收C3的时候, 又接收到A1怎么办?

极端情况? 不存在的!

现在是单工通信, 一条线发, 一条线送, 直来直往的.

发出去的信号收到就是收到, 有问题就是有问题, 没问题就是没问题, 不存在先发出去的信号后送达这种情况.

如果存在呢? 那, 到时候再说呗!

那就先这么改! 又得停赛一整天去更新, 刚开始就试比赛了几天, 现在又反复的停赛, 不行, 不能再一再二再三了.

下午去X宅帮帮忙, 嗯, 看他能不能找出些bug.

就用, 就用, 对, 游戏代码整理思路来贿赂他, 把他彻底绑到这条船上, 完美!

不断完善的漏洞
在动之以情, 晓之以理, 背后手揣(藏)着了一把键盘的情况下, X宅加入了这次bug寻找之旅.

不, 论游戏如何作弊.

回合一:
老套路, 接收到匹配信息后, 直接模拟发送胜利匹配信息, 结束游戏.

这个, 那个, 发现这种情况, 把你账号封禁了不就得了...(X宅斜眼冷视)

回合二:

断开网线, 然后10s之后再次插上网线, 对面因为长时间没有接收到信号算胜利, 这边又因为插上网线之后长时间没有接收到对面信号算胜利.

这个, 那个, 这局不记录场次, 流局?

不行, 那输不起不就拔网线了.

好像, 大概, 发现这种情况, 次数多的封禁账号吧...(背后发毛, 像什么注视着一样)

回合三:

统一修改失败信号为胜利信号, 赢了就是赢了, 输了还是赢了.

这其中大多数对局都是正常的记录, 你说是bug呢? 还是程序问题呢?

这Geee, 封ngg!(表情不太自然)

回合四:

插拔网线大法, 使得对方画面卡顿, 一会等一帧时间特别久, 一会等一帧时间正常.

利用这个时间差, 让对手措手不及, 比如 :

接球后看到对方球拍接不到球, 那么我拔掉网线, 等一秒再插上.

对方会看到画面卡了整整一秒, 然后, 又正常了, 一秒可以, 那0.5秒呢? 2s呢? 会不会气急败坏扔手柄呢?

这局不就胜利了, 你还查不出来.



这个, 直冒冷汗..

. . .

我 : "还有这么多问题啊!"

X宅 : "不然呢? 喏, 代码都在那, 这些问题不都很好找吗? 你就是灯下黑, 太熟悉了反而啥都看不见."

无言以对...

我 : "那, 一起修!? 看起来问题有点麻烦了."

X宅 : "不然呢, 都上了匪船了, 还能跳海不成?"

开始修bug了. . .

b. . .

u. .

g.

尾声
又又又经过了一段的时间, 嗯, 帧同步在不断的完善, 现在每一帧数据都是可靠的, 必定会送达的了!

又又又是一次本游戏网络同步史上的一次大进步!

然后, 嗯, 果然, 这种大进步, 背后是很多潜藏的风险, bug修完就没bug了!(手动狗头)
</code></pre>
</details>

<details>
<summary>UE5 网络相关系列 导言(结)</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/447260326
前言
上一篇文章 : 孤傲雕：UE5 网络相关系列 导言(七) 系列文章, 请逐篇阅读
回放? 服务器? 作弊再也没门了!
总结一下所有胜利失败会出问题的场次, 或者bug, 或者漏洞.

都是两边操作数据不同步, 无论是bug造成的, 还是网络延迟波动造成的.

我们是个帧同步游戏, 只要每帧的顺序和操作一致, 那么画面就一致, 这也是我们整个游戏可以P2P点对点联机同步的根本.

这些数据, 完全也可以记录一份, 然后就可以判断出场次的胜利和失败了, 问题的话, 那么这个场次就可以标记为异常.

这样做的话, 嗯, X宅提出的几种作弊手段就没有效果了.

并且, 我们还可以将这些记录进行回放, 变成游戏对战的实时画面, 如果场次特别精彩的话, 可以多次观看.

实现起来也简单, 嗯, 记录一下两边的操作帧, 在什么时候记录呢?

嗯, 好像有两种实现方式:

方案一 : 单独开一个设备(服务器)记录, 这个设备也是接收两边所有的输入信号, 然后按照帧的顺序进行记录, 最后将这些帧信息写到总的服务器里面
方案二 : 在两边设备游戏, 应用双方输入信号后, 记录一下, 在游戏结束后, 将两边的输入信号, 都记录发送给总服务器, 然后进行比对处理
如果方式一, 嗯, 数据是绝对可靠唯一的, 也不会出现问题, 并且, 嗯, 如果有一边掉线了, 长时间没有收到输入事件, 它也可以正常记录, 长时间没有收到的那一方判负, 给两边发送游戏结束事件.

等等, 是不是游戏胜利, 失败, 都可以由这台设备进行处理, 这台设备也是记录了两边所有玩家的操作, 也可以模拟正常的游戏对局, 并且是我们这边自己的设备, 绝对可靠的.

这样一改的话, 玩家拿什么作弊?

没毛病. . .

但总感觉有什么奇怪的地方, 一局游戏, 专门开一台设备去记录对战, 倒吸一口冷气, 这, 现在200多人在玩这个游戏, 我要准备200多台设备, 设备不要钱啊?

Pass, 哪怕它的效果再好也要Pass

P2P联机, 其中一台是服务器设备, 进行数据记录和比赛结束, 由于需要多一台设备, 性价比极低, 哪怕会带来没有玩家作弊的优势, 还是要Pass

那看一看方案二.

在游戏结束的时候, 两边都上传一下两边各自的每帧数据信息, 如果两边一致, 嗯, 那游戏正常结算

如果不一致, 那么有一边作弊, 或者程序出现了漏洞, 也方便排查.

总归能找出些问题, 那些左右数据不一致的场次, 就先不记录到排行榜中, 人工处理一下, 嗯, 判断一下是不是X宅的几种作弊方式, 是不是异常记录, 再处理处理.

说干就干, 这个实现简单, 益处很多, 能极大程度的解决作弊问题, 还不影响正常对局, 也不需要添加额外的设备.

掉线重连导致两边场次都胜利的异常也可以筛出来, 从某一帧开始, 对方都开始不移动了, 嗯, 怎么处理还得再思考思考...

等等, 记录一下两边的胜利帧收到时间, 慢的就是掉线的那一端, 判个负没问题吧, 嗯, 简单有效.

看来帧同步还是有很大的优势的, 按照原来的即时同步来做的话, 这些都没有办法处理.

唯一可惜的就是, 还剩下"插拔网线作弊大法"这个恶心的方式没有办法处理, 容我再思考思考

插拔网线大法的尝试解决

插拔网线大法, 本质上, 是利用每一帧都是可靠的, 都会等待对方输入事件, 这个后来加入的设定, 导致的.

嗯, 这个设定, 又是为了防止网络延迟一丢丢带来的.

或者说, 极端情况下, 一个玩家设备端, 网速时快时慢, 那么, 嗯, 就是这种插拔网线大法的效果.

不理解? 这样说


第一张图, 是我们最希望的, 每帧间隔时间的波动情况

第二张图, 是网络正常情况下, 每帧间隔时间的波动情况

第三张图, 是网络异常情况下, 每帧间隔时间的波动情况, 他的波动范围会特别特别大, 导致游戏画面看起来几帧快, 几帧慢, 时快时慢, 非常诡异.

等等, 实际上, 问题也可以这样说, 如何让每帧间隔时间变得更平滑?

这个平滑, 可好解决一些.

固定一秒三十帧, 现在不限制的话, 玩家机器加网络正常波动在四十帧左右, 在三十帧内平滑, 还是很好处理的.

到时间才处理下一帧并发送新的一帧按键事件.

这样平滑修改后, 玩家每局游戏的操作手感也几乎统一嗯, 不会出现时快时慢的微调.

然后就是极端情况, 极端情况下, 那就二秒五十帧? 发现一次帧数特别慢的, 就开始5秒的慢速时间, 比正常的一秒三十帧要慢一些, 如果还不行, 就二秒四十帧, 一秒十五帧, 一秒十帧.

但五秒内, 平稳在某个帧数上, 再开始加快, 画面上也可以显示一个当前网络延迟导致的游戏速度.

嗯, 正常情况下, 游戏玩起来会很平滑, 网速慢就是慢一点的平滑.

他插拔网线, 也会导致对面知道对方网卡了, 接下来一段时间是慢速模式, 插拔网线, 还是能恶心人, 但恶心获胜就没那么容易了.

如果, 真的还这样的话, 那, 举报? 举报验证后对这种恶意行为进行封号? 没毛病.

之前X宅是因为作弊被封号, 这种恶意行为封号, 也是可以的吧!

这两个大问题解决后, 嗯, 网络波动和作弊, 算是彻彻底底的解决了吧! 接下来就是修bug, 然后再次停赛一天, 更新游戏了.

不堪重负的交换机
正式比赛的第九日, 已经距离比赛开始过去了十一天, 中间两次大的暂停比赛整体更新设备.

不过, 这次更新好像出乎意料的好评!

中午在外面吃饭时, 碰到的玩家都说, 手感更好更平稳了.

那是, 现在平滑的像一个单机游戏似的, 快夸夸我.

然后就是幸福的烦恼了, 又有许多人在安利下要安装设备, 但交换机的口不够用了. 定制的150口早已经更换过一次250口的了, 现在再扩大, 好像要出问题了.

交换机是有处理数据的, 接口越多, 处理越多的话, 会造成, 对, 那个恶心的网络延迟.

所以我们想其他办法来扩展交换机, 比如加一个交换机.


这两个交换机, 分别连接250, 不, 少一点吧, 150个设备, 交换机A连接0-150, 交换机B连接151-300

如果发现, 设备ID在自己的连接口上, 就自己处理, 不再就发送给另一台交换机, 由另一台交换机进行处理.

这样我们就可以有300个接口, 接入300台设备

如果再加一台交换机C, 嗯, 设备ID在自己的连接口上, 就自己处理, 不再则查询他在哪一个叫交换机上, 发送到对应交换机处理.

没毛病, 这样理论上可以无限添加接口, 添加无限设备了, 再加上, 中继器可以无限延长网线, 延长设备到交换机的距离, 和交换机之间的距离.

简单的说, 我们可以开到隔壁城市里面了!

我们预留的16位bit用来存设备号, 终于有了用武之地了!

然后, 为了让玩家体验更好, 匹配对局, 优先匹配本交换机内的其他玩家, 优先个70%, 较大该类匹配到本交换机内的其他玩家, 网络延迟也不至于那么糟糕.

嗯, 唯一麻烦的可能是记录排名的服务器, 接收数据量过多了, 管它呢, 下次再办比赛再说.

后记
比赛终止的那天
就这样, 游戏比赛完美结束, 在最后一天, 有了近400人的玩家规模, 隔壁城市也有了50个人参与进来, 并且大受好评!

隔壁市的XAX程序员也顶上了这个游戏, 打算研发一个类似的竞品.

而我, 早已卖游戏设备, 赚了个底朝天, 在最后一次更新后, 几乎没有出现bug, 只是做了一丢丢游戏体验上的微调, 比如画面更好看了啊, 随便加了一丢丢的球拍皮肤什么的, 大受好评.

又一个月后
隔壁城市, 隔壁的隔壁, 这个游戏已经四处开花了, 用户数量近1000, 但交互机之间的数据通信出了一些问题, 和之前设备之间互相通信一样, 再加一层交互机的交换机呗, 层层网络结构延伸扩展出去, 也没有什么的.

半年后
据说, 隔壁国家也打算采购这设备了, 现在ID16位, 已经快到极限了, 但如果大规模的修改ID是不行的, 在交换机上动动手脚? 交换机上分配一个区域ID, 区域内直接通过16位ID进行交换, 区域外通过交换机的区域ID+16位ID进行交换.

完美

一年后
摊子扔给了X宅, 环游世界去了, 全剧终!

结语
说实话, 嗯, 这个导言写到第八篇才写完也是够了, 还是没有再把隔壁市的交换机引出路由啊再开(水)一章

原计划是, 这个游戏只是个引子, 没错, 引子, 引出到帧同步, 他的使命就完成了

然后再过渡到上世纪的网络同步文字冒险游戏, 网络的FPS主机模式等等, 去引出游戏帧同步, 状态同步, 客户端服务器等各种各样的概念.

因为, 网络同步这些乱糟糟多的东西, 如果真的要系统讲的话, 没有实践经验, 是不太能体会到中间那些糟心的问题的.

至于单纯的的RPC和属性同步怎么使用, 这种使用的东西? 放心, 绝对会写的, 会很迟很迟写的. 嗯, 绝对放心!

嗯, 或者说, 一个宝箱开关考虑各种情况的简单实现, 就可以让你对RPC和属性同步有个深刻的认识, 但, 我不写,就是玩儿!

然后为了, 让, 那些, 没有, 网络, 复杂实战经验的人, 大概有个认知, 所以有了这一系列序, 结果, 一个简单的乒乓球对战游戏, 就写(水)了这么多, 想想后面的系列还是算了.

好, 换个话题

这个系列水了八篇, 自认还是算满意的吧, 打个及格分还是有的.

嗯, 假设, 如果真的从零开始做一个简单的网络同步游戏, 没有设备和乱七八糟现成的同步协议的话, 一步一步搭起来可能还真是这个样子, 由于是写一发一, 之间想到什么新的有趣的玩意, 也就加上了.

嗯, 为了逼真一点, 加了些对话, 虽然自己都觉得尴尬(笑)(假装有删除线)

所以越水越多了.

不过, 嗯, 网线, 中继器, 交换机一些基础的网络设备, 信号不断地传送和转发导致的网络延迟, 丢包问题.

如果是一篇一篇读过来的, 应该大概会有个印象了.

全文没有出现时序问题, 是因为全程都是单工通信, 最后网状结构看起来很复杂, 其实都是两根网线通过各种手段延长到极致进行互相通信罢了.

透过问题看本质是十分重要的. 划重点了.

文章内一些问题的解决思路, 比解决问题的方案, 是更重要的.

因为, 如果你正儿八经的系统的读过网络基本原理的话 , 你会感觉, 所有文章基本都是废话(恭喜你, 终于发现了)

好吧, 为什么这样做, 和怎么样做比, 为什么是更重要的. 当你知道为什么, 你也可以思考, 为什么不那样做, 以及这样做有哪些局限性等等.
而该游戏加上时序问题, 也好解决, 就是把哪里不同帧的先后顺序, 那个1位奇偶bit, 换成一个4bit? 或者8bit?的一个数字, 然后比较是不是下一帧就可以了, 考虑一下溢出归零之后, 大的帧数反而变小的问题, 就解决掉了.

如果不考虑, 就简单粗暴的加一个32或者64bit记录帧数, 嗯, 在哪个年代, 这点内存也是会扣着使用的.

但按照原计划来说的话, 还是要写到时序问题, 在硬件传输上不仅仅是传输延迟了, 因为不同的数据会在不同的网络设备线路上传输, 不同线路到达的先后顺序是不一致的, 从而导致的时序问题.

软件层上的发送接收时机就更不用说了

时序问题在乘算一个丢包, 错误数据, 问题就更严重了.

接着, 话题再转.

比如, 客户端数据不可靠这一点了, 在X宅的帮助下, 很多很多客户端的作弊方式, 你可能都没有想到的, 或者我还没有想到的, 还会有特别特别多, 这个防外挂, 防作弊, 也是一门功课.

现在也还是防不住外挂(不引入服务器的话), 因为P2P联机, 两个人, 谁是对的, 谁是错的, 没有第三人, 是无法判断的.

嗯, 系统到最后, 只是能记录玩家的场次记录, 然后分析是不是作弊了.

嗯, 如果没有排行榜, 比赛这种比较较真的玩意, 也不会有那么多想作弊的, 论作弊动力的重要性.

最后

在实现基础网络同步之后, 对由于网络延迟, 网络波动等等造成体验较差情况的处理了.

平滑, 预处理, 补偿, 修正等等, 五花八门, 这里只是一个最简单的平滑, 简单但有效.

总之
除了这些问题, 网络同步还会有很多很多的问题, 嗯, 细算拆分一下基本雷同, 也就这些

大道至简, 简而至繁 -- 孤傲鵰


最后的最后

留一个简单的思考题, 如果, 不是可靠的帧同步, 而是不可靠的固定帧数帧同步, 如何避免两边的玩家操作不一致呢?

(每秒30帧, 帧内如果没有输入事件, 就当做没有进行下一帧)

嗯, 这个问题很简单吧? 细想一堆坑的. 注意, 是没有服务器的哦?

// 本来打算接着水水这个的, 嗯, 想了想算了, 算了, 越写越多,



那就这样吧, 再爱都曲终人散啦...
</code></pre>
</details>

<details>
<summary>UE5 网络相关系列 之 再谈 ENetMode 网络模式</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/448243398
前言
旧文章 :
孤傲雕：UE4 网络相关系列 导言
孤傲雕：UE4 网络相关之 网络模式(ENetMode)相关讲解
孤傲雕：UE4 网络相关之 网络模式(ENetMode)的获取
UE5 EA源码版本
序
温故而知新, 可以为师矣.

在很久很久之前, 就有对ENetMode进行讲解, 忘了的, 回去再复习复习先.

嗯, 现在又看了看, 好像发现没有什么好说的, 意思也基本补充到位了.

但, 讲解网络模式, 不从这个作为引子开始, 总是感觉不够意思.

所以, 就换个角度, 继续谈(水)一谈了

Play In Editor

在版本比较高的UE4和现在UE5中, PlayerInEditor的网络启动选项和以前不同

现在是玩家数量NumberOfPlayers和网络模式NetMode

如图所示, 玩家数量, 就是启动的程序窗口数量, 当玩家数量为三, 会有下面的结果

PlayStandalone
启动三个不同的程序窗口, 互相之间没有网络通讯, 三个都是NM_Standalone
PlayAsListenServer
启动三个不同的程序窗口, 互相之间有网络通讯, 其中有网络模式为NM_ListenServer的聆听服务器和两个网络模式为NM_Client的客户端
PlayAsClient
启动三个不同的程序窗口, 互相之间有网络通讯, 其中有网络模式为NM_DedicatedServer的专属服务器和三个网络模式为NM_Client的客户端
发现区别了没有, PlayAsClient会在背后启动一个隐藏窗口NM_DedicatedServer

和旧版本的区别而言, 嗯, 在理解客户端之间关联的情况下, 使用更方便了.

// 原来, 启动三个互不连接的程序窗口, 藏在设置里面, 可能都注意不到
网络概述-虚幻引擎文档
// 什么时候监听服务器改成聆听服务器这个词汇了...
// 又什么时候专用服务器变成专属服务器这个词了???
// 嗯, 那个, 尽量跟着换, 但估计还是习惯用原来的.

在对应的高级设置中, 嗯, 分门别类, 比原来的杂乱一堆而言, 选项整理的更清楚了, 基本还是那几个.

多的也基本没用.

ENetMode的注意事项
// 为什么是/有 这几个NetMode? 讲过了, 在导言那篇
// 这几个NetMode的区别. 讲过了, 在讲解那篇
// NetMode跟随地图切换. 讲过了, 在讲解那篇
// 运行中NetMode的获取判定. 讲过了, 在获取那篇
因为, 这个, 那个, 已经用ENetMode写(水)过几篇文章了, 也没有什么新的东西概念好写的了, 补充说明也感觉不太需要的样子.

那就随便讲点注意事项了, 嗯, 就这样

NM_DedicatedServer专属服务器没有玩家

专属服务器没有玩家, 这点会导致蓝图常用节点以及UWorld::GetFirstPlayerControllerC++常用代码, 返回值异常

这个异常呢, 嗯, 常常会被忽略掉, 如下图, 在一个GameMode下写如下蓝图节点, 然后运行多个客户端+一个专属服务器


专属服务器会先打印很长时间空值, 此时PlayerController指针为空

然后在第一个玩家加入进来之后, 打印"PlayerController", 也就是此刻, PlayerController指针有值

这是因为所有的PlayerController都会在服务器与对应客户端上加载, 当有玩家(客户端连接)时, 取第一个PlayerController, 此时返回一个有值的PlayerController

这个值一般是当前所有玩家中, 最先加入的那一个.

由于, 玩家中间可能出现掉线断开连接等, 这个值是会动态变化的, 所以不推荐使用.

以及, 嗯, 大多数情况, 去获取PlayerController, 是想要在客户端获取本地的PlayerController, 在专属服务器上面这样操作, 本身逻辑上, 就会有问题.

那聆听服务器为什么正常呢?

由聆听服务器于自己也是客户端, 在接收任何客户端连接前, 会自己创建本地的PlayerController, 先把位置占了, 所以之后实现效果, 和客户端一模一样了.

但是, 在客户端获取PlayerIndex为1的PlayerController一般是获取不到的(特殊情况自己知道, 懒得多说), 而聆听服务器此时会获取当第一个加入的PlayerController, 打印PlayerController1

蓝图节点同上, 改一下PlayerIndex就可以测试

NM_DedicatedServer专属服务器没有UTextRenderComponent组件

Unreal Engine 4.11 Release Notes
New: UTextRenderComponent and UFont will now not be loaded on dedicated servers - watch out for NULL references!
不只一次, 见到在蓝图Tick中访问TextRenderComponent 报蓝图空指针警告, 短时间内产生海量日志了.



在BaseEngine.ini中, 里面有定义ClassesExcludedOnDedicatedServer 和ClassesExcludedOnDedicatedClient 嗯, 字面理解, 在服务器或者客户端中不会烘焙的类.

也就是说, 这些类在打包后就不存在了.



在UCookerSettings::PostInitProperties中, 会将这些值给到FClassExclusionData 结构体GDedicatedServerExclusionList 和GDedicatedClientExclusionList 中, 并在实际执行NeedsLoadForServer 或NeedsLoadForClient 中, 将 这些类直接过滤.

嗯, 想过滤其他东西, 按照类似的改就行了.

好像有点跑题了, 拉回来.

NM_DedicatedServer专属服务区的帧率是有限制的

通常情况下, 专属服务器的帧率是被限制在30FPS的, 在BastEngine.ini中的NetServerMaxTickRate 被定义

而聆听服务器客户端不同, 他们的帧率一般都很高, 嗯, 30-120FPS不等, 看实际电脑配置和性能优化.

虚幻应该好像是有锁120帧, 没找到在哪锁的, 但可以通过t.MaxFPS帧率来解锁
</code></pre>
</details>

<details>
<summary>UE5 网络相关系列 之 网络模式背后的主人UNetDriver</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/455605509
前言
旧文章 :
孤傲雕：UE4 网络相关之网络驱动器(UNetDriver)的顺藤摸瓜
上一篇 : 孤傲雕：UE5 网络相关系列 之 再谈 ENetMode 网络模式
UE5 EA源码版本
本文没啥东西, 嗯, 都在下几篇文章内, 这篇文章就是凑数+过渡
序
温故而知新, 可以为师矣.

在很久很久之前, 我们从ENetMode网络模式顺腾摸瓜, 找到了其背后真正的主人:UNetDriver

// 忽略PIE流程, 懒得考虑
服务器加载地图的时候, 就确认了网络模式, 在UEngine::LoadMap中的UWorld::Listen中创建了服务器的UNetDriver

客户端确定网络模式, 则是要加入到服务器时, 在UEngine::Browse时 创建UPendingNetGame, 准备连接服务器, 在其中创建客户端的UNetDriver

本文呢, 则是对这个主人, 进行一些简单的挖掘, 因为这个类的东西, 真的很多, 很多.

最好的教程, 就是代码本身, 然后就是代码的注释.

UNetDriver 类前面自带的注释 都有:314-24行, 嗯, 概况十分简单易懂, 可以自行阅读

// UNetDriver系列相关, 大多就是对这些注释的补充扩展, 以及瞎扯皮了
反正说不完, 就随便先讲比较简单的一丢丢了.

由简入深吗!

UNetDriver的创建初始化流程


首先看一下创建的方法, 都是通过UEngine::CreateNamedNetDriver 来创建, 只是参数不同NAME_GameNetDriver 和NAME_PendingNetDriver


但本质, 最后都走的是CreateNamedNetDriver_Local 函数

服务器创建后调用InitListen , 客户端调用InitConnect 走不同的分支, 使得同一个类, 对象, 最后一个是服务器用, 一个是客户端用.


当然, 这两个初始化会有一些公用的部分, 在InitBase 里面, 根据bInitAsClient又有一定的独立逻辑

最后由UNetDriver::SetWorld收尾, 将UNetDriver和UWorld关联



那问一个可能比较弱智的问题:

为什么不进一步拆分一下子类? 服务器子类和客户端子类, 逻辑分开, 共用的放基类, 这样一拆分, 逻辑不会更清楚吗? 现在代码要各种判断, 服务器做什么, 客户端做什么, 不麻烦吗?

盲猜一下原因, 如果不符, 纯当胡说.


看一下UNetDriver的子类, 或者本身的UCLASS宏中的MetaData元数据Abstract

UNetDriver
UIpNetDriver
UNetDriverEOS
UOculusNetDriver
USteamNetDriver
UWebSocketNetDriver
USteamSocketsNetDriver
UDemoNetDriver
如果, 客户端和服务器拆分成两个类, 则不同的平台, 不同的实现, 继承并扩展, 会是一个特别麻烦的问题 : 菱形继承

有解决办法吗? 有.

麻烦吗? 有点.

那有必要拆分子类, 嗯, 不知道, 可有可无吧.

UNetDriver的创建

创建的实现CreateNamedNetDriver_Local, 里面有两个函数值得重点关注:

FindNamedNetDriver_Local
CreateNetDriver_Local
并且, 根据这些逻辑, 可以简单的看出 :

NetDriverName是唯一值, 每个网络驱动都不相同
NetDriverDefinition 是创建NetDriver时使用的, 表明创建哪一种NetDriver
细想一下, 我为什么这么说, 先不要继续往下看, 稍稍锻炼锻炼读码能力, 嗯.

读部分代码, 推算其他地方的逻辑

















想好了吗? 那继续.

FindNamedNetDriver_Local


从FWorldContext::ActiveNetDrivers集合中查找对应名称的UNetDriver

这个集合存储了UNetDriver 指针和FNetDriverDefinition 指针


FNetDriverDefinition存储了NetDriver 的创建信息

种类名称DefName
默认创建类型DriverClassName
如果默认类型无法创建, 的备份类型 DriverClassNameFallback
好的, 通过查询FindNamedNetDriver_Local, 我们有认识了一堆数据结构.

嗯, 然并卵

创建CreateNetDriver_Local
接着看一下创建, 忽略掉通过FNetDriverDefinition查找实际生成类的代码, 嗯, 可以通过-NetDriverOverrides= 在配置中覆盖, 嗯, 注释解释的很全面, 有需求的自行查找


不要忘了外面还有一个NetDriver->SetNetDriverName(NetDriverName);

覆盖默认名称为最终使用的名称.

嗯, 好像这堆东西都很简单的样子, 是的.

这么多啰嗦的代码, 不细看SetNetDriverName, 都只是初始化了一个UObject

那细看呢? 接着往下喽:

UNetDriver::SetNetDriverName


嗯, 网络测试相关的, 如果没有其他设置, 会通过NetDriverName来初始化 FPacketSimulationSettings

这个呢是模拟网络状况丢包延迟相关的, 前文配置中有淡淡提到过.

就这样, 一个UNetDriver被创建出来了, 没啥东西, 嗯, 没啥

UNetDriver与UWorld关联
在看UNetDriver::SetWorld实现前, 先思考一个问题

为什么UNetDriver放置UWorld中?

已知 :

UNetDriver是网络模式背后的实际处理这
ENetMode 跟随地图发生变化, 以
那么, UWorld 管理地图关卡, 放在这里, 刚刚好






UNetDriver 在SetWorld时进行一定的初始化

Actor同步列表初始化
属性同步相关初始化(仅服务器)
属性同步相关, 只在ReplicationDriver存在(服务器创建), 时处理, 这个是因为 :
服务器属性同步要处理那些需要同步并同步等各种各样的东西
而客户端只需要接收属性并应用
服务器要做的东西特别多杂乱, 客户端的很少, 合并到Actor同步里面就可以, 所以服务器处理特殊很多
Tick事件注册

在注册/注销TIck函数时, 注册了很多很多, 嗯, 如上这么多Tick函数

尾声
到此为止, 只能说, 你应该大致知道, 有UNetDriver这个玩意, 这个玩意呢, 负责整个网络同步通讯等等

这个类在UWorld::Tick事件, 即主线程游戏帧中不断的走逻辑.

并眼熟一些杂七杂八的东西, 这些东西后面都会逐步展开讲到(大概吧)
</code></pre>
</details>

<details>
<summary>UE5 网络相关系列 之 服务器网络连接的初始化</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/463752477
前言
上一篇 : 孤傲雕：UE5 网络相关系列 之 网络模式背后的主人UNetDriver
UE5 EA源码版本
序
书接前文, 服务器的UNetDriver, 执行UNetDriver::InitBase和UNetDriver::InitListen 进行初始化.

在UNetDriver::InitBase 打一个断点, 然后看一下堆栈, 它到底做了些什么事.


在Windows平台, 默认的UNetDriver是UIpNetDriver, TCP/IP协议, 这很合理.

UNetDriver::InitBase
First

首先根据参数初始化三个属性:

InitialConnectTimeout 新链接多久超时
ConnectionTimeout 已有连接多久超时
bNoTimeouts 忽略超时(仅推荐用于测试)
在UNetConnection::GetTimeoutValue 函数中, 会获得对应连接, 实际的超时时间

不同情况下会不一样, 有的会长, 有的会短.


接着, 在UNetConnection::Tick时, 比较CurrentRealtimeSeconds 当前时间和 LastReceiveRealtime 上一次收到消息的时间, 如果时间插件大于超时时间, 判定超时, 执行对应逻辑

嗯, 超时时间默认是60s, 也算久的吧...



Second

在超时相关初始化后, 接着会调用UNetDriver::InitConnectionClass加载UNetConnection 的UClass,

注意!!!

只是加载Class, 并没有创建对应的UNetConnection



Thrid

然后, 如果不是客户端, 是服务器会做一些额外处理

嗯, 这些呢, 或者不用讲, 或者需要长篇, 都不太在本文范围内.


UNetDriver::InitDestroyedStartupActors 这个函数可以淡淡提一笔 // 省的到时候不知道在说什么

GetDestroyedReplicatedStaticActors 画重点, ReplicatedStaticActors 同步静态Actors, 静态Actors?

又一个新鲜玩意儿, 记下来, 以后讲


Fourth
老规矩, 忽略测试相关代码, DO_ENABLE_NET_TEST宏内不看

Notify是FNetworkNotify , 里面定义了一堆委托, 将一些事件广播出去.

class ENGINE_API UWorld final : public UObject, public FNetworkNotify
好巧不巧, UWorld就继承自这个类, 在一些网络事件时, 做一些对于处理

Total
到此, UNetDriver::IniBase就完了, 内容不多, 只是又又又引入了一堆新的东西:

UNetConnection
ConnectionlessHandler
ReplicatedStaticActors
UReplicationDriver
FDDoSDetection
FNetworkNotify(UWorld)
UIpNetDriver::InitBase
等到了UIpNetDriver时, 就更细节了一步.

它主要做了以下几件事

UIpNetDriver::CreateAndBindSocket 创建初始化Socket, 并绑定到对应端口, 获得实际的网络地址
CVarNetIpNetDriverUseReceiveThread, CVarNetUseRecvMulti, 根据这两个不同的控制台变量, 以及对应平台子类是否实现支持, 然后对Socket接收时处理, 进一步的性能优化. [没接触过]
嗯, 这个, 那个, 如果让我讲, 我也扯不太清楚.

毕竟, 嗯, 一个层层封装的Socket类, 各种平台各种特殊处理, 本人不是特别特别专业做底层网络的

嗯, 看了意义不大, 也啃起来麻烦, 暂时还没到这一步.

所以, 就这样草草带过了喽!

此时, 我们建立了一个Socket , 有了Socket, 就可以很方便的发送和接收消息了!

Socket会监听端口, 编辑器内默认是17777, 打包后默认是7777

此时通过ip:port 的形式, 客户端已经可以找到服务器了, 尝试开始连接了.

UIpNetDriver::InitListen
UIpNetDriver::InitListen 除了调用UIpNetDriver::InitBase 外, 主要干了两件事 :

调用UIpNetDriver::InitConnectionlessHandler 对, ConnectionlessHandler 进行初始化
覆盖URL中的端口为实际端口
就是说, 你可能希望服务器监听7777 端口, 但被占用了, 它会自动分配到其他端口, 比如7778
这里会使用真实的端口, 覆盖掉你希望(启动参数等配置)的端口
这个节点之后, 就可以通过逻辑获取真实使用的端口, 并检测判断, 根据情况做一定处理喽


前文UIpNetDriver::InitBase 的时候有置空ConnectionlessHandler , 这里是对他的一个初始化.

/** Serverside PacketHandler for managing connectionless packets */
TUniquePtr<PacketHandler> ConnectionlessHandler;
它是一个PacketHandler类, 包裹处理, 是对网络传输的数据包进行处理的一个类, 是对应网络传输包的出口入口

这里是Connectionless 变量名称是无连接的, 在UNetConnection中有另外的的Handler, 是与之对应的有链接了.

啥? UNetConnection是啥, 上面初始化过它的类, 有印象吗?
/** The HandlerComponent pipeline, for processing incoming/outgoing packets */
TArray<TSharedPtr<HandlerComponent>> HandlerComponents;
他有一个属性HandlerComponents 很关键, 是一个装饰器模型的应用

里面的每一个HandlerComponent 都可以对网络传输包进行一定的处理, 比如加密, 校验, 封装, 合并, 拆分...

这个类, 以及这个位置的这个属性, 细扯起来内容会特别多.

之后讲到客户端和服务器建立连接的时候, 再进一步慢慢深入了解.

尾声
就这样, 我们通过UNetDriver::InitListen 函数, 发现了一大堆稀奇古怪的东西.

这些稀奇古怪的东西, 就是稀奇古怪的东西喽.
</code></pre>
</details>

<details>
<summary>UE5 网络相关系列 之 客户端网络连接的初始化</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/469305449
前言
上一篇 : 孤傲雕：UE5 网络相关系列 之 服务器网络连接的初始化
UE5 EA源码版本
序
书接前文, 在看过服务器的UNetDriver初始化后, 我们知道服务器已经开始监听端口, 等待客户端连接了.

这一过程中, 认识了很多很多新鲜东西, 这些内容将慢慢的逐步展开.

接着自然是客户端的UNetDriver初始化, 然后连接服务器了!

UIpNetDriver::InitConnect
客户端的UNetDriver, 自然也取UIpNetDriver, 它会先调用UIpNetDriver::InitBase

在前文中, 我们大致介绍过, 没印象的同学可以回头看看... // 我才不是说自己都没印象了.


接着, 之前没有用到的UNetConnection , 在UNetDriver::InitBase中初始化过它的Class , 在这个地方就被创建了, 接下来, 先好好的看一看这个UNetConnection吧 :

嗯, 一个非常非常非常关键的类!

题外话 : class UNetConnection : public UPlayer
UNetConnection继承自UPlayer 玩家?

从服务器来看, 一个客户端的网络连接, 背后其实就是一个玩家, 嗯, 继承自UPlayer也说的过去.

但, 那个常见的ULocalPlayer 又是什么玩意?


先通过全局查找, 查找一下那个地方创建的, 上面第一个是单元测试忽略.

找到UGameInstance::CreateLocalPlayer , 接着继续找哪里调用的, 或者运行堆栈都可以.


很容易的找到UGameViewportClient::SetupInitialLocalPlayer这个位置

// 上面还发现一个控制台, 嗯, ALLOW_CONSOLE, 扒一扒, 应该有不少有趣的玩意.
扯回来, 看注释, ULocalPlayer在游戏中渲染任何东西是必须的.

嗯, UGameViewportClient游戏客户端视图窗口, 所以大概, 可以这样认为.

UNetConnection 是一个网络游戏客户端, 对外的玩家体现, 它进行网络连接活动, 让其他客户端/服务器感知到这个玩家的存在, 并互相交流.

ULocalPlayer 是一个网络游戏客户端(实际是任意客户端), 对内的玩家展现, 关联视图窗口绘制等等, 让玩家能看到"游戏世界".

嗯, 就这, 应该够清晰的吧!

题外话 : ServerConnection & ClientConnections
NetConnection 字面翻译是网络连接, 变量名称ServerConnection, 服务器的网络连接


自然, 在UNetDriver 里面还有另一个, 与其对应的ClientConnections 客户端网络连接们.

们, 复数, 一个服务器可以同时和多个客户端进行连接.

嗯, 还记得万恶的开始, 一切的根源UNetMode吗?



如果是客户端, 那么必定有一个和服务器的连接.

但反之, 如果是服务器, 不一定有和客户端的连接.

同时, 在这里我们也可以从时序上看出, 是客户端的网络连接线创建, 然后去连接服务器, 当服务器同意接收后, 连接正式创建, 服务器保存UNetConnection到ClientConnections 中.

嗯, 一句正确的废话.

UIpNetDriver::InitConnect Again
好了, 话题拉回, 继续我们的初始化流程


在创建UNetConnection 之后, 自然是对它的初始化, 然后就是往下这部分呢, 就是将UNetDriver::InitBase中创建的Socket 绑定到UNetConnection 上面

至于AddressResolution相关, 下一篇文章再讲

UNetDriver::CreateInitialClientChannels
最后就是调用UNetDriver::CreateInitialClientChannels 进行收尾了


ChannelDefinitions 参考UChannel 的类型定义, 客户端此时只会创建ControlChanel和VoiceChannel两个 , ActorChannel 不会创建

先来看一下FChannelDefinition 的各个属性

UControlChannel是bClientOpen&bInitialClient 在客户端创建的, 用于交换连接控制消息的通道, 固定占用0号索引位置
UVoiceChannel是属性都是true, 嗯, 在客户端和服务器的UNetConnection初始化的时候默认创建并连接, 他是语音通道, 固定占用1号索引位置
[这个语言通道, 稍大的游戏几乎用不着, 本身网络就是一个问题, 还用UE本身进行语音传输, 嗯, 一般都是外接插件了, 不差这些. 也就大概一些小巧的联机游戏会使用一下喽.]
UActorChannel 是bServerOpen的, 仅在服务器创建, 是一个动态创建的, 随着Actor同步而创建, 一个同步的Actor就占用一个通道, 索引位置不定, 或者说剩下的都是它的.
UControlChannel和UActorChannel在后面, 我们会打很多的交到, 现在呢, 只是再粗略的看一下UChannel的创建初始化, 水够字数

UNetConnection::CreateChannelByName 中, 抛开断言不看.


首先, 找到对应的ChannelIndex , ActorChannel 在创建的时候, 会自动去找空位置的索引.

总共上限net.MaxChannelSize默认值是32767, 也就是可以有32765个UActorChannel存在


可以看到, 先调用UNetDriver::GetOrCreateChannelByName进行创建, 跳进去看一看


嗯, 用一个CVarActorChannelPool 控制台变量控制是否开启UActorChannel对象池, 默认开启.

所以, UChannel的创建就是一个基本的NewObject了, 接着就是进行对应的初始化, 调用UChannel::Init 和可能的UChannel::StartTickingChannel添加到Tick列表中等等, 这些就到时候具体类, 具体分析了.

在UNetConnection里面有存储了所有Channels的数组, 索引对应UChannel的索引.

和一个OpenChannels 所有正在使用的有效的UChannel .

创建完成时维护一下之间的关联.

嗯, 完毕.

本文呢, 实际上, 我们又又又又认识了一堆乱七八糟的东西, 还是没有什么实质性的进展.

客户端还是没有和服务器连接成功, 好难啊(狗头)
</code></pre>
</details>

<details>
<summary>UE5 网络相关系列 之UNetConnection初始化</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/494674422
前言
上一篇 : 孤傲雕：孤傲雕：UE5 网络相关系列 之 客户端网络连接的初始化
忙于工作, 所以鸽子了很久
UE5 EA源码版本
序
孤傲雕：UE5 网络相关系列 之 客户端网络连接的初始化

书接前文, 已经有点久远了.

前面, 我们笼统的讲了一下客户端的UIpNetDriver::InitConnect, 认识了一些新的类, 草草带过了UNetConnection的创建初始化


前文提到过, 客户端的NetConnection是在UNetDriver::InitConnect时创建并初始化的

通过NewObject创建对象, 调用C++的构造函数, 初始化默认属性

然后调用UNetConnec::InitLocalConnection 进行初始化, 参数有NetDriver和它刚刚创建的Socket ,URL(服务器地址)和Socket状态.

同UNetDriver, UNetConnection 也是服务器和客户端公用一个相同的类

所以, 也有一个基础的UNetConnection::InitBase函数

在整个UNetConnection创建初始化过程中, 又做了很多很多事情

本文将一步步展开, 进行一定的说明描述

UIpConnection::UIpConnection

在UNetConnection::UNetConnection初始化中有如上代码, 关键值是CVarMaxChannelSize,这是一个命令行变量



默认值是UNetConnection::DEFAULT_MAX_CHANNEL_SIZE 值为32767, 抛开UControlChannel和UVoiceChannel固定占用的0和1位置, 也就是说, 剩下的留给Actor可用的通道只有32765个.

这个值, 嗯, 根据实际的项目可以进行扩大或缩小, 就可以修改同时存在的网络同步的Actor上限了.

接着, 如果UNetConnection是运行时动态创建的, 不是CDO, 会初始化对应的Channels数组和对应Channels信息的OutReliable、InReliable、PendingOutRec 数组

子类UIpConnection::UIpConnection中没有什么好讲的

当然, 忽略了很多很多初始化的值, 用到再说.

UNetConnection::InitBase
这个函数内内容过多, 所以就打乱一下顺序, 请自行对照源码查看.

输入参数相关的初始化

首先关联对应的NetDriver管理类, 然后设置唯一的UNetConnection连接ID



这个ID通过FNetConnectionIdHandler来申请, 内部有一个TBitArray

这个TBitArray可是一个好玩意, 提供了一个位运算的bool数据, 很有意思, 有兴趣可以自己扒一下 .


然后是这四个状态的初始化 :

切换State为USOCK_Pending

关联对应的服务器路径URL


MaxPacket是一个网络数据包的最大尺寸, 取值为1024


PacketOverhead是这种网络连接属性的数据包开销, 取值为28


UNetConnection的各种时间

接着会初始化一堆时间, UNetDriver::GetElapsedTime 获取的是经过时间, 在UNetDriver::Tick中不断增加

StatUpdateTime是上一次网络的统计时间, 这个在UNetConnection::Tick中每 UNetConnection::StatPeriod(默认值1s)进行一次数据统计

而其他时间, 就是网络数据收发各个状态的时间, 如下:

LastReceiveTime
取值基础为UNetDriver::GetElapsedTime, 是最新一次接收到网络信息的时间
LastReceiveRealtime

取值基础为FPlatformTime::Seconds,是对LastReceiveTime时间信息的补充, 有用做判断连接超时掉线

LastGoodPacketRealtime
取值基础为FPlatformTime::Seconds是最新一次接收到有效网络信息的时间
LastTime
取值基础为FPlatformTime::Seconds, 在UNetConnection::Tick中设置, 最新一次正常Tick的时间
LastTickTime
取值基础为UNetDriver::GetElapsedTime, 绝大多数情况下和LastTime在同一帧取值
LastSendTime
取值基础为UNetDriver::GetElapsedTime, 最新一次发送网络信息的时间取值
LastRecvAckTimestamp
取值基础为UNetDriver::GetElapsedTime, 最新一次收到ACK的时间
ConnectTimestamp
取值基础为UNetDriver::GetElapsedTime, UNetConnection创建初始化的时间


忽略内容
FNetAnalyticsAggregator和FHistogram NetConnectionHistogram数据记录分析相关的, 忽略

重置并初始化TUniquePtr<PacketHandler> Handler 这个前文提到过, 这里也不打算展开, 之后看情况再说.

CurrentNetSpeed当前连接的网络速度, 暂时忽略



UPackageMapClient

最后就是这个UPackageMapClient, 请眼熟它! 请眼熟它! 以后可能应该有大篇幅文章描述他.

UIpConnection::InitBase

IsAddressResolutionEnabled这个玩意是地址解析, 此处及之后默认按开启处理, 暂时忽略

CVarNetEnableCongestionControl是否启用拥塞控制, 嗯, 控制台参数, 默认关闭, 忽略

UIpConnection::InitLocalConnection

最后一步是初始化发送网络数据的缓冲区SendBuffer, 然后再看红色内容地址解析状态标记为等待解析.

再接前文, UIpNetDriver::InitConnect处没有讲的地方进一步展开处理



这个地址解析, 大体是Address Resolution Protocl地址解析协议

这玩意不在讲解范围内, 嗯, 扒拉了一下看不懂也没讲的必要.

大白话这个地址解析就是 :

我是客户端, 我要连接服务器, 但我只有一个服务器的IP, 所以我要先通过IP地址, 通过各种途径(ARP)来先找到服务器的实际位置, 比如中间要经过那些设备跳转啊, 服务器最后到底是谁啊(MAC地址)等等

大致就这样吧, 这玩意, 嗯, 陷进去查查资料啥的, 烦得很.

尾声
经过近三篇文章漫长的初始化, 我写的头大, 估计你们看的也头大.

看着内容杂七杂八的, 东一块, 西一块, 唉~~~


但胜利的曙光已经可以看到了, 在客户端初始化之后, 就是这里SendInitialJoin : NMT_Hello 了

孤傲雕：UE4 网络相关之网络连接的建立UPendingNetGame

是的, 接下来就到了这一步了!

才怪, 接下来是 :

客户端向服务器发送的第一个数据包, 建立连接的过程
服务器端UNetConnection的创建
再然后才是这些NMT的来来回回

</code></pre>
</details>

<details>
<summary>UE5 网络相关系列 之客户端和服务器的握手请求</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/528871087
前言
上一篇 : 孤傲雕：UE5 网络相关系列 之UNetConnection初始化
UE5 5.0.2源码版本(糟糕的消息, 好像网络这一块的源码开始有一定调整了)
文章过长, 容易太长不看, 嗯, 还请点击右上角手动关闭
引子
书接前文, 至此:

客户端和服务器各自的UNetDriver已经初始化完毕
客户端和服务器连接的UNetConnection也初始化完成
那接下来就是客户端向服务器建立连接, 正式开始通讯了.



UE4 使用的是UDP通讯协议, 而不是TCP通讯协议, 这个大家都知道.

TCP中会通过三次握手来建立连接:

第一次握手-客户端向服务器 : 发起建立连接的请求(客户端能发)
第二次握手-服务器向客户端 : 我同意你的连接请求，同时我也向你发起建立连接的请求(服务器能收, 服务器能发)
第三次握手-客户端向服务器 : 我同意建立连接。(客户端能收)
三个请求过后, 客户端和服务器的通信能力就被确认了, 相互之间能正常通讯.

不然如果网络都不通, 嗯...

UE4是UDP通讯, 也有类似的模拟握手请求的处理, 本文就是对UE4中对连接建立相关的部分代码解析.

PacketHandler::BeginHandshaking

在前文, 最后会调用PacketHandler::BeginHandshaking开始进行握手请求, 实际触发的是 StatelessConnectHandlerComponent::NotifyHandshakeBegin

那握手实际的处理类是StatelessConnectHandlerComponent 它喽, 参考注释

/** * PacketHandler component for implementing a stateless (non-memory-consuming) connection handshake * * Partially based on the Datagram Transport Layer Security protocol. */ StatelessConnectHandlerComponent它用于实现无状态（非内存消耗）连接握手的PacketHandler。组件部分基于数据报传输层安全协议。
嗯, 参考一头文件, 嗯, 大致时序如下:

FInitialPacket(NotifyHandshakeBegin)
客户端向服务器 : 发送消息(客户端能发)
FChallengePacket(SendConnectChallenge)
服务器向客户端 : 收到, 请回复(服务器能收, 服务器能发)
FResponsePacket(SendChallengeResponse)
客户端向服务器 : 收到, 既然能正常发送, 那么我进入下一步了!(客户端能收)
FAckPacket(SendChallengeAck)
服务器向客户端 : 对相关数据进行进一步的验证, 一切正常, 那可以
在客户端最后收到FAckPacket后, 就开始NMT_Hello等逻辑请求了.

整体握手流程
FInitialPacket

// 开始握手连接
// 实际数据包结构(伪代码)
struct FInitialPacket // 共228位
{
	// 前置内容, 最大32位
	uint8 MagicHeader;
	// 第1位 值1
	// 表明这是握手协议
	uint8 bHandshakePacket :1;
	// 第2位 值0
	// 表明这是一次重新开始的握手请求, 重置所有状态
	uint8 bRestartHandshake:1;
	// 第3位 值0
	// 表明使用的对应的密码索引
	uint8 SecretIdPad:1;
	// 第4位->第227位 值都为0
	// 占位用
	uint8 PacketSizeFiller[28];
	// 第228位 值1
	// 最后一位, 表示数据结束
	uint8 TerminationBit:1;
};
首先, 我们先看发送数据拼接这一块StatelessConnectHandlerComponent::NotifyHandshakeBegin, 最后数据格式如上结构体, 通过FBitWriter写入二进制数据.

PacketSizeFiller是占位数据, 防止DRDoS攻击

简单描述且联系上下文就是, 客户端会发送228位的数据请求, 然后服务器收到解析后也发送228位数据回去, 客户端和服务器来回的数据大小是差不多的, 耗费流量一致.

所以, 客户端模拟数据包攻击, 要付出相同的成本代价, 如果没有这些占位符.

嗯, 客户端4bit换服务器228bit, 血赚(实际上还有UDP报文格式, 实际远不只4位)


最后内存中的实际内存数据, 右边是对应的二进制数据.


UIpNetDriver::IsNetResourceValid该函数会判断Socket是否存在有效

由于前文提到过的地址解析异步, 会稍迟一段时间才可以有效通过

第一次有效发送, 反而是客户端觉得服务器没有回应, 才再次发送的(见后文丢包重发)


接着就是通过UIpConnection::LowLevelSend发送, 跟到底是FSocket::SendTo

Socket的处理, 就不再啰嗦了

至此, 成功地拼接出一个握手连接建立请求的数据包, 接下来客户端就是不断重试直到服务器处理返回了.

FChallengePacket

服务器会在UIpNetDriver::TickDispatch中不断地对收到的网络数据包进行处理, 当找不到地址对应的UNetConnection网络连接时, 会当做无连接数据包调用UIpNetDriver::ProcessConnectionlessPacket处理, 其中兜兜转转又会返回到StatelessConnectHandlerComponent::IncomingConnectionless类进行处理


如果是初始化连接, 收到的是FInitialPacket

那么调用StatelessConnectHandlerComponent::SendConnectChallenge向该地址发起连接质询, 其中会生成给客户端发送一个唯一的Cookie码, 当做标识符.

// 服务器相应握手连接
// 实际数据包结构(伪代码)
struct FChallengePacket // 共228位
{
	// 前置内容, 最大32位(可选)
	uint8 MagicHeader;
	// 第1位 值1
	// 表明这是握手协议
	uint8 bHandshakePacket :1;
	// 第2位 值0
	// 表明这是一次重新开始的握手请求, 重置所有状态
	uint8 bRestartHandshake:1;
	// 第3位 值0
	// 表明使用的对应的密码索引
	uint8 SecretIdPad:1;
        // 第4位->第67位 值取 Driver->GetElapsedTime(), 为一个大于0的值
	// 服务器发送时的时间
	double Timestamp;
	// 第68位->第227位 值根据地址时间秘钥等动态生成
	// 一个Cookie验证码
	uint8 Cookie[20];
	// 第228位 值1
	// 最后一位, 表示数据结束
	uint8 TerminationBit:1;
};
发送的内容如上

之前的占位内容, 被替换成了一个时间和一个动态生成的Cookie(参考后文中的Cookie验证相关)

此时, 服务器接收到客户端的FInitialPacket握手请求, 然后向客户端发送FChallengePacket, 包含时间和动态生成的Cookie, 等待客户端的进一步响应.

FResponsePacket

前文提到过, 在UIpNetDriver::TickDispatch中会不断地处理网络数据包, 由于客户端接收到服务器的数据, 这个地址的服务器UNetConnection 已经创建过了, 那么走的就是另一个流程UNetConnection::ReceivedRawPacket , 然后兜兜转转, 又到了StatelessConnectHandlerComponent::Incoming里面进行处理


此时, 解析服务器的时间, 值大于0, 是FChallengePacket的数据包, 切换客户端本地状态成InitializedOnLocal 标记本地初始化完成.

// 客户端回复服务器相应
// 实际数据包结构(伪代码)
struct FResponsePacket // 共228位
{
	// 前置内容, 最大32位(可选)
	uint8 MagicHeader;
	// 第1位 值1
	// 表明这是握手协议
	uint8 bHandshakePacket :1;
	// 第2位 值0
	// 表明这是一次重新开始的握手请求, 重置所有状态
	uint8 bRestartHandshake:1;
	// 第3位 值 取服务器FChallengePacket中值
	// 表明使用的对应的密码索引
	uint8 SecretIdPad:1;
	// 第4位->第67位 值 取服务器FChallengePacket中值
	// 服务器发送时的时间
	double Timestamp;
	// 第68位->第227位 值 取服务器FChallengePacket中值
	// 一个Cookie验证码
	uint8 Cookie[20];
	// 第228位 值1
	// 最后一位, 表示数据结束
	uint8 TerminationBit:1;
};
此时, 客户端不断的调用StatelessConnectHandlerComponent::SendChallengeResponse拼接FResponsePacket的数据包内容, 向服务器发送.

由于Timestamp和Cookie都是服务器动态生成的, 所以客户端此时除了收发能力外,还有一定的数据解析处理能力.

FAckPacket
最后, 当服务器在StatelessConnectHandlerComponent::IncomingConnectionless中接收到非FInitialPacket初始化数据包后, 就当做FResponsePacket处理, 并验证Cookie数据是否有效(见后文)

// 服务器最终确认客户端连接的回复
// 实际数据包结构(伪代码)
struct FAckPacket // 共228位
{
	// 前置内容, 最大32位(可选)
	uint8 MagicHeader;
	// 第1位 值1
	// 表明这是握手协议
	uint8 bHandshakePacket :1;
	// 第2位 值0
	// 表明这是一次重新开始的握手请求, 重置所有状态
	uint8 bRestartHandshake:1;
	// 第3位 值1
	// 表明使用的对应的密码索引, 此时为无效占位值
	uint8 SecretIdPad:1;
	// 第4位->第67位 值 -1
	// 服务器发送时的时间
	double Timestamp;
	// 第68位->第227位 值 取客户端FResponsePacket中值
	// 一个Cookie验证码
	uint8 Cookie[20];
	// 第228位 值1
	// 最后一位, 表示数据结束
	uint8 TerminationBit:1;
};
保存一份客户端的地址和Cookie数据后, 便通过StatelessConnectHandlerComponent::SendChallengeAck发送类FAckPacket数据包给客户端.


接着, 在UIpNetDriver::ProcessConnectionlessPacket中, 处理完数据包后, 正式建立该客户端地址对应的UNetConnection, 里面初始化过程, 嗯, 再单开文章吧.


而客户端最后还是在StatelessConnectHandlerComponent::Incoming中接收处理到FAckPacket信息

然后, 整个握手请求状态完成, 客户端即将触发UPendingNetGame::SendInitialJoin进入NMT相关流程



至此, 整个握手流程结束.

额外补充
握手数据包丢失, 服务器无回信的处理
客户端和服务器之间收发的消息概率会丢包或者数据包数据异常, 凡是有概率发生的事情一定会发生, 那重试功能就必不可少了.

在StatelessConnectHandlerComponent::Tick 中, 当客户端状态不是Handler::Component::State::Initialized(即没有初始化成功的时候)会隔一段时间检测一下状态, 然后发送第一次或者第三次握手请求, 不断的进行轮询.


而服务器, 则不断的等客户端的消息, 收到后处理并返回客户端

向客户端发送数据丢了, 不做任何处理, 过段时间客户端会当做自己发送失败, 重试.
向客户端发送数据成功, 客户端根据逻辑进入第三步或者完成握手连接操作
反正, 客户端不断的进行轮询, 不断地发送握手请求, 服务器只是接收并处理.

当所有握手请求流程都走完的时候, 就一切正常, 连接建立.

如果卡壳, 连接迟迟无法建立, 就会触发连接超时, 断开连接并报ENetworkFailure相关错误.

Cookie验证相关

上午中, 有提到过, Cookie是通过StatelessConnectHandlerComponent::GenerateCookie动态生成, 服务器会发送给客户端并在收到回复后进行验证.

浏览上下文代码, 不难发现, 服务器在接收到那些客户端地址的FInitialPacket数据时并没有保存任何信息

嗯, 假设服务器保存, 那模拟客户端只发不收单纯骚扰的话, 被攻击的时候, 嗯...

所以就导致, 实际上, 如果客户端足够聪明, 是可以直接模拟向服务器发送FResponsePacket, 只发不收, 伪造数据.当伪造成功, Cookie被验证通过的话, 那么服务器就会认为和客户端连接建立成功, 创建对应的UNetConnection连接了并进行后续的各种网络操作

嗯, 如果这个操作很容易的话, 那攻击炸掉一个UE4服务器还是很轻松的.

所以我们再进一步看一下Cookie的生成和验证相关.


内部实现如上, 就是一个用一些信息通过哈希生成Cookie

生成参数有客户端的地址字符串, 当前时间, 使用的秘钥索引, 秘钥索引通过!!SecretID强制取0或1并从HandshakeSecret中读取实际的秘钥, 客户端本身是不知道秘钥内容的.

所有内容中, 客户端不知道的只有秘钥本身.

如果秘钥本身泄露的话, 哪怕没有泄露, 通过Hash暴力计算, 也是可以推出这个秘钥的.

然后, 就可以轻松的模拟数据包, 炸掉UE4服务器, 甚至整个项目的所有服务器



所以, 这个秘钥不可能是固定值, 会在StatelessConnectHandlerComponent::Tick中不断地进行更新.

不断交替重置索引0和索引1的秘钥, 一次只更新一个并标记当前正在使用该索引.

嗯, HandshakeSecret是个秘钥数组 , 秘钥个数为SECRET_COUNT定值2, 单个秘钥长度SECRET_BYTE_SIZE定值64

那为什么有两个秘钥呢? 同时为什么每个数据包发送的时候都有一个bit表示使用的是哪一个秘钥?

一个秘钥不行吗?







列个时序如下

00:00 秘钥A=22, 开始全部使用秘钥A
00:02 客户端X进行FInitialPacket请求, 通过秘钥A生成Cookit
00:05 秘钥B=33, 开始全部使用秘钥B
00:06 客户端Y进行FInitialPacket请求, 通过秘钥B生成Cookit
00:07 客户端X进行FResponsePacket请求, 使用服务器FChallengePacket包中旧秘钥A22生成的Cookit(成功)
00:09 客户端Y进行FResponsePacket请求, 使用服务器FChallengePacket包中旧秘钥B33生成的Cookit(成功)
00:10 秘钥A=44, 开始全部使用秘钥A(此时旧的秘钥A才全部失效)
00:12 客户端X进行FResponsePacket请求, 使用服务器FChallengePacket包中旧秘钥A22生成的Cookit(失败)
00:13 客户端X进行FInitialPacket请求, 通过秘钥A生成Cookit
00:13 客户端Y进行FResponsePacket请求, 使用服务器FChallengePacket包中旧秘钥B33生成的Cookit(成功)
00:14 客户端X进行FResponsePacket请求, 使用服务器FChallengePacket包中旧秘钥A44生成的Cookit(成功)
从上面可以看出, 每次秘钥更新后, 会先停止使用再延迟失效, 中间有很大时间差, 足够客户端完整的进行完整个握手请求了(完成不了基本是网络超时有问题了)

而, 如果没有这个写法, 那么, 嗯, 每次秘钥更新, 之前的所有Cookie立刻全部失效, 是一种很大的浪费.

RestartHandshake地址变化后连接恢复
StatelessConnectHandlerComponent::IncomingConnectionless前文已知, 这里是服务器中对无连接数据包的处理, 如果是握手包, 走之前的逻辑.


前文有淡淡提到过, 服务器处理数据包的时候, 会根据数据包的来源地址, 去获得对应的UNetConnection进行处理, 如果不存在, 那么当做无连接数据包处理

所以, 当数据包是正常有效的, 客户端和服务器已经建立过连接, 但现在找不到对应的UNetConnection时, 可能会在该函数内出现一个 有效数据包被当做无连接数据包处理.

此处情况, 就是客户端的地址发生变化, 找不到对应的UNetConnection了, 连接丢失

那服务器就需要告诉客户端, 连接丢失了, 请重新建立连接, 服务器调用StatelessConnectHandlerComponent::SendRestartHandshakeRequest函数进行通知

// 重新开始握手连接
// 实际数据包结构
struct FRestartPacket // 共2位
{
	// 前置内容, 最大32位(可选)
	uint8 MagicHeader[4];
	// 第1位 值1
	// 表明这是握手协议
	uint8 bHandshakePacket :1;
	// 第2位 值1
	// 表明这是一次重新开始的握手请求, 重置所有状态
	uint8 bRestartHandshake:1;
}; 
发送过程同前文, 发送数据只有两个bit告知客户端重新开始握手连接协议.


客户端接收到之后, 重头开始进行握手协议


同时, 当服务器收到解析完成最后时, 会从所有的客户端连接中, 尝试找到对应Cookie的连接并恢复状态.

成功则皆大欢喜, 失败, 那等连接超时断开, 全部重置

MagicHeader额外信息头

在前面的段落内, 我们知道, 发送或者接收握手请求的时候, 有MagicHeader 的一些处理

这个是一个额外信息, 在每个握手请求数据包的前置二进制字符串, 最大32bits, 该字符串只能包含字符0和字符1



在StatelessConnectHandlerComponent 构造函数内, 会通过命令行变量CVarNetMagicHeader 初始化MagicHeader

这个值呢, 嗯, 从代码的角度内, 但所有对应的维护都是正常的.

那么修改这个命令行变量, 前面附加几位bit, 那么, 这个握手请求的数据结构, 就会变得和其他UE4的不同, 多几位bit, 其他数据bit位顺延

嗯, 如果要模拟UE4客户端握手请求, 此时需要对客户端进一步抓包, 额外添加这几位bit才可以

也可以定制一定的信息, 使得这个MagicHeader运行中动态变化, 加大一定的模拟难度.

毕竟, 这是客户端和服务器的最先开始的网络通讯, 所有UE4项目用的相同的数据包结构, 模拟这样一个数据表, 是非常简单的.
</code></pre>
</details>

<details>
<summary>UE5 网络相关系列之NetControlMessage</summary>
<pre><code>
https://zhuanlan.zhihu.com/p/556200112
前言
上一篇 : 孤傲雕：UE5 网络相关系列 之客户端和服务器的握手请求
UE5 5.0.2源码版本
文章缺少细节, 嗯, 还请点击右上角手动关闭
引子
书接前文, 在客户端服务器连接完全建立之后, 就是UPendingNetGame::SendInitialJoin相关内容了

就是对NMT(NetControlMessage)相关流程, 以及藏在它背后的UControllerChannel.

NMT流程可以参考孤傲雕：UE4 网络相关之网络连接的建立UPendingNetGame一篇很早前的文章.

而NMT相关控制消息不断的发送接收, 背后拉拉扯扯, 就可以慢慢扯出UE网络相关很多底层实现设计了.

内容过多, 先开一个口子, 熟悉一点点, 再慢慢深入

FNetControlMessage<NMT_Hello>
FNetControlMessage<NMT_Hello>::Send(ServerConn, IsLittleEndian, LocalNetworkVersion, EncryptionToken);
从第一个NMT_Hello消息看起, 客户端调用一个模版类的静态函数发送消息

// 0-第一种NMT信息
// uint8-内存大小端存储模式, 1小2大
// uint32-UE项目对应的网络版本, 参考 UE4 网络相关之网络版本获取与比对https://zhuanlan.zhihu.com/p/158986763
// FString-EncryptionToken加密相关
DEFINE_CONTROL_CHANNEL_MESSAGE(Hello, 0, uint8, uint32, FString);
F12跳转看FNetControlMessage, 是通过DEFINE_CONTROL_CHANNEL_MESSAGE宏定义的



可见, 通过传入参数拼接结构体FControlChannelOutBunch, 它继承自FOutBunch, 默认数据可靠, 毕竟服务器客户端之间互相交换的控制信息, 内容很关键.

它源自FNetBitWriter, 根是FArchive 用作序列化的, 在FNetBitWriter中, 对于网络传输数据的序列化, 有特殊的处理.

而FControlChannelOutBunch则对其中的FName和UObject进行特殊处理, 阻挡序列化, 这两种类型不应该在ControlChannel内使用.

也就是说, NMT消息支持FString但不支持FName, 问, 就是网络同步的时候对FName进行了优化, 不是直接转换成FString进行同步的, 而这里不支持, 也没必要支持.

至于UObject? UObject请走UActorChannel来错地方了!



然后, 我们再来看一下NMT_HELLO会拼接出什么样的信息:

最开始是一个uint8类型的NMT_MessageType, 然后当EncryptionToken为空, 此时只会记录int32字符串长度0,

总共统计一下就是8+8+32+32=80bit

ServerConn->Channels[0]是在前文已经初始化成功的UControllerChannel, 他在数组里面固定位置第一个, 调用UControlChannel::SendBunch来发送

UControlChannel::SendBunch


UControlChannel::SendBunch的处理还是比较简单的

它本身有一个发送队列TArray<FQueuedControlMessage>, 储存所有待发送的信息, 如果队列空的就立刻发送, 不为空就先存起来, 在UControlChannel::Tick中排队逐个发送

缓存数据时, 只需要存储NMT本身的数据信息和NMT的类型, 即前文中序列化后的Data数据

之间大的代码, 夹杂一些大于可靠缓存数量, 发送消息过多或者消息本身就有错误的检测, 就不过多啰嗦了

至于最后, 它的发送, 就依靠基础的UChannel::SendBunch了

UChannel::SendBunch

UChannel::SendBunch中对FOutBunch有进一步的处理, 比如拆分较大的Bunch, 给出Bunch排序, 设置一些Bunch属性等等.

UControlChannel是客户端本地打开通道的(见前文), 所以在NMT_Hello的时候 : UControlChanel的第一个消息

FOutBunch::bOpen就标记为True了, 进行特殊处理了, 而客户端的第二个NMT_Login消息就不需要了取值false

所有数据处理完, 就调用UChannel::SendRawBunch发送数据了, 该函数又找到ServerConnection和服务器的连接, 调用UNetConnection::SendRawBunch发送数据了

UNetConnection::SendRawBunch

该函数暂不细讲, 可以大致理解成他是最后一道对发送数据的处理, 仅重点标一下, 他序列化的时候, 会序列化ChannelIndex, UControlChannel 固定为0, 两端对应就很容易了

它会将FOutBunch序列化成BitArray并拼接多个到一个Packet, 并缓存到SendBuffer中, 即打包一起发送

毕竟只是一个Bunch, 一个比较小的数据信息块, 数据量有点小, 如果可以的话

多个Bunch可以合并一起变成一个大的数据块再发送.

而NMT消息是控制流程用的, 嗯, 可靠且希望即使处理, 即使内容很少, 所以往往接着执行UNetConnection::FlushNet , 将当前所有缓存待发送的网络数据信息, 全部发送

最后UNetConnection::LowLevelSend才是最后的发送的位置

UNetConnection::ReceivedRawPacket
服务器在接受到客户端信息后会走到该函数, 然后对Packet信息进行解析, 变成一个个对应的Bunch

前文提到过, 序列化中的信息有ChannelIndex, 所以序列化后Bunch可以很简单的得到, 是UControlChannel的

走进UControlChannel::ReceivedRawBunch入口处理Bunch信息

UChannel::ReceivedRawBunch
由于Bunch是根据ChSequence有顺序排序的, 所以需要按照顺序逐个接收, 具体处理略

实际处理的函数是UChannel::ReceivedNextBunch


由于第一个NMT_Hello是一个bOpen的消息, 所以服务器会特殊处理, 接受客户端对该通道的打开请求, 对OpenPacketId和OpenAcked进行处理

接着就是UChannel::ReceivedSequencedBunch再接UControlChannel::ReceivedBunch了

UControlChannel::ReceivedBunch

这里是对NMT信息的最后解析处理, 此时Bunch的Data数据, 就是前文对应的NMT_Hello拼接出的数据, 按照相同的顺序进行解析即可

读取Bunch数据块中第一个uint8位, 对应前文, 是NMT的消息

然后网络相关就没了, 整体扔给UWorld::NotifyControlMessage进行逻辑处理, 剩下的就是NMT流程兜兜转转, 就不再啰嗦了

本文呢, 实际上, 我们又又又又认识了一堆乱七八糟的东西.

好像跟踪了一些NMT消息的发送流程, 但具体细节缺失好多, 还是没有什么实质性的进展.(狗头)
</code></pre>
</details>